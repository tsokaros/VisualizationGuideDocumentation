{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to The Illinois Numerical Relativity Visualization Primer .toc-container { border: 1px solid #ddd; border-radius: 4px; margin: 1em 0; background-color: #f9f9f9; } .toc-container summary { font-weight: bold; padding: 0.5em 1em; background-color: #f0f0f0; border-bottom: 1px solid #ddd; cursor: pointer; } .toc-container summary:hover { background-color: #e0e0e0; } .toc-content { padding: 0.5em 1em; } .toc-content ul { margin: 0; padding-left: 1.5em; } .affiliations { font-family: Arial, sans-serif; font-size: 14px; line-height: 1.5; font-style: italic; } Eric Yu 1,2 , Shreyas Jammi 1,2 , Mit Kotak 1,2 , Antonios Tsokaros 1,2,3 , Milton Ruiz 4 , and Stuart L. Shapiro 1,2 1 Department of Physics, University of Illinois at Urbana-Champaign, Urbana, IL 61801, USA 2 National Center of Supercomputing Applications, University of Illinois at Urbana-Champaign, Urbana, IL 61801, USA 3 Research Center of Astronomy and Applied Mathematics, Academy of Athens, Athens 11527, Greece 4 Departament d\u2019Astronomia i Astrof\u0131\u0301sica, Universitat de Val\u00e8ncia, C/ Dr Moliner 50, 46100, Burjassot (Val\u00e8ncia), Spain Abstract Over the past several decades the advent of new algorithms and new computers made possible numerous advances in computational physics, including numerical relativity, the computational study of Einstein\u2019s equations of general relativity. Full 3+1-dimensional simulations of black holes and neutron stars that could include magnetic fields and detailed microphysics has become possible, and together with them, the need to analyze complicated large sets of data. Visualizing such datasets is important in order to better understand the problem at hand, as well as to efficiently communicate cutting-edge research to a larger audience. One open source software package that has emerged as a leader in supercomputing visualization, especially in the field of numerical relativity, is VisIt. This document describes techniques developed in the Relativity Group at the University of Illinois at Urbana-Champaign over the past couple of decades to visualize numerical relativity simulations using the VisIt software. This guide is meant to be used as a resource for implementing visualizations using VisIt for numerical relativity and for further improving the visualization efforts of similar computationally intensive studies. Keywords: VisIT; Visualization; Numerical Relativity Contents Contents Introduction Requirements and Feasibility Installation of Windows Installation of Mac Installation of Linux Interacting with VisIT Interacting with VisIT GUI Interacting with VisIT CLI VisIT Elements Databases HDF5 data VTK Files Plots and Operators Volume rendering Isosurface rendering Vector fields Streamline integration Expressions Exporting Attributes Finalizing Images Typical VisIT Workflow in Numerical Relativity Black Holes and Spin Vectors Density Isosurface Volume Magnetiuc Field Lines Particle Seeds Grid Seeds Fluid Velocity Arrows Case Study: Magnetars Poloidal Field Lines Toroidal Field Lines Final Image and Summary Case Study: Black Hole with Accretion Disk Isosurface Rendering of Disk Volume Rendering of Disk Magnetic Field Lines Around the Black Hole Visualizing a Relativisitic Jet Case Study: Binary Neutron Stars Before Black Hole Formation After Black Hole Formation Additional Plots After Merger Case Study: Binary Black Hole with Accretion Disk Magnetic Field Lines in the Disk Two Black Holes Visualizing Gravitational Waves Post-Processing Implementation Three Dimensional Volume Plot Two Dimensional Contour Plot","title":"Home"},{"location":"#welcome-to-the-illinois-numerical-relativity-visualization-primer","text":".toc-container { border: 1px solid #ddd; border-radius: 4px; margin: 1em 0; background-color: #f9f9f9; } .toc-container summary { font-weight: bold; padding: 0.5em 1em; background-color: #f0f0f0; border-bottom: 1px solid #ddd; cursor: pointer; } .toc-container summary:hover { background-color: #e0e0e0; } .toc-content { padding: 0.5em 1em; } .toc-content ul { margin: 0; padding-left: 1.5em; } .affiliations { font-family: Arial, sans-serif; font-size: 14px; line-height: 1.5; font-style: italic; }","title":"Welcome to The Illinois Numerical Relativity Visualization Primer"},{"location":"References/","text":"Reference [1] T. W. Baumgarte and S. L. Shapiro. Numerical Relativity: Solving Einstein\u2019s Equations on the Computer. Cambridge University Press, Cambridge, UK, 2010. doi: 10.1017/cbo9781139193344. [2] T. W. Baumgarte, S. L. Shapiro, and M. Shibata. Astrophys. J., 528:L29, 2000. [3] H. Childs, E. Brugger, B. Whitlock, J. Meredith, S. Ahern, D. Pugmire, K. Biagas, M. Miller, C. Harrison, G. H. Weber, H. Krishnan, T. Fogal, A. Sanderson, C. Garth, E. W. Bethel, D. Camp, O. R\u00a8ubel, M. Durant, J. M. Favre, and P. Navr\u00b4atil. Visit: An end-user tool for visualizing and analyzing very large data. In High Performance Visualization\u2013Enabling Extreme-Scale Scientific Insight, pages 357\u2013372. October 2012. doi: 10.1201/b12985. [4] Z. B. Etienne, V. Paschalidis, R. Haas, P. M\u00a8osta, and S. L. Shapiro. Illinoisgrmhd: an open- source, user-friendly grmhd code for dynamical spacetimes. Classical and Quantum Gravity, 32(17):175009, Aug. 2015. ISSN 1361-6382. doi: 10.1088/0264-9381/32/17/175009. URL http://dx.doi.org/10.1088/0264-9381/32/17/175009. [5] C. Reisswig and D. Pollney. Notes on the integration of numerical relativity waveforms. Classical and Quantum Gravity, 28(19):195015, sep 2011. doi: 10.1088/0264-9381/28/19/195015. URL https://doi.org/10.1088%2F0264-9381%2F28%2F19%2F195015. [6] M. Ruiz, A. Tsokaros, and S. L. Shapiro. Jet launching from merging magnetized binary neutron stars with realistic equations of state. Physical Review D, 104(12), dec 2021. doi: 10.1103/physrevd.104.124049. URL https://doi.org/10.1103%2Fphysrevd.104.124049 [7] M. Ruiz, A. Tsokaros, and S. L. Shapiro. General relativistic magnetohydrodynamic simulations of accretion disks around tilted binary black holes of unequal mass, 2023. [8] N. The HDF Group, Q. Koziol, and U. O. of Science. Hdf5-version 1.12.0, 2 2020. URL https://www.osti.gov//servlets/purl/1631295. [9] A. Tsokaros, M. Ruiz, S. L. Shapiro, and K. Ury\u00afu. Magnetohydrodynamic Simulations of Self-Consistent Rotating Neutron Stars with Mixed Poloidal and Toroidal Magnetic Fields. Phys. Rev. Lett., 128(6):061101, 2022. doi: 10.1103/PhysRevLett.128.061101. [10] K. Uryu, S. Yoshida, E. Gourgoulhon, C. Markakis, K. Fujisawa, A. Tsokaros, K. Taniguchi, and Y. Eriguchi. New code for equilibriums and quasiequilibrium initial data of compact objects. IV. Rotating relativistic stars with mixed poloidal and toroidal magnetic fields. Phys. Rev. D, 100(12):123019, 2019. doi: 10.1103/PhysRevD.100.123019.","title":"References"},{"location":"References/#reference","text":"[1] T. W. Baumgarte and S. L. Shapiro. Numerical Relativity: Solving Einstein\u2019s Equations on the Computer. Cambridge University Press, Cambridge, UK, 2010. doi: 10.1017/cbo9781139193344. [2] T. W. Baumgarte, S. L. Shapiro, and M. Shibata. Astrophys. J., 528:L29, 2000. [3] H. Childs, E. Brugger, B. Whitlock, J. Meredith, S. Ahern, D. Pugmire, K. Biagas, M. Miller, C. Harrison, G. H. Weber, H. Krishnan, T. Fogal, A. Sanderson, C. Garth, E. W. Bethel, D. Camp, O. R\u00a8ubel, M. Durant, J. M. Favre, and P. Navr\u00b4atil. Visit: An end-user tool for visualizing and analyzing very large data. In High Performance Visualization\u2013Enabling Extreme-Scale Scientific Insight, pages 357\u2013372. October 2012. doi: 10.1201/b12985. [4] Z. B. Etienne, V. Paschalidis, R. Haas, P. M\u00a8osta, and S. L. Shapiro. Illinoisgrmhd: an open- source, user-friendly grmhd code for dynamical spacetimes. Classical and Quantum Gravity, 32(17):175009, Aug. 2015. ISSN 1361-6382. doi: 10.1088/0264-9381/32/17/175009. URL http://dx.doi.org/10.1088/0264-9381/32/17/175009. [5] C. Reisswig and D. Pollney. Notes on the integration of numerical relativity waveforms. Classical and Quantum Gravity, 28(19):195015, sep 2011. doi: 10.1088/0264-9381/28/19/195015. URL https://doi.org/10.1088%2F0264-9381%2F28%2F19%2F195015. [6] M. Ruiz, A. Tsokaros, and S. L. Shapiro. Jet launching from merging magnetized binary neutron stars with realistic equations of state. Physical Review D, 104(12), dec 2021. doi: 10.1103/physrevd.104.124049. URL https://doi.org/10.1103%2Fphysrevd.104.124049 [7] M. Ruiz, A. Tsokaros, and S. L. Shapiro. General relativistic magnetohydrodynamic simulations of accretion disks around tilted binary black holes of unequal mass, 2023. [8] N. The HDF Group, Q. Koziol, and U. O. of Science. Hdf5-version 1.12.0, 2 2020. URL https://www.osti.gov//servlets/purl/1631295. [9] A. Tsokaros, M. Ruiz, S. L. Shapiro, and K. Ury\u00afu. Magnetohydrodynamic Simulations of Self-Consistent Rotating Neutron Stars with Mixed Poloidal and Toroidal Magnetic Fields. Phys. Rev. Lett., 128(6):061101, 2022. doi: 10.1103/PhysRevLett.128.061101. [10] K. Uryu, S. Yoshida, E. Gourgoulhon, C. Markakis, K. Fujisawa, A. Tsokaros, K. Taniguchi, and Y. Eriguchi. New code for equilibriums and quasiequilibrium initial data of compact objects. IV. Rotating relativistic stars with mixed poloidal and toroidal magnetic fields. Phys. Rev. D, 100(12):123019, 2019. doi: 10.1103/PhysRevD.100.123019.","title":"Reference"},{"location":"Section1/","text":"Introduction .link { text-align: center; font-size: 16px; } .textstuff { font-size: 17px; } VisIt is an open-source visualization and analysis tool for large data sets often used to create computationally complex visualizations. The uniqueness of VisIt that separates it from similar visualization software lies in the method in which it handles and models the input data. Rendering realistic physics simulations is often computationally intensive, especially when using the massive data sets output by large-scale numerical simulations. Optimized processing and rendering techniques are crucial in the field of numerical relativity for this very reason, as creating accurate and self- consistent visualizations is impossible without these added techniques due to the magnitude of complexity involved in the data itself. The first part of this guide is geared as a general overview of VisIt for numerical relativity researchers. We will go over the installation process and user guide for local machines and supercomputers. Then we will introduce relevant aspects of VisIt by walking through sample visualizations using small datasets. After this introduction, we will discuss a typical workflow with VisIt in numerical relativity before providing a suite of case studies of visualizations we\u2019ve made over the past years and the specific techniques we used. Throughout the document, we will reference small data files and scripts, which can be found in the following repository: https://github.com/tsokaros/Illinois-NR-VisIt-Guide We will reference this repository using the prefix VisIt-Guide . If we want to point to a file called ex_file.ext located in the folder ex_folder inside of the repository, we will write VisIt-Guide/ex_folder/ex_file.ext . These file locations will also be hyperlinks that point to the file on GitHub.","title":"Introduction"},{"location":"Section1/#introduction","text":".link { text-align: center; font-size: 16px; } .textstuff { font-size: 17px; } VisIt is an open-source visualization and analysis tool for large data sets often used to create computationally complex visualizations. The uniqueness of VisIt that separates it from similar visualization software lies in the method in which it handles and models the input data. Rendering realistic physics simulations is often computationally intensive, especially when using the massive data sets output by large-scale numerical simulations. Optimized processing and rendering techniques are crucial in the field of numerical relativity for this very reason, as creating accurate and self- consistent visualizations is impossible without these added techniques due to the magnitude of complexity involved in the data itself. The first part of this guide is geared as a general overview of VisIt for numerical relativity researchers. We will go over the installation process and user guide for local machines and supercomputers. Then we will introduce relevant aspects of VisIt by walking through sample visualizations using small datasets. After this introduction, we will discuss a typical workflow with VisIt in numerical relativity before providing a suite of case studies of visualizations we\u2019ve made over the past years and the specific techniques we used. Throughout the document, we will reference small data files and scripts, which can be found in the following repository: https://github.com/tsokaros/Illinois-NR-VisIt-Guide We will reference this repository using the prefix VisIt-Guide . If we want to point to a file called ex_file.ext located in the folder ex_folder inside of the repository, we will write VisIt-Guide/ex_folder/ex_file.ext . These file locations will also be hyperlinks that point to the file on GitHub.","title":"Introduction"},{"location":"Section10/","text":"Visualizing Gravitational Waves In this section we will discuss how to visualize gravitational waves using numerical relativity simulation data. Gravitational wave movies can provide helpful intuition about the systems being simulated. When they are examined in conjunction with movies of the sources that produce them, broad insights related to gravitational wave emission can be deduced. These visualizations will use the following simulation output database: Psi4_rad.mon.# : ASCII files containing the Newman-Penrose scalar decomposed into s = \u22122 spin-weighted spherical harmonics \u03c8 4 lm . There are multiple files with # = 1,2,...,9 that correspond to different extraction radii r areal . These files have columns t \u2225 Re(\u03c8 4 22 ) \u2225 Im(\u03c8 4 22 ) \u2225 Re(\u03c8 4 21 ) \u2225 Im(\u03c8 4 21 ) \u2225 \u00b7 \u00b7 \u00b7 \u2225 Im(\u03c8 4 last mode ) \u2225 r areal \u2225 \u27e8g tt \u27e9 \u2225 \u27e8g tr \u27e9 \u2225 \u27e8g rr \u27e9 The last three columns are averages of metric components. The fourth from the last column is the extraction radius rareal. This value is relatively constant across a single file and is far enough from the origin (where the compact objects are located) so that we are in the radiation zone. Multiple files #=1,2,...,9 that correspond to different rareal are output so that we can confirm that the gravitational wave amplitude falls of like r \u22121 and otherwise does not depend on the extraction radius. The first column is the simulation time t. The rest of the columns are the real and imaginary components of \u03c8 4 decomposed into \u03c8 4 lm , which are the s = \u22122 spin-weighted spherical harmonics -2 Y lm (\u03b8, \u03d5) [1]. $$ \\psi_4(t, \\theta, \\phi) = \\sum_{l=2}^{\\infty} \\sum_{m=-l}^{l} \\psi_4^{lm}(t) \\; {}^{-2}Y_{lm}(\\theta, \\phi) $$ For example: columns 2, 3 are modes (l, m) = (2, 2); columns 4, 5 are modes (l, m) = (2, 1); columns 6, 7 are modes (l, m) = (2, 0) (note that we count down from m = l to m = \u2212l). Continuing this pattern, and noting that there are five l = 2 modes, seven l = 3 modes, etc., we know that Columns 2 through 11 are the l = 2 modes Columns 12 through 25 are the l = 3 modes Columns 26 through 43 are the l = 4 modes and so on. In the Illinois GRMHD code, for binary black hole simulations, we output the first thirty modes. This means that there are 2 \u2217 30 + 5 = 65 columns in the Psi4 rad.mon.# file (real and imaginary column for each mode plus the five additional columns). In this case, the last mode output would be (l, m) = (5, \u22123). This file gives one-dimensional data of the \u03c84 scalar as a function of time t that is extracted at a radius rareal from the origin. In order to turn this into 3D data of the gravitational wave strain h(t, r, \u03b8, \u03d5) that we can visualize and turn into a movie, a considerable amount of post-processing must be done. The \u2018plus\u2019 and \u2018cross\u2019 polarizations of the strain h are related to \u03c8 4 by \u03c8 4 = h\u00a8 + \u2212 ih\u00a8 \u00d7 Thus in order to get the strain, we must perform a double time integration on \u03c8 4 lm (t). Following the method described in [5], we perform this double-time integration by dividing by \u03c9 2 in Fourier space. For frequencies close to zero, the calculation of the singular integral becomes inaccurate, therefore a cutoff frequency \u03c90 is introduced [5]. We set \u03c90 equal or less than the initial orbital angular velocity of the system (for the most dominant (2, 2) mode). Implementation-wise, the Fourier transforms are done with a standard Fast Fourier Transform with padding added to each end of the time-domain signal. After this double-time integration, we will have the values C lm as a function of time: $$ C_{lm}(t) = \\int_{-\\infty}^{t} dt' \\int_{-\\infty}^{t'} dt'' \\, \\psi_4^{lm}(t'') $$ At this step, we have an array of the C lm (t) that is a function of time. We already have the angular dependence from the spherical harmonics -2 Y lm (\u03b8, \u03d5). In order to obtain the radial dependence, we will have to consider how the amplitude of h falls as 1/r, as well as the time retardation t = t(r) due to the time it takes the signal to reach the observer at the radiation zone (at position r areal ). To add the time retardation, we consider howC lm (r) should look like at a fixed time t = t0. We define a retarded time: $$ t_0(r) = \\begin{cases} t_0 - r & \\text{if } t_0 \\ge r \\\\ 0 & \\text{if } t_0 < r \\end{cases} $$ Note that in units of c = 1, the speed of gravitational waves is one. Therefore at a radius r, we want to use the data \u201cfrom the past\u201d at time t0(r) = t0 \u2212 r. If our fixed time, t0, is relatively early in the simulation so that t0 < r, then it would have been impossible for a wave to propagate from the origin to that radius r. In that case we set t0(r) equal to the first simulation time t = 0. Since there might be numerical errors that cause C lm (t = 0) to be nonzero everywhere, we manually set C lm (t = 0) = 0. Then we can add this time retardation, along with the 1/r dependence to get radial dependence at a fixed time t0 using $$ C_{lm}(t_0, r) = \\frac{1}{r} \\, C_{lm}(t_0(r)) $$ Then we can get the 3D data of the gravitational wave strain at a fixed time t0 using $$ \\frac{1}{2} \\left( h_+(t_0, r, \\theta, \\phi) - i h_\\times(t_0, r, \\theta, \\phi) \\right) = \\frac{1}{r} \\sum_{l=2}^{\\infty} \\sum_{m=-l}^{l} C_{lm}(t_0(r)) \\, {}^{-2}Y_{lm}(\\theta, \\phi) $$ The individual polarization h+ (h\u00d7) can be obtained by taking the real (imaginary) part of this expression. Using the method described above, we are able to create a 3D data file that contains the gravitational scalar field h+ or h\u00d7 for every time from our original Psi4 rad.mon.# file. In the following sections, we will discuss some nuances about the implementation as well as the specifics about how to generate data files that can be visualized in VisIt using two different rendering techniques. Post-Processing Implementation The first thing we must do is choose the grid parameters of the 3D data that we will generate. A choice that we make in the Illinois Relativity Group is to visualize the strain only in the lower half z < 0 space. Since the orbital angular momentum in our binary simulations points in the z\u02c6 direction, plotting the strain in z < 0, gives a cross-section on the xy-plane as viewed from above (i.e. a bird\u2019s eye view from a point on the positive z axis). We choose a grid where the xy slices are squares of length 2L. Since we only want to plot z < 0, we use a grid such that (x, y, z) \u2208 [\u2212L, L] \u00d7 [\u2212L, L] \u00d7 [0, L]. We want to pick L large enough such that we can observe the outward propagation of the waves. For the images above, we used L = 75 (remembering that c = 1). Additionally, we will need to choose the number of grid points in the x, y, z directions, which we will denote by nx, ny, nz. We\u2019ve found that having a grid spacing of 1 in code units is enough to produce good visualizations. For now on, we will adopt the notation i, j, k when refering to the x, y, z indices of our grid. Assuming L = 75 with (nx, ny) = (150, 150) and nz = 75, then (i, j, k) = 0, 0, 0 would correspond to (x, y, z) = (\u221275, \u221275, \u221275) and (i, j, k) = (149, 149, 74) would correspond to (x, y, z) = (75, 75, 0). After we\u2019ve chosen our grid, we create lookup tables that give us the values of -2 Y lm (\u03b8, \u03d5) = -2 Y lm (x, y, z) and r = r(x, y, z) at each grid point since these values will be used at each time step and can be rather expensive to compute (especially the -2 Y lm ). The lookup tables for -2 Y lm will be arrays of shape [n x,n y,n z,n modes] ([n x,n y,n z]) that we can access as Ylm[i,j,k,m] (r[i,j,k]). Here n x, n y, n z are nx, ny, nz and n modes is the number of lm-modes that were in the output Psi4 rad.mon.# files (i.e. n_modes is P N l=1 P l m=\u2212l 1 = N(N + 2) where the sum is cutoff at l = N while theoretically it should extend to \u221e). Then we can start calculating h+ and h\u00d7. The lm (t) that we obtain by double time integrating \u03c8 4 lm (t) is a function of time and the lm-modes. It can be loaded into an array of the shape [n times, n modes] that we can access as Clm[t,m]. Here n times is the number of iteration times (i.e. the number of rows) in our output Psi4 rad.mon.# file. In order to apply Eq. 5 to this array, we need to express Eq. 4 in terms of indices. To do this, we need the time step dt between times. Then we can use rt = ((t - (r / dt)).astype(int)).clip(min=0) to implement Eq. 5. This example is in Python, and r is the lookup table NumPy array for r and t is the index for the time. This way, t and r/dt both have \u201cindex\u201d dimensions. It is then cast as an integer and all negative values are set to zero so that rt is an array of indices (that we can access as rt[i,j,k]). Then NumPy allows us to simply do Clm_ijk = Clm[rt,:] to implement Eq. 5 and create an array Clm ijk of shape [n x,n y,n z,n modes]. This is now the same shape as the lookup table Ylm so now Eq. 6 can be implemented by summing over the lm-modes and dividing by the r lookup table hplus_hcross = 2*(1/r)*np.einsum('ijkm->ijk', Clm_ijk*Ylm) where we have used NumPy\u2019s einsum method to sum over the modes. Then h+ and h\u00d7 can be obtained by taking the real and imaginary parts of the hplus hcross array of complex numbers. Moving forward, we refer to either h+ or h\u00d7 as simply h (or h). At a fixed time t*dt (remember that t is an index), we have obtained an array h=h[i,j,k]. The last remaining step before we discuss visualization is how to store the data contained in this array in a format that is usable by VisIt. We will use .vtk files to store this scalar data. The first thing we have to do is setup the header of the .vtk file. We will use the option DATASET STRUCTURED POINTS since we have a predefined grid with fixed spacing. The DIMENSIONS field is n x, n y, n z (150, 150, 75 with the grid we\u2019ve been using). The ORIGIN field is the minimum value of the x, y, z coordinates which is \u2212L for all three (with our choice of L it is -75 -75 -75). The SPACING field is spacing between grid points in each direction. Since we are going from -75 to 75 with 150 points, the spacing is actually (2L+ 1)/nx (for our choice, the spacing in the x, y directions is 151/150 \u2248 1.00666 and the spacing in the z direction is 76/75 \u2248 1.01333). Having this slight offset between our grid points and the integers helps us avoid a singularity at the origin (since we divide by r). Finally the POINT DATA field is just the product nxnynz (here 150 \u00d7 150 \u00d7 75 = 1687500). After inputting the grid settings in the header, we just have to add the data. According to the .vtk documentation, the STRUCTURED POINTS option means that we must input our data with the x coordinate increasing the fastest, then the y, and then the z. In NumPy, one way to convert an array that is indexed like h[i,j,k] to a 1D array that follows this criteria is by doing h_kji_flat = (np.einsum('ijk->kji', h)).flatten() Below we show an example of such a .vtk file. 1 # vtk DataFile Version 3.0 2 GW Strain h 3 ASCII 4 DATASET STRUCTURED POINTS 5 DIMENSIONS 150 150 75 6 ORIGIN \u221275 \u221275 \u221275 7 SPACING 1.00666 1.00666 1.01333 8 POINT DATA 1687500 9 SCALARS GW\u2212FIELD float 10 LOOKUP TABLE default 11 h[0,0,0] 12 h[1,0,0] 13 h[2,0,0] 14 ... 15 h[0,1,0] 16 h[1,1,0] 17 h[2,1,0] 18 ... 19 h[0,0,1] 20 h[1,0,1] 21 h[2,0,1] 22 ... VTK File Containing 3D Gravitational Wave Data For 2D data, the process is very similar. We can pick an arbitrary two-dimensional slice by choosing two orthogonal unit vectors u, \u02c6 v\u02c6 (usually these are just x, \u02c6 y\u02c6) and define our grid using these coordinates. We choose a square grid u, v \u2208 (\u2212L, L). Since we don\u2019t want to see the edge of our grid in the contour plot, we choose a slightly larger value L = 100. We\u2019ve again found that a grid spacing of 1 is good enough so in the visualizations we show later, we have (nu, nv) = (200, 200). After choosing the grid, the process to get arrays of the strains h+ and h\u00d7 follows the same procedure as the 3D data (just with one fewer index in our arrays). We typically multiply all the values of the strain h by a large constant (we use a constant C = 2000) to make the plot more visible. To store the data, we again use a .vtk file, which uses the same format with one fewer dimension. The differences can be seen in the example below of a .vtk file containing two-dimensional gravitational wave data. 1 # vtk DataFile Version 3.0 2 GW Strain h 3 ASCII 4 DATASET STRUCTURED POINTS 5 DIMENSIONS 200 200 6 ORIGIN \u2212100 \u2212100 7 SPACING 1.005 1.005 8 POINT DATA 40000 9 SCALARS GW\u2212FIELD float 10 LOOKUP TABLE default 11 h[0,0] 12 h[1,0] 13 h[2,0] 14 ... 15 h[0,1] 16 h[1,1] 17 h[2,1] 18 ... VTK File Containing 3D Gravitational Wave Data A .vtk file will need to be generated at even intervals across the entire dataset in order to create a movie. The files should be named like h 00000.vtk, h 00001.vtk, and so on so that they can be loaded in VisIt as the database h *.vtk. Now that we\u2019ve generated 3D and 2D gravitational wave data, it is time to visualize them. Three Dimensional Volume Plot In this section, we will discuss how to visualize gravitational waves using a volume plot of the scalar field h+ or h\u00d7 in three dimensions. The main difference between volume rendering of density and volume rendering of gravitational waves is our choice of opacity and colorbar. The range of data is symmetric about zero. Since we are making a volume plot, we should strategically choose settings to bring out the wavelike nature of the data we are working with. Since the range of the data is symmetric about zero, we want to choose a colorbar that has this symmetry as well. Additionally, we want the colorbar to also tell us something about the magnitude of the wave. The decision that we\u2019ve made is to choose darker colors for higher magnitudes and lighter colors for lower magnitudes. For the actual colors, we went with yellow (cyan) for positive (negative) values with lower magnitudes, and green (blue) for the positive (negative) values with higher magnitudes. The final colorbar can be seen in Fig. 67. Figure 67: 3D volume rendering of gravitational waves. For the opacity, we also want to make it symmetric about zero. Next, we want to make sufficiently small magnitudes transparent. If we didn\u2019t, then the entire visualization will be dominated by values that are zero or near zero. Additionally, we\u2019d like the larger magnitudes to have higher opacity than the lower magnitudes so they stand out in the final visualization. An optional trick that we use to further bring out the wavelike nature of the data is to add small peaks in the lower magnitude parts of the opacity array. Adding these peaks creates more \u201cwavelike\u201d parts of the volume plot that propagate outwards when a movie is created. In Fig. 67, these peaks are reflected by the more pronounced \u201cstripes\u201d of yellow and cyan on the outer edge of the visualization. The opacity array with the above features as displayed in the VisIt GUI is shown below in Fig. 68. Here, we can see how the region around zero (where cyan turns to yellow) has zero opacity. We can also see the peaks in the lower magnitude parts of the colorbar (yellow and cyan) as well as higher opacities for the higher magnitude parts of the colorbar (green and blue). After choosing the volume settings and exporting them to .xml files as described in Sec. 4.4, volume plots of the strain h can be made as we\u2019ve done previously (e.g. Sec. 4.2.1). As mentioned earlier, the 3D data we are working with is only present in the lower half of R^3, where z < 0, so we can see a cross-section on the xy-plane. To visualize this entire cross-section, we usually choose a top-down view (i.e. with a view normal of the form (0, 0, +z)). This top-down view can be seen on the left-hand side of Fig. 69. Another option that brings out the three-dimensional nature of our data is to pick a side view, which can be seen on the right-hand side. After the volume settings and view are decided, all that is left to do in order to create a movie, is to use these settings to produce stills for every time step. When we create the t/M label in these images that show the time step, we remember that the original Psi4 rad.mon.# data file we used was extracted at a radius rareal from the origin. That means that waves take a time t = r areal to propagate from the origin to the extraction radius. Since we want to compare our gravitational wave visualizations directly with the movies of the compact object sources, we must subtract rareal from the times. So we are actually using (t-r areal)/M to label our images. See the link below for an example of a gravitational wave movie that was created using data from a binary black hole simulation. https://www.youtube.com/watch?v=dlQWrd_f-bU Figure 68: Volume opacity array for gravity wave 3D rendering. (a) Top-down view. (b) Side view. Figure 69: Different viewing angles of 3D gravitational wave data Two Dimensional Contour Plot In this section, we will discuss how to visualize gravitational waves using a contour plot. This type of plot visualizes the strain h+ or h\u00d7 on a two-dimensional slice of three-dimensional space. The strain is visualized as a surface h(u, v) where u, v are the two orthogonal coordinates that span the two-dimensional slice. While this contour plot only visualizes a 2D slice of the data, it doesn\u2019t rely on changing the colorbar and opacity to only visualize certain magnitudes. It also is more intuitive since visualizing gravitational waves on a surface can be imagined as \u201cripples on a pond\u201d. To create a contour plot, we will use a Pseudocolor and Mesh plot with the Elevate operator applied. Optionally, we can add a Resample operator and a Cylinder operator. Their purposes are outlined below. Pseudocolor plot with a constant colorbar to visualize the surface. Mesh plot to visualize the grid. Adding the grid highlights how the 2D slice of space we are plotting curves in the presence of gravitational waves. Elevate operator applied to both plots that uses the h(u, v) function. This creates a surface plot of h(u, v). It is important to note that VisIt can only create an elevated pseudocolor plot as a surface like z(x, y), where x, y, z are the coordinates of VisIt\u2019s three-dimensional. In other words, VisIt will rotate the general 2D slice the generated data encodes to its xy-plane. Resample operator to change the resolution of the grid we visualize with the Mesh plot. Cylinder operator to only plot the surface at radii r greater than a specified radius r0, which is far enough from the source such that we are in the radiation zone. An example of a contour plot of gravitational waves on the xy-plane for a binary black hole can be seen in Fig. 70. The constant color for the Pseudoclor plot here is a teal blue. We choose a constant colorbar since the information about the strain h is already encoded in the elevation of the surface. The grey lines on the surface are created by the Mesh plot and showcase the gridlines of constant x or y values. The Elevate operator creates the surface plot of h(x, y), which creates the curved surface. The Cylinder operator cuts out the region at the center of the \u201cspiral\u201d to only visualize the surface in the radiation zone. In Code Lst. 10.3 below, we provide VisIt CLI code that loads the h *.vtk database and adds the plots and operators described above. Figure 70: Contour Plot of Gravitational Waves on the xy-Plane 1 OpenDatabase(\u201d/path/to/data/h \u2217.vtk\u201d, 0) 2 3 AddPlot(\u201dPseudocolor\u201d, \u201dGW\u2212FIELD\u201d) 4 Pseudo = PseudocolorAttributes() 5 Pseudo.colorTableName = \u201dconstant colortable\u201d 6 Pseudo.minFlag = 1; Pseudo.min = \u2212100 7 Pseudo.maxFlag = 1; Pseudo.max = 100 8 Pseudo.smoothingLevel = 1 #(0, NONE); (1, Fast); (2, High) 9 Pseudo.legendFlag = 0 10 SetPlotOptions(Pseudo) 11 plots = [0] 12 13 AddPlot(\u201dMesh\u201d, \u201dmesh\u201d) 14 m = MeshAttributes() 15 m.foregroundFlag = 0; m.legendFlag = 0; m.smoothingLevel = m.Fast 16 SetPlotOptions(m) 17 plots += [1] 18 19 SetActivePlots(tuple(plots)) 20 21 AddOperator(\u201dResample\u201d) 22 rAtts = ResampleAttributes() 23 rAtts.is3D = 0; rAtts.samplesX = 200; rAtts.samplesY = 200 24 SetOperatorOptions(rAtts) 25 26 AddOperator(\u201dElevate\u201d) 27 elevAtts = ElevateAttributes() 28 elevAtts.variable = \u201dGW\u2212FIELD\u201d; elevAtts.useXYLimits = elevAtts.Never 29 SetOperatorOptions(elevAtts) 30 31 AddOperator(\u201dCylinder\u201d) 32 CylinderAtts = CylinderAttributes() 33 CylinderAtts.point1 = (0, 0, 10000); CylinderAtts.point2 = (0, 0, \u221210000) 34 CylinderAtts.radius = wave zone r; CylinderAtts.inverse = 1 35 SetOperatorOptions(CylinderAtts) 36 37 SetActivePlots(0) Code Listing 10.3: run gw.py The specific settings we\u2019ve applied to each plot/operator are justified below PseudocolorAttributes() : The Pseudocolor plot is added with the variable GW-FIELD, which corresponds to the data loaded in the h_*.vtk files. Here, constant_colortable is a place holder for a constant color table, which can be made by creating a fully opaque color table with only one color (see Sec. 4.4). The min and max values are turned on and set to \u00b1100 to ensure that the entire range of data falls within the color table limits so that the plot is all one color. The line smoothingLevel = 1 chooses an interpolation algorithm. We\u2019ve found that it must be set to 1 (which corresponds to VisIt\u2019s \u2018fast\u2019 algorithm) for the Pseudocolor and Mesh plots to align when the Elevate operator is applied. MeshAttributes() : Like the Pseudocolor plot, we set the smoothingLevel field to Fast. Setting foregroundFlag to False will use the default color of black instead of the foreground color for the mesh lines. ResampleAttributes() : We set is3D to false since we are working with 2D data. Then we resample to have 200 grid points in the x and y directions. Increasing this number will increase the smoothness of the plot but decrease the visibility of the individual squares of the Mesh plot. Resample should only be used to downsample from the original resolution of the data. ElevateAttributes() : We set the variable to GW-FIELD, which corresponds to the strain data loaded in the h *.vtk files. We set useXYLimits to never so that the elevation height isn\u2019t scaled automatically. CylinderAttributes() : We set point1, point2 to points on the positive and negative z-axis. These points are the ends of the cylinder. We set radius to a specified wave zone r r0to only show the plot in the radiation zone. We set inverse to true so that everything outside this cylinder is plotted (i.e. the near zone region r < r0 is not plotted). For the view, we use viewNormal = (0, 1.2, 1), focus = (15, 10, ), viewUp = (-0.2, -1.2, 1), and imageZoom = 3.2. It is important to note that since our data is on a two-dimensional square grid, we can\u2019t zoom out too much, or else the edges of the grid will be visible (Fig. 71). For our grid with range x, y \u2208 (\u2212L, L) with L = 100, we found that a zoom of 3.2 works. If we\u2019d like to zoom out to show a larger portion of the waveform, then we\u2019d have to generate the data using a grid with a larger value of L. As we did for the gravitational wave movie using three-dimensional volume rendering, we use a time label of (t-r_areal)/M to synchronize the gravitational wave movie with the movie of the compact object sources. An example of this synchronization can be seen in Fig. 72. Gravitational waves and the source visualization of an accretion disk surrounding a rapidly rotating black hole are shown. At this snapshot, the misalignment between the angular momentum of the black hole and the disk causes the disk to undergo a violent distortion that emits gravitational waves. By synchronizing the time labels of the two movies, this violent behavior will be immediately reflected in the gravitational wave movie. The entire movie can be found at the link below. https://www.youtube.com/watch?v=ouRAUuPwnJ0 Figure 71: Example of edges of grid being visible","title":"Gravitational Waves"},{"location":"Section10/#visualizing-gravitational-waves","text":"In this section we will discuss how to visualize gravitational waves using numerical relativity simulation data. Gravitational wave movies can provide helpful intuition about the systems being simulated. When they are examined in conjunction with movies of the sources that produce them, broad insights related to gravitational wave emission can be deduced. These visualizations will use the following simulation output database: Psi4_rad.mon.# : ASCII files containing the Newman-Penrose scalar decomposed into s = \u22122 spin-weighted spherical harmonics \u03c8 4 lm . There are multiple files with # = 1,2,...,9 that correspond to different extraction radii r areal . These files have columns t \u2225 Re(\u03c8 4 22 ) \u2225 Im(\u03c8 4 22 ) \u2225 Re(\u03c8 4 21 ) \u2225 Im(\u03c8 4 21 ) \u2225 \u00b7 \u00b7 \u00b7 \u2225 Im(\u03c8 4 last mode ) \u2225 r areal \u2225 \u27e8g tt \u27e9 \u2225 \u27e8g tr \u27e9 \u2225 \u27e8g rr \u27e9 The last three columns are averages of metric components. The fourth from the last column is the extraction radius rareal. This value is relatively constant across a single file and is far enough from the origin (where the compact objects are located) so that we are in the radiation zone. Multiple files #=1,2,...,9 that correspond to different rareal are output so that we can confirm that the gravitational wave amplitude falls of like r \u22121 and otherwise does not depend on the extraction radius. The first column is the simulation time t. The rest of the columns are the real and imaginary components of \u03c8 4 decomposed into \u03c8 4 lm , which are the s = \u22122 spin-weighted spherical harmonics -2 Y lm (\u03b8, \u03d5) [1]. $$ \\psi_4(t, \\theta, \\phi) = \\sum_{l=2}^{\\infty} \\sum_{m=-l}^{l} \\psi_4^{lm}(t) \\; {}^{-2}Y_{lm}(\\theta, \\phi) $$ For example: columns 2, 3 are modes (l, m) = (2, 2); columns 4, 5 are modes (l, m) = (2, 1); columns 6, 7 are modes (l, m) = (2, 0) (note that we count down from m = l to m = \u2212l). Continuing this pattern, and noting that there are five l = 2 modes, seven l = 3 modes, etc., we know that Columns 2 through 11 are the l = 2 modes Columns 12 through 25 are the l = 3 modes Columns 26 through 43 are the l = 4 modes and so on. In the Illinois GRMHD code, for binary black hole simulations, we output the first thirty modes. This means that there are 2 \u2217 30 + 5 = 65 columns in the Psi4 rad.mon.# file (real and imaginary column for each mode plus the five additional columns). In this case, the last mode output would be (l, m) = (5, \u22123). This file gives one-dimensional data of the \u03c84 scalar as a function of time t that is extracted at a radius rareal from the origin. In order to turn this into 3D data of the gravitational wave strain h(t, r, \u03b8, \u03d5) that we can visualize and turn into a movie, a considerable amount of post-processing must be done. The \u2018plus\u2019 and \u2018cross\u2019 polarizations of the strain h are related to \u03c8 4 by \u03c8 4 = h\u00a8 + \u2212 ih\u00a8 \u00d7 Thus in order to get the strain, we must perform a double time integration on \u03c8 4 lm (t). Following the method described in [5], we perform this double-time integration by dividing by \u03c9 2 in Fourier space. For frequencies close to zero, the calculation of the singular integral becomes inaccurate, therefore a cutoff frequency \u03c90 is introduced [5]. We set \u03c90 equal or less than the initial orbital angular velocity of the system (for the most dominant (2, 2) mode). Implementation-wise, the Fourier transforms are done with a standard Fast Fourier Transform with padding added to each end of the time-domain signal. After this double-time integration, we will have the values C lm as a function of time: $$ C_{lm}(t) = \\int_{-\\infty}^{t} dt' \\int_{-\\infty}^{t'} dt'' \\, \\psi_4^{lm}(t'') $$ At this step, we have an array of the C lm (t) that is a function of time. We already have the angular dependence from the spherical harmonics -2 Y lm (\u03b8, \u03d5). In order to obtain the radial dependence, we will have to consider how the amplitude of h falls as 1/r, as well as the time retardation t = t(r) due to the time it takes the signal to reach the observer at the radiation zone (at position r areal ). To add the time retardation, we consider howC lm (r) should look like at a fixed time t = t0. We define a retarded time: $$ t_0(r) = \\begin{cases} t_0 - r & \\text{if } t_0 \\ge r \\\\ 0 & \\text{if } t_0 < r \\end{cases} $$ Note that in units of c = 1, the speed of gravitational waves is one. Therefore at a radius r, we want to use the data \u201cfrom the past\u201d at time t0(r) = t0 \u2212 r. If our fixed time, t0, is relatively early in the simulation so that t0 < r, then it would have been impossible for a wave to propagate from the origin to that radius r. In that case we set t0(r) equal to the first simulation time t = 0. Since there might be numerical errors that cause C lm (t = 0) to be nonzero everywhere, we manually set C lm (t = 0) = 0. Then we can add this time retardation, along with the 1/r dependence to get radial dependence at a fixed time t0 using $$ C_{lm}(t_0, r) = \\frac{1}{r} \\, C_{lm}(t_0(r)) $$ Then we can get the 3D data of the gravitational wave strain at a fixed time t0 using $$ \\frac{1}{2} \\left( h_+(t_0, r, \\theta, \\phi) - i h_\\times(t_0, r, \\theta, \\phi) \\right) = \\frac{1}{r} \\sum_{l=2}^{\\infty} \\sum_{m=-l}^{l} C_{lm}(t_0(r)) \\, {}^{-2}Y_{lm}(\\theta, \\phi) $$ The individual polarization h+ (h\u00d7) can be obtained by taking the real (imaginary) part of this expression. Using the method described above, we are able to create a 3D data file that contains the gravitational scalar field h+ or h\u00d7 for every time from our original Psi4 rad.mon.# file. In the following sections, we will discuss some nuances about the implementation as well as the specifics about how to generate data files that can be visualized in VisIt using two different rendering techniques.","title":"Visualizing Gravitational Waves"},{"location":"Section10/#post-processing-implementation","text":"The first thing we must do is choose the grid parameters of the 3D data that we will generate. A choice that we make in the Illinois Relativity Group is to visualize the strain only in the lower half z < 0 space. Since the orbital angular momentum in our binary simulations points in the z\u02c6 direction, plotting the strain in z < 0, gives a cross-section on the xy-plane as viewed from above (i.e. a bird\u2019s eye view from a point on the positive z axis). We choose a grid where the xy slices are squares of length 2L. Since we only want to plot z < 0, we use a grid such that (x, y, z) \u2208 [\u2212L, L] \u00d7 [\u2212L, L] \u00d7 [0, L]. We want to pick L large enough such that we can observe the outward propagation of the waves. For the images above, we used L = 75 (remembering that c = 1). Additionally, we will need to choose the number of grid points in the x, y, z directions, which we will denote by nx, ny, nz. We\u2019ve found that having a grid spacing of 1 in code units is enough to produce good visualizations. For now on, we will adopt the notation i, j, k when refering to the x, y, z indices of our grid. Assuming L = 75 with (nx, ny) = (150, 150) and nz = 75, then (i, j, k) = 0, 0, 0 would correspond to (x, y, z) = (\u221275, \u221275, \u221275) and (i, j, k) = (149, 149, 74) would correspond to (x, y, z) = (75, 75, 0). After we\u2019ve chosen our grid, we create lookup tables that give us the values of -2 Y lm (\u03b8, \u03d5) = -2 Y lm (x, y, z) and r = r(x, y, z) at each grid point since these values will be used at each time step and can be rather expensive to compute (especially the -2 Y lm ). The lookup tables for -2 Y lm will be arrays of shape [n x,n y,n z,n modes] ([n x,n y,n z]) that we can access as Ylm[i,j,k,m] (r[i,j,k]). Here n x, n y, n z are nx, ny, nz and n modes is the number of lm-modes that were in the output Psi4 rad.mon.# files (i.e. n_modes is P N l=1 P l m=\u2212l 1 = N(N + 2) where the sum is cutoff at l = N while theoretically it should extend to \u221e). Then we can start calculating h+ and h\u00d7. The lm (t) that we obtain by double time integrating \u03c8 4 lm (t) is a function of time and the lm-modes. It can be loaded into an array of the shape [n times, n modes] that we can access as Clm[t,m]. Here n times is the number of iteration times (i.e. the number of rows) in our output Psi4 rad.mon.# file. In order to apply Eq. 5 to this array, we need to express Eq. 4 in terms of indices. To do this, we need the time step dt between times. Then we can use rt = ((t - (r / dt)).astype(int)).clip(min=0) to implement Eq. 5. This example is in Python, and r is the lookup table NumPy array for r and t is the index for the time. This way, t and r/dt both have \u201cindex\u201d dimensions. It is then cast as an integer and all negative values are set to zero so that rt is an array of indices (that we can access as rt[i,j,k]). Then NumPy allows us to simply do Clm_ijk = Clm[rt,:] to implement Eq. 5 and create an array Clm ijk of shape [n x,n y,n z,n modes]. This is now the same shape as the lookup table Ylm so now Eq. 6 can be implemented by summing over the lm-modes and dividing by the r lookup table hplus_hcross = 2*(1/r)*np.einsum('ijkm->ijk', Clm_ijk*Ylm) where we have used NumPy\u2019s einsum method to sum over the modes. Then h+ and h\u00d7 can be obtained by taking the real and imaginary parts of the hplus hcross array of complex numbers. Moving forward, we refer to either h+ or h\u00d7 as simply h (or h). At a fixed time t*dt (remember that t is an index), we have obtained an array h=h[i,j,k]. The last remaining step before we discuss visualization is how to store the data contained in this array in a format that is usable by VisIt. We will use .vtk files to store this scalar data. The first thing we have to do is setup the header of the .vtk file. We will use the option DATASET STRUCTURED POINTS since we have a predefined grid with fixed spacing. The DIMENSIONS field is n x, n y, n z (150, 150, 75 with the grid we\u2019ve been using). The ORIGIN field is the minimum value of the x, y, z coordinates which is \u2212L for all three (with our choice of L it is -75 -75 -75). The SPACING field is spacing between grid points in each direction. Since we are going from -75 to 75 with 150 points, the spacing is actually (2L+ 1)/nx (for our choice, the spacing in the x, y directions is 151/150 \u2248 1.00666 and the spacing in the z direction is 76/75 \u2248 1.01333). Having this slight offset between our grid points and the integers helps us avoid a singularity at the origin (since we divide by r). Finally the POINT DATA field is just the product nxnynz (here 150 \u00d7 150 \u00d7 75 = 1687500). After inputting the grid settings in the header, we just have to add the data. According to the .vtk documentation, the STRUCTURED POINTS option means that we must input our data with the x coordinate increasing the fastest, then the y, and then the z. In NumPy, one way to convert an array that is indexed like h[i,j,k] to a 1D array that follows this criteria is by doing h_kji_flat = (np.einsum('ijk->kji', h)).flatten() Below we show an example of such a .vtk file. 1 # vtk DataFile Version 3.0 2 GW Strain h 3 ASCII 4 DATASET STRUCTURED POINTS 5 DIMENSIONS 150 150 75 6 ORIGIN \u221275 \u221275 \u221275 7 SPACING 1.00666 1.00666 1.01333 8 POINT DATA 1687500 9 SCALARS GW\u2212FIELD float 10 LOOKUP TABLE default 11 h[0,0,0] 12 h[1,0,0] 13 h[2,0,0] 14 ... 15 h[0,1,0] 16 h[1,1,0] 17 h[2,1,0] 18 ... 19 h[0,0,1] 20 h[1,0,1] 21 h[2,0,1] 22 ... VTK File Containing 3D Gravitational Wave Data For 2D data, the process is very similar. We can pick an arbitrary two-dimensional slice by choosing two orthogonal unit vectors u, \u02c6 v\u02c6 (usually these are just x, \u02c6 y\u02c6) and define our grid using these coordinates. We choose a square grid u, v \u2208 (\u2212L, L). Since we don\u2019t want to see the edge of our grid in the contour plot, we choose a slightly larger value L = 100. We\u2019ve again found that a grid spacing of 1 is good enough so in the visualizations we show later, we have (nu, nv) = (200, 200). After choosing the grid, the process to get arrays of the strains h+ and h\u00d7 follows the same procedure as the 3D data (just with one fewer index in our arrays). We typically multiply all the values of the strain h by a large constant (we use a constant C = 2000) to make the plot more visible. To store the data, we again use a .vtk file, which uses the same format with one fewer dimension. The differences can be seen in the example below of a .vtk file containing two-dimensional gravitational wave data. 1 # vtk DataFile Version 3.0 2 GW Strain h 3 ASCII 4 DATASET STRUCTURED POINTS 5 DIMENSIONS 200 200 6 ORIGIN \u2212100 \u2212100 7 SPACING 1.005 1.005 8 POINT DATA 40000 9 SCALARS GW\u2212FIELD float 10 LOOKUP TABLE default 11 h[0,0] 12 h[1,0] 13 h[2,0] 14 ... 15 h[0,1] 16 h[1,1] 17 h[2,1] 18 ... VTK File Containing 3D Gravitational Wave Data A .vtk file will need to be generated at even intervals across the entire dataset in order to create a movie. The files should be named like h 00000.vtk, h 00001.vtk, and so on so that they can be loaded in VisIt as the database h *.vtk. Now that we\u2019ve generated 3D and 2D gravitational wave data, it is time to visualize them.","title":"Post-Processing Implementation"},{"location":"Section10/#three-dimensional-volume-plot","text":"In this section, we will discuss how to visualize gravitational waves using a volume plot of the scalar field h+ or h\u00d7 in three dimensions. The main difference between volume rendering of density and volume rendering of gravitational waves is our choice of opacity and colorbar. The range of data is symmetric about zero. Since we are making a volume plot, we should strategically choose settings to bring out the wavelike nature of the data we are working with. Since the range of the data is symmetric about zero, we want to choose a colorbar that has this symmetry as well. Additionally, we want the colorbar to also tell us something about the magnitude of the wave. The decision that we\u2019ve made is to choose darker colors for higher magnitudes and lighter colors for lower magnitudes. For the actual colors, we went with yellow (cyan) for positive (negative) values with lower magnitudes, and green (blue) for the positive (negative) values with higher magnitudes. The final colorbar can be seen in Fig. 67. Figure 67: 3D volume rendering of gravitational waves. For the opacity, we also want to make it symmetric about zero. Next, we want to make sufficiently small magnitudes transparent. If we didn\u2019t, then the entire visualization will be dominated by values that are zero or near zero. Additionally, we\u2019d like the larger magnitudes to have higher opacity than the lower magnitudes so they stand out in the final visualization. An optional trick that we use to further bring out the wavelike nature of the data is to add small peaks in the lower magnitude parts of the opacity array. Adding these peaks creates more \u201cwavelike\u201d parts of the volume plot that propagate outwards when a movie is created. In Fig. 67, these peaks are reflected by the more pronounced \u201cstripes\u201d of yellow and cyan on the outer edge of the visualization. The opacity array with the above features as displayed in the VisIt GUI is shown below in Fig. 68. Here, we can see how the region around zero (where cyan turns to yellow) has zero opacity. We can also see the peaks in the lower magnitude parts of the colorbar (yellow and cyan) as well as higher opacities for the higher magnitude parts of the colorbar (green and blue). After choosing the volume settings and exporting them to .xml files as described in Sec. 4.4, volume plots of the strain h can be made as we\u2019ve done previously (e.g. Sec. 4.2.1). As mentioned earlier, the 3D data we are working with is only present in the lower half of R^3, where z < 0, so we can see a cross-section on the xy-plane. To visualize this entire cross-section, we usually choose a top-down view (i.e. with a view normal of the form (0, 0, +z)). This top-down view can be seen on the left-hand side of Fig. 69. Another option that brings out the three-dimensional nature of our data is to pick a side view, which can be seen on the right-hand side. After the volume settings and view are decided, all that is left to do in order to create a movie, is to use these settings to produce stills for every time step. When we create the t/M label in these images that show the time step, we remember that the original Psi4 rad.mon.# data file we used was extracted at a radius rareal from the origin. That means that waves take a time t = r areal to propagate from the origin to the extraction radius. Since we want to compare our gravitational wave visualizations directly with the movies of the compact object sources, we must subtract rareal from the times. So we are actually using (t-r areal)/M to label our images. See the link below for an example of a gravitational wave movie that was created using data from a binary black hole simulation. https://www.youtube.com/watch?v=dlQWrd_f-bU Figure 68: Volume opacity array for gravity wave 3D rendering. (a) Top-down view. (b) Side view. Figure 69: Different viewing angles of 3D gravitational wave data","title":"Three Dimensional Volume Plot"},{"location":"Section10/#two-dimensional-contour-plot","text":"In this section, we will discuss how to visualize gravitational waves using a contour plot. This type of plot visualizes the strain h+ or h\u00d7 on a two-dimensional slice of three-dimensional space. The strain is visualized as a surface h(u, v) where u, v are the two orthogonal coordinates that span the two-dimensional slice. While this contour plot only visualizes a 2D slice of the data, it doesn\u2019t rely on changing the colorbar and opacity to only visualize certain magnitudes. It also is more intuitive since visualizing gravitational waves on a surface can be imagined as \u201cripples on a pond\u201d. To create a contour plot, we will use a Pseudocolor and Mesh plot with the Elevate operator applied. Optionally, we can add a Resample operator and a Cylinder operator. Their purposes are outlined below. Pseudocolor plot with a constant colorbar to visualize the surface. Mesh plot to visualize the grid. Adding the grid highlights how the 2D slice of space we are plotting curves in the presence of gravitational waves. Elevate operator applied to both plots that uses the h(u, v) function. This creates a surface plot of h(u, v). It is important to note that VisIt can only create an elevated pseudocolor plot as a surface like z(x, y), where x, y, z are the coordinates of VisIt\u2019s three-dimensional. In other words, VisIt will rotate the general 2D slice the generated data encodes to its xy-plane. Resample operator to change the resolution of the grid we visualize with the Mesh plot. Cylinder operator to only plot the surface at radii r greater than a specified radius r0, which is far enough from the source such that we are in the radiation zone. An example of a contour plot of gravitational waves on the xy-plane for a binary black hole can be seen in Fig. 70. The constant color for the Pseudoclor plot here is a teal blue. We choose a constant colorbar since the information about the strain h is already encoded in the elevation of the surface. The grey lines on the surface are created by the Mesh plot and showcase the gridlines of constant x or y values. The Elevate operator creates the surface plot of h(x, y), which creates the curved surface. The Cylinder operator cuts out the region at the center of the \u201cspiral\u201d to only visualize the surface in the radiation zone. In Code Lst. 10.3 below, we provide VisIt CLI code that loads the h *.vtk database and adds the plots and operators described above. Figure 70: Contour Plot of Gravitational Waves on the xy-Plane 1 OpenDatabase(\u201d/path/to/data/h \u2217.vtk\u201d, 0) 2 3 AddPlot(\u201dPseudocolor\u201d, \u201dGW\u2212FIELD\u201d) 4 Pseudo = PseudocolorAttributes() 5 Pseudo.colorTableName = \u201dconstant colortable\u201d 6 Pseudo.minFlag = 1; Pseudo.min = \u2212100 7 Pseudo.maxFlag = 1; Pseudo.max = 100 8 Pseudo.smoothingLevel = 1 #(0, NONE); (1, Fast); (2, High) 9 Pseudo.legendFlag = 0 10 SetPlotOptions(Pseudo) 11 plots = [0] 12 13 AddPlot(\u201dMesh\u201d, \u201dmesh\u201d) 14 m = MeshAttributes() 15 m.foregroundFlag = 0; m.legendFlag = 0; m.smoothingLevel = m.Fast 16 SetPlotOptions(m) 17 plots += [1] 18 19 SetActivePlots(tuple(plots)) 20 21 AddOperator(\u201dResample\u201d) 22 rAtts = ResampleAttributes() 23 rAtts.is3D = 0; rAtts.samplesX = 200; rAtts.samplesY = 200 24 SetOperatorOptions(rAtts) 25 26 AddOperator(\u201dElevate\u201d) 27 elevAtts = ElevateAttributes() 28 elevAtts.variable = \u201dGW\u2212FIELD\u201d; elevAtts.useXYLimits = elevAtts.Never 29 SetOperatorOptions(elevAtts) 30 31 AddOperator(\u201dCylinder\u201d) 32 CylinderAtts = CylinderAttributes() 33 CylinderAtts.point1 = (0, 0, 10000); CylinderAtts.point2 = (0, 0, \u221210000) 34 CylinderAtts.radius = wave zone r; CylinderAtts.inverse = 1 35 SetOperatorOptions(CylinderAtts) 36 37 SetActivePlots(0) Code Listing 10.3: run gw.py The specific settings we\u2019ve applied to each plot/operator are justified below PseudocolorAttributes() : The Pseudocolor plot is added with the variable GW-FIELD, which corresponds to the data loaded in the h_*.vtk files. Here, constant_colortable is a place holder for a constant color table, which can be made by creating a fully opaque color table with only one color (see Sec. 4.4). The min and max values are turned on and set to \u00b1100 to ensure that the entire range of data falls within the color table limits so that the plot is all one color. The line smoothingLevel = 1 chooses an interpolation algorithm. We\u2019ve found that it must be set to 1 (which corresponds to VisIt\u2019s \u2018fast\u2019 algorithm) for the Pseudocolor and Mesh plots to align when the Elevate operator is applied. MeshAttributes() : Like the Pseudocolor plot, we set the smoothingLevel field to Fast. Setting foregroundFlag to False will use the default color of black instead of the foreground color for the mesh lines. ResampleAttributes() : We set is3D to false since we are working with 2D data. Then we resample to have 200 grid points in the x and y directions. Increasing this number will increase the smoothness of the plot but decrease the visibility of the individual squares of the Mesh plot. Resample should only be used to downsample from the original resolution of the data. ElevateAttributes() : We set the variable to GW-FIELD, which corresponds to the strain data loaded in the h *.vtk files. We set useXYLimits to never so that the elevation height isn\u2019t scaled automatically. CylinderAttributes() : We set point1, point2 to points on the positive and negative z-axis. These points are the ends of the cylinder. We set radius to a specified wave zone r r0to only show the plot in the radiation zone. We set inverse to true so that everything outside this cylinder is plotted (i.e. the near zone region r < r0 is not plotted). For the view, we use viewNormal = (0, 1.2, 1), focus = (15, 10, ), viewUp = (-0.2, -1.2, 1), and imageZoom = 3.2. It is important to note that since our data is on a two-dimensional square grid, we can\u2019t zoom out too much, or else the edges of the grid will be visible (Fig. 71). For our grid with range x, y \u2208 (\u2212L, L) with L = 100, we found that a zoom of 3.2 works. If we\u2019d like to zoom out to show a larger portion of the waveform, then we\u2019d have to generate the data using a grid with a larger value of L. As we did for the gravitational wave movie using three-dimensional volume rendering, we use a time label of (t-r_areal)/M to synchronize the gravitational wave movie with the movie of the compact object sources. An example of this synchronization can be seen in Fig. 72. Gravitational waves and the source visualization of an accretion disk surrounding a rapidly rotating black hole are shown. At this snapshot, the misalignment between the angular momentum of the black hole and the disk causes the disk to undergo a violent distortion that emits gravitational waves. By synchronizing the time labels of the two movies, this violent behavior will be immediately reflected in the gravitational wave movie. The entire movie can be found at the link below. https://www.youtube.com/watch?v=ouRAUuPwnJ0 Figure 71: Example of edges of grid being visible","title":"Two Dimensional Contour Plot"},{"location":"Section2/","text":"Requirements and Feasibility .link { text-align: center; font-size: 16px; } .textstuff { font-size: 17px; } VisIt is a comprehensive visualization tool designed to handle extremely large datasets in a parallelized and distributed manner that is highly adaptable to any computer system. Its client-server architecture enables remote visualization, while its plugin-based system allows for customization and extension. With support for various operating systems and high-performance computing environments, VisIt is a powerful tool for visualizing complex datasets in diverse scientific and engineering fields. Its robust design, extensive set of features, and ongoing community support make it a feasible solution for large-scale data analysis and visualization, making it essential for the numerical relativity visualization workflow. For the visualizations we will walk through in this primer, a personal computer should be more than enough, however it is important to consider the system requirements to run VisIT across all computing platforms. The following are the key features to note about system requirements: Operating Systems: VisIt is cross-platform, supporting Windows, macOS, and many UNIX variants like UbuntuOS, TOSS OS, Redhat OS, AIX, IRIX, Solaris, and Tru64. Its adaptability also extends to various high-performance computing environments such as SGI's Altix, Cray's XT4, and many commodity clusters. Parallelization: VisIt's core design is based on a client-server architecture, with the server being parallelized. This parallelized server is crucial for processing large datasets interactively and enables remote visualization capabilities. Hardware: Given its focus on large-scale data processing, VisIt can leverage high-performance hardware configurations, such as supercomputers and clusters. For instance, it has been used to visualize datasets comprising billions of points, making it ideal for high-end hardware setups. VisIt\u2019s feasibility largely depends on its ability to handle vast datasets in a parallelized, distributed manner. Key aspects that contribute to its feasibility include: Robust Design: VisIt has been designed with a significant investment in software development, totaling over one and a half million lines of code. The inclusion of third-party libraries like Qt (for its user interface), Python (for scripting), and VTK (for visualization algorithms) contributes to its robustness. Client-Server Model: The client-server architecture allows users to perform remote visualization, reducing the need to transfer large datasets across networks. This model enhances feasibility by enabling efficient utilization of computing resources. Plugin Architecture: VisIt\u2019s plugin-based system allows for easy extension and customization, facilitating the addition of new plots, operators, and file format readers. This flexibility makes it adaptable to various user needs and data types. Compatibility and Adaptability: VisIt has been used for a wide range of applications, from visualizing structured and unstructured grids to adaptive refinement meshes and particle simulations. Its flexibility and extensive library of plots, operators, and queries make it suitable for our visualization needs. Community and Development: VisIt's development is supported by a robust community, with contributions from multiple organizations and universities. The ongoing development by 25 developers from DOE Laboratories and other institutions ensures continuous improvements and updates. Figure 1: VisIt website binary releases VisIt releases different versions of the software that can be installed on a local machine using binaries. These binaries are packaged code that includes an executable installer. The user can follow the installer\u2019s prompts to set up VisIt on their machine. Across this manual, we will be using VisIt 3.1.1, however, any version of VisIt 3 should work. The binary installers corresponding to different releases of VisIt for different operating systems can be found on the releases page: https://visit-dav.github.io/visit-website/releases-as-tables/ For instructions on how to install VisIt, navigate to section corresponding to the appropriate operating system: Windows (), Mac (), or Linux () Installation on Windows Scrolling down on the VisIt releases page, we can find the VisIt Series 3.1 binaries releases table (Fig. 2). The binary release that we are interested in using would be the VisIt 3.1.1 \u201cWin 10/8/7 development\u201d dev release, as it provides greater flexibility and maneuverability within the code for the users. At this point, it is a matter of downloading this file onto the local windows machine and launching the binary executable. Given all of these steps were run correctly, we should be met with an installation prompt, which should install VisIt 3.1.1 onto the windows system as seen within Fig. Figure 2: VisIt 3.1 Series Binaries Figure 3: Windows Installation Prompt Installation on Mac On the releases page, scroll down to find VisIt version 3.1.1, which is the version we will be using throughout this manual. Find the row corresponding to Mac OS and the column corresponding to VisIt 3.1.1 and click the Mac 10.14 dmg download, as shown in Fig After downloading the dmg, double click the download. A window should open with the VisIt application and the applications folder. Drag the VisIt icon to the applications folder, after which a progress bar will appear. When this progress bar is complete, you have successfully installed VisIt on Mac OS. Figure 4: VisIt 3.1.1 Mac OS download Installation on Linux The VisIt installation process on Linux is somewhat more involved than the previous Windows and MacOS installations, but it is not overly complicated. On the releases page, the VisIt installation executables are found in the VisIt Series 3.1 Installation section. For the Linux installation process, we will be downloading the VisIt-install script and the VisIt .tgz file, which contains the instructions and the packaged code to install VisIt onto our system. Although the process described within this tutorial can be extrapolated to any of the listed Linux distributions and VisIt versions, only certain Linux distributions are supported with a given VisIt version. The VisIt functionality differs only slightly between releases since VisIt usually implements a few different features or changes across each release. In this section, we will be installing VisIt 3.1.4 onto an Ubuntu 20.04 system. The User variable represents the user account of the Linux system that the VisIt software have been downloaded in. After downloading the VisIt-install script and the corresponding .tgz file shown in Fig. 5, we first move these files into the same directory. To ensure that the scripts are correctly initialized as an executable, we run the following command. chmod +x VisIt-install Before we run the script, we need to rename the .tgz file since the script expects a certain file name. This is done with the following command mv VisIt3_1_4.linux-x86_64-ubuntu20.tar.gz VisIt3_1_4.linux-x86_64.tar.gz Finally, we can run the installtion script. ./VisIt-install [version] [platform] [directory] The ./VisIt-install part of the command executes the VisIt-install bash script. The following parts of the command in square brackets are arguments. The version argument determines what version of VisIt will be installed on the local machine which in our case is 3.1.4. The platform argument is dependent on the type of system we are installing VisIt onto. The three potential values for this argument are linux-86_64, linux, and darwin. The correct argument can be found in the name of the .tgz file. In this case, the platform is linux-x86_64. If one platform argument does not work, try the other two. There is no consequence for choosing the wrong platform type since the installation script will not work for the wrong argument. Lastly, the directory argument is the location in which we wish to install VisIt. This can be anywhere on the machine, however the /user/src is typically the location of locally installed software on Linux systems, which is where we will be installing VisIt. Figure 5: VisIt 3.1.4 Linux Installation Putting all of this together, the command we run is: ./VisIt-install 3.1.4 linux-x86_64 /usr/local/VisIt Next, we will be prompted to choose a network configuration, which is a setting that allows VisIt to connect different computers together through a common client-server. For our purposes, this is not important so we choose the No Network configuration setting and proceed with the installation. After some time, Visit will have been successfully installed. In order to open VisIt, we run the newly installed executable. /usr/local/VisIt/bin/VisIt For ease of use, it is recommended that Linux users add VisIt to their $PATH environment, which can allow the user to run the VisIt executable without entering the directory it is located in. This can be done by simply adding export PATH=$PATH:/usr/local/VisIt/bin to the end of the \u223c/.bashrc file. To open VisIt, we now only need to enter in visit within the terminal.","title":"Requirements And Feasibility"},{"location":"Section2/#requirements-and-feasibility","text":".link { text-align: center; font-size: 16px; } .textstuff { font-size: 17px; } VisIt is a comprehensive visualization tool designed to handle extremely large datasets in a parallelized and distributed manner that is highly adaptable to any computer system. Its client-server architecture enables remote visualization, while its plugin-based system allows for customization and extension. With support for various operating systems and high-performance computing environments, VisIt is a powerful tool for visualizing complex datasets in diverse scientific and engineering fields. Its robust design, extensive set of features, and ongoing community support make it a feasible solution for large-scale data analysis and visualization, making it essential for the numerical relativity visualization workflow. For the visualizations we will walk through in this primer, a personal computer should be more than enough, however it is important to consider the system requirements to run VisIT across all computing platforms. The following are the key features to note about system requirements: Operating Systems: VisIt is cross-platform, supporting Windows, macOS, and many UNIX variants like UbuntuOS, TOSS OS, Redhat OS, AIX, IRIX, Solaris, and Tru64. Its adaptability also extends to various high-performance computing environments such as SGI's Altix, Cray's XT4, and many commodity clusters. Parallelization: VisIt's core design is based on a client-server architecture, with the server being parallelized. This parallelized server is crucial for processing large datasets interactively and enables remote visualization capabilities. Hardware: Given its focus on large-scale data processing, VisIt can leverage high-performance hardware configurations, such as supercomputers and clusters. For instance, it has been used to visualize datasets comprising billions of points, making it ideal for high-end hardware setups. VisIt\u2019s feasibility largely depends on its ability to handle vast datasets in a parallelized, distributed manner. Key aspects that contribute to its feasibility include: Robust Design: VisIt has been designed with a significant investment in software development, totaling over one and a half million lines of code. The inclusion of third-party libraries like Qt (for its user interface), Python (for scripting), and VTK (for visualization algorithms) contributes to its robustness. Client-Server Model: The client-server architecture allows users to perform remote visualization, reducing the need to transfer large datasets across networks. This model enhances feasibility by enabling efficient utilization of computing resources. Plugin Architecture: VisIt\u2019s plugin-based system allows for easy extension and customization, facilitating the addition of new plots, operators, and file format readers. This flexibility makes it adaptable to various user needs and data types. Compatibility and Adaptability: VisIt has been used for a wide range of applications, from visualizing structured and unstructured grids to adaptive refinement meshes and particle simulations. Its flexibility and extensive library of plots, operators, and queries make it suitable for our visualization needs. Community and Development: VisIt's development is supported by a robust community, with contributions from multiple organizations and universities. The ongoing development by 25 developers from DOE Laboratories and other institutions ensures continuous improvements and updates. Figure 1: VisIt website binary releases VisIt releases different versions of the software that can be installed on a local machine using binaries. These binaries are packaged code that includes an executable installer. The user can follow the installer\u2019s prompts to set up VisIt on their machine. Across this manual, we will be using VisIt 3.1.1, however, any version of VisIt 3 should work. The binary installers corresponding to different releases of VisIt for different operating systems can be found on the releases page: https://visit-dav.github.io/visit-website/releases-as-tables/ For instructions on how to install VisIt, navigate to section corresponding to the appropriate operating system: Windows (), Mac (), or Linux ()","title":"Requirements and Feasibility"},{"location":"Section2/#installation-on-windows","text":"Scrolling down on the VisIt releases page, we can find the VisIt Series 3.1 binaries releases table (Fig. 2). The binary release that we are interested in using would be the VisIt 3.1.1 \u201cWin 10/8/7 development\u201d dev release, as it provides greater flexibility and maneuverability within the code for the users. At this point, it is a matter of downloading this file onto the local windows machine and launching the binary executable. Given all of these steps were run correctly, we should be met with an installation prompt, which should install VisIt 3.1.1 onto the windows system as seen within Fig. Figure 2: VisIt 3.1 Series Binaries Figure 3: Windows Installation Prompt","title":"Installation on Windows"},{"location":"Section2/#installation-on-mac","text":"On the releases page, scroll down to find VisIt version 3.1.1, which is the version we will be using throughout this manual. Find the row corresponding to Mac OS and the column corresponding to VisIt 3.1.1 and click the Mac 10.14 dmg download, as shown in Fig After downloading the dmg, double click the download. A window should open with the VisIt application and the applications folder. Drag the VisIt icon to the applications folder, after which a progress bar will appear. When this progress bar is complete, you have successfully installed VisIt on Mac OS. Figure 4: VisIt 3.1.1 Mac OS download","title":"Installation on Mac"},{"location":"Section2/#installation-on-linux","text":"The VisIt installation process on Linux is somewhat more involved than the previous Windows and MacOS installations, but it is not overly complicated. On the releases page, the VisIt installation executables are found in the VisIt Series 3.1 Installation section. For the Linux installation process, we will be downloading the VisIt-install script and the VisIt .tgz file, which contains the instructions and the packaged code to install VisIt onto our system. Although the process described within this tutorial can be extrapolated to any of the listed Linux distributions and VisIt versions, only certain Linux distributions are supported with a given VisIt version. The VisIt functionality differs only slightly between releases since VisIt usually implements a few different features or changes across each release. In this section, we will be installing VisIt 3.1.4 onto an Ubuntu 20.04 system. The User variable represents the user account of the Linux system that the VisIt software have been downloaded in. After downloading the VisIt-install script and the corresponding .tgz file shown in Fig. 5, we first move these files into the same directory. To ensure that the scripts are correctly initialized as an executable, we run the following command. chmod +x VisIt-install Before we run the script, we need to rename the .tgz file since the script expects a certain file name. This is done with the following command mv VisIt3_1_4.linux-x86_64-ubuntu20.tar.gz VisIt3_1_4.linux-x86_64.tar.gz Finally, we can run the installtion script. ./VisIt-install [version] [platform] [directory] The ./VisIt-install part of the command executes the VisIt-install bash script. The following parts of the command in square brackets are arguments. The version argument determines what version of VisIt will be installed on the local machine which in our case is 3.1.4. The platform argument is dependent on the type of system we are installing VisIt onto. The three potential values for this argument are linux-86_64, linux, and darwin. The correct argument can be found in the name of the .tgz file. In this case, the platform is linux-x86_64. If one platform argument does not work, try the other two. There is no consequence for choosing the wrong platform type since the installation script will not work for the wrong argument. Lastly, the directory argument is the location in which we wish to install VisIt. This can be anywhere on the machine, however the /user/src is typically the location of locally installed software on Linux systems, which is where we will be installing VisIt. Figure 5: VisIt 3.1.4 Linux Installation Putting all of this together, the command we run is: ./VisIt-install 3.1.4 linux-x86_64 /usr/local/VisIt Next, we will be prompted to choose a network configuration, which is a setting that allows VisIt to connect different computers together through a common client-server. For our purposes, this is not important so we choose the No Network configuration setting and proceed with the installation. After some time, Visit will have been successfully installed. In order to open VisIt, we run the newly installed executable. /usr/local/VisIt/bin/VisIt For ease of use, it is recommended that Linux users add VisIt to their $PATH environment, which can allow the user to run the VisIt executable without entering the directory it is located in. This can be done by simply adding export PATH=$PATH:/usr/local/VisIt/bin to the end of the \u223c/.bashrc file. To open VisIt, we now only need to enter in visit within the terminal.","title":"Installation on Linux"},{"location":"Section3/","text":"Interacting with VisIT .link { text-align: center; font-size: 16px; } .textstuff { font-size: 17px; } In this section, we will walk through the steps taken to create a simple visualization using a small sample data file. This visualization just serves as an introduction to VisIt. The details and justifications for the steps taken will be the content of future sections. The two primary ways of interacting with VisIt are through the graphical user interface (GUI) and the command line interface (CLI). The GUI is the interface that opens on the desktop when VisIt is launched on a local machine. Naturally, the GUI is more intuitive, but when we want to make many complex visualizations to create a movie out of a numerical relativity simulation, it isn\u2019t very efficient. This is where the CLI comes in, as it allows us to script many of the commands and operations that VisIt performs on the data, allowing for quick manipulation and automation of visualizations that have many moving parts. A typical workflow in numerical relativity visualization involves experimenting in the GUI on a single frame to fine-tune certain settings before automating the process using scripts that interact with the CLI and visualizing an entire movie. Below, we provide instructions on how to make a simple visualization using the GUI and the CLI. We use a sample VTK file that contains vector field data on a 3 \u00d7 3 \u00d7 3 grid. The values for the vector field $v1 , v2 , v3$ at each of the 27 points are specified after the header. The specifics of the VTK file format and the data aren\u2019t important here and will be discussed in detail in Sec. 4.1.2. The first few lines of test_vector.vtk \u2014 which can be found at VisIt-Guide/sec 3/test vector.vtk \u2014 are shown in Code Lst. 3 below. 1 # vtk DataFile Version 3.0 2 test_vector_field 3 ASCII 4 DATASET STRUCTURED_POINTS 5 DIMENSIONS 3 3 3 6 ORIGIN -3 -3 -3 7 SPACING 3 3 3 8 POINT_DATA 27 9 VECTORS test_vec float 10 1.000000 0.000000 0.000000 11 1.000000 0.000000 0.000000 12 1.000000 0.000000 0.000000 13 1.000000 0.000000 0.000000 14 1.000000 0.000000 0.000000 15 1.000000 0.000000 0.000000 16 1.000000 0.000000 0.000000 17 1.000000 0.000000 0.000000 18 1.000000 0.000000 0.000000 19 1.000000 0.000000 0.000000 20 1.000000 0.000000 0.000000 21 1.000000 0.000000 0.000000 22 1.000000 0.000000 0.000000 23 1.000000 0.000000 0.000000 24 1.000000 0.000000 0.000000 25 1.000000 0.000000 0.000000 26 1.000000 0.000000 0.000000 27 1.000000 0.000000 0.000000 28 1.000000 0.000000 0.000000 29 1.000000 0.000000 0.000000 30 1.000000 0.000000 0.000000 31 1.000000 0.000000 0.000000 32 1.000000 0.000000 0.000000 33 1.000000 0.000000 0.000000 34 1.000000 0.000000 0.000000 35 1.000000 0.000000 0.000000 36 1.000000 0.000000 0.000000 Code Listing 3: test_vector.vtk Interacting with VisIT GUI On a local machine, the user can launch the VisIt GUI either by running the executable file (for Windows and Mac) or by running the VisIt executable from the terminal (for Linux). On a supercomputer, please refer to the machine\u2019s documentation, since X11 forwarding or a VNC client of some sort is required. Many supercomputing systems also have an associated OnDemand interface in which users can access the supercomputing resources through website interface. Depending on the support of the OnDemand interface, the supercomputer may allow you to access the supercomputing resources through a desktop interface, allowing the users to access the VisIt GUI Interface. After successfully launching the GUI, we are introduced to the standard VisIt layout (Fig. 6). Figure 6: Standard VisIt Layout We will now walk through the steps we will need to take to make a first visualization in VisIt. First, download the data file test_vector.vtk to the same machine VisIt is being run on. To plot the data in VisIt, we will need to open the file as a database. We can do this by clicking the Open button at the top of the left panel in the VisIt layout (Fig. 7). Figure 7: Open Database in VisIt GUI A file explorer will open up. Navigate to where we downloaded test_vector.vtk , select the file, and click open. Now that the database is opened, we can create a plot. Since the sample database contains vector field data, we will create a vector plot. Click the Add button to bring up a dropdown menu of all the available plots. At the bottom of the list, hover over the Vector plot option and click test_vec , which is the custom name for the vector field contained in the database that we just loaded. Then click the Draw button to create the plot Figure 8: Add vector plot and draw plot in VisIt GUI After clicking Draw , the plot will load before appearing in the right panel of the standard VisIt layout. We can click and drag the plot to change its orientation. The plot should look similar to Fig. 9. As we can see, the vector field contained in the sample data file is a constant vector field that points in the +x\u0302 direction. Figure 9: Sample Vector Plot in VisIt GUI Interacting with VisIT CLI We will now replicate the plot we made in the previous section using the CLI. To launch VisIt in CLI mode, we add the -cli flag when launching VisIt. visit -cli After doing so, the right panel of the standard VisIt layout will open, and the command line interface will open in the terminal (Fig. 10). Figure 10: VisIt CLI Layout >>>OpenDatabase(\"/path/to/test vector.vtk\") >>>AddPlots(\"Vector\", \"test vec\") >>>DrawPlots() After doing so, the same plot that we created in the GUI (Fig. 9) will render. As with the GUI, we can drag the plot to change its orientation. With VisIt CLI, we can also make visualizations and save them to image files without opening a VisIt window. To do this, we will need to launch VisIt with the -cli and the -nowin options. visit -cli -nowin To recreate the plot and save it to an image in -nowin mode, type the following lines into the CLI. 1 >>> OpenDatabase(\"/path/to/test_vector.vtk\") 2 >>> AddPlots(\"Vector\", \"test_vec\") 3 >>> c = View3DAttributes() 4 >>> c.viewNormal = (1.5, 0, 1) 5 >>> c.viewUp = (0, 0, 1) 6 >>> SetView3D(c) 7 >>> s = SaveWindowAttributes() 8 >>> s.format = s.PNG 9 >>> s.outputToCurrentDirectory = 1 10 >>> s.fileName = \"/path/to/output\" 11 >>> SetSaveWindowAttributes(s) 12 >>> DrawPlots() 13 >>> SaveWindow() In the -nowin mode, we specify the View3DAttributes() to change the orientation since we cannot drag the plot around. The viewNormal vector specifies a vector from the origin to the camera, and the viewUp vector specifies the top of the camera (see Fig. 38, Sec. 4.5). We also need to specify the SaveWindowAttributes() since we are saving the plot to an image file (see Sec. 4.5). The /path/to/ points to the folder where you want to save your output images. After saving the plot to an image, we can exit the visit -cli -nowin environment and return to the terminal by pressing Ctrl+C . Instead of typing these commands one by one in the VisIt CLI, we can also use Python scripting which is much more efficient (especially when we are making a large amount of visualizations for a movie). To do this, we create a run.py VisIt script like the one shown in Code Lst. 3.2, which can be found at VisIt-Guide/sec_3/run.py 1 OpenDatabase(\"/path/to/sample_vector_field.vtk\") 2 AddPlot(\"Vector\", \"vec_field\") 3 4 v = VectorAttributes() 5 v.scaleByMagnitude = 0 6 v.autoScale = 0 7 v.scale = 2.0 8 v.minFlag = 1 9 v.maxFlag = 1 10 v.min = 0 11 v.max = 1e-8 12 v.colorTableName = 'hot' 13 v.nVectors = 1000 14 SetPlotOptions(v) 15 16 c = View3DAttributes() 17 c.viewNormal = (1.0, -1.0, 0.35) 18 c.viewUp = (0, 0, 1) 19 SetView3D(c) 20 s = SaveWindowAttributes() 21 s.format = s.PNG 22 s.outputToCurrentDirectory = 1 23 s.fileName = \"/path/to/output\" 24 SetSaveWindowAttributes(s) 25 DrawPlots() 26 SaveWindow() Code Listing 3.2: run.py Then we can run the script directly from the terminal. visit -cli -nowin -s run.py where the -s flag indicates that VisIt will use the run.py script. Documentation for the VisIt CLI can be found on their website and can be very helpful, but it is not comprehensive. Thankfully, the VisIt GUI provides a tool that converts actions taken in the GUI to a CLI script. In the toolbar, navigate to Controls \u2192 Command . . . which will open up a window as seen in Fig. 11. Within this window, we can start by pressing the Record button and performing any GUI commands. After we have completed any GUI commands that we would like to map onto the CLI counterparts, we can click \u25a0 Stop and the corresponding CLI commands will be displayed within the command box within the middle of the window. If we would like to create a CLI command file in which we could automate any repetitive commands, we could use the Make macro functionality in order to create a CLI command file to run. This can be especially useful to the user when trying to automate the visualization process if a particular visualization command might be difficult to code, as this feature will auto fill the corresponding GUI command into the CLI code. Figure 11: VisIT GUI to CLI window","title":"Interacting with VisIT"},{"location":"Section3/#interacting-with-visit","text":".link { text-align: center; font-size: 16px; } .textstuff { font-size: 17px; } In this section, we will walk through the steps taken to create a simple visualization using a small sample data file. This visualization just serves as an introduction to VisIt. The details and justifications for the steps taken will be the content of future sections. The two primary ways of interacting with VisIt are through the graphical user interface (GUI) and the command line interface (CLI). The GUI is the interface that opens on the desktop when VisIt is launched on a local machine. Naturally, the GUI is more intuitive, but when we want to make many complex visualizations to create a movie out of a numerical relativity simulation, it isn\u2019t very efficient. This is where the CLI comes in, as it allows us to script many of the commands and operations that VisIt performs on the data, allowing for quick manipulation and automation of visualizations that have many moving parts. A typical workflow in numerical relativity visualization involves experimenting in the GUI on a single frame to fine-tune certain settings before automating the process using scripts that interact with the CLI and visualizing an entire movie. Below, we provide instructions on how to make a simple visualization using the GUI and the CLI. We use a sample VTK file that contains vector field data on a 3 \u00d7 3 \u00d7 3 grid. The values for the vector field $v1 , v2 , v3$ at each of the 27 points are specified after the header. The specifics of the VTK file format and the data aren\u2019t important here and will be discussed in detail in Sec. 4.1.2. The first few lines of test_vector.vtk \u2014 which can be found at VisIt-Guide/sec 3/test vector.vtk \u2014 are shown in Code Lst. 3 below. 1 # vtk DataFile Version 3.0 2 test_vector_field 3 ASCII 4 DATASET STRUCTURED_POINTS 5 DIMENSIONS 3 3 3 6 ORIGIN -3 -3 -3 7 SPACING 3 3 3 8 POINT_DATA 27 9 VECTORS test_vec float 10 1.000000 0.000000 0.000000 11 1.000000 0.000000 0.000000 12 1.000000 0.000000 0.000000 13 1.000000 0.000000 0.000000 14 1.000000 0.000000 0.000000 15 1.000000 0.000000 0.000000 16 1.000000 0.000000 0.000000 17 1.000000 0.000000 0.000000 18 1.000000 0.000000 0.000000 19 1.000000 0.000000 0.000000 20 1.000000 0.000000 0.000000 21 1.000000 0.000000 0.000000 22 1.000000 0.000000 0.000000 23 1.000000 0.000000 0.000000 24 1.000000 0.000000 0.000000 25 1.000000 0.000000 0.000000 26 1.000000 0.000000 0.000000 27 1.000000 0.000000 0.000000 28 1.000000 0.000000 0.000000 29 1.000000 0.000000 0.000000 30 1.000000 0.000000 0.000000 31 1.000000 0.000000 0.000000 32 1.000000 0.000000 0.000000 33 1.000000 0.000000 0.000000 34 1.000000 0.000000 0.000000 35 1.000000 0.000000 0.000000 36 1.000000 0.000000 0.000000 Code Listing 3: test_vector.vtk","title":"Interacting with VisIT"},{"location":"Section3/#interacting-with-visit-gui","text":"On a local machine, the user can launch the VisIt GUI either by running the executable file (for Windows and Mac) or by running the VisIt executable from the terminal (for Linux). On a supercomputer, please refer to the machine\u2019s documentation, since X11 forwarding or a VNC client of some sort is required. Many supercomputing systems also have an associated OnDemand interface in which users can access the supercomputing resources through website interface. Depending on the support of the OnDemand interface, the supercomputer may allow you to access the supercomputing resources through a desktop interface, allowing the users to access the VisIt GUI Interface. After successfully launching the GUI, we are introduced to the standard VisIt layout (Fig. 6). Figure 6: Standard VisIt Layout We will now walk through the steps we will need to take to make a first visualization in VisIt. First, download the data file test_vector.vtk to the same machine VisIt is being run on. To plot the data in VisIt, we will need to open the file as a database. We can do this by clicking the Open button at the top of the left panel in the VisIt layout (Fig. 7). Figure 7: Open Database in VisIt GUI A file explorer will open up. Navigate to where we downloaded test_vector.vtk , select the file, and click open. Now that the database is opened, we can create a plot. Since the sample database contains vector field data, we will create a vector plot. Click the Add button to bring up a dropdown menu of all the available plots. At the bottom of the list, hover over the Vector plot option and click test_vec , which is the custom name for the vector field contained in the database that we just loaded. Then click the Draw button to create the plot Figure 8: Add vector plot and draw plot in VisIt GUI After clicking Draw , the plot will load before appearing in the right panel of the standard VisIt layout. We can click and drag the plot to change its orientation. The plot should look similar to Fig. 9. As we can see, the vector field contained in the sample data file is a constant vector field that points in the +x\u0302 direction. Figure 9: Sample Vector Plot in VisIt GUI","title":"Interacting with VisIT GUI"},{"location":"Section3/#interacting-with-visit-cli","text":"We will now replicate the plot we made in the previous section using the CLI. To launch VisIt in CLI mode, we add the -cli flag when launching VisIt. visit -cli After doing so, the right panel of the standard VisIt layout will open, and the command line interface will open in the terminal (Fig. 10). Figure 10: VisIt CLI Layout >>>OpenDatabase(\"/path/to/test vector.vtk\") >>>AddPlots(\"Vector\", \"test vec\") >>>DrawPlots() After doing so, the same plot that we created in the GUI (Fig. 9) will render. As with the GUI, we can drag the plot to change its orientation. With VisIt CLI, we can also make visualizations and save them to image files without opening a VisIt window. To do this, we will need to launch VisIt with the -cli and the -nowin options. visit -cli -nowin To recreate the plot and save it to an image in -nowin mode, type the following lines into the CLI. 1 >>> OpenDatabase(\"/path/to/test_vector.vtk\") 2 >>> AddPlots(\"Vector\", \"test_vec\") 3 >>> c = View3DAttributes() 4 >>> c.viewNormal = (1.5, 0, 1) 5 >>> c.viewUp = (0, 0, 1) 6 >>> SetView3D(c) 7 >>> s = SaveWindowAttributes() 8 >>> s.format = s.PNG 9 >>> s.outputToCurrentDirectory = 1 10 >>> s.fileName = \"/path/to/output\" 11 >>> SetSaveWindowAttributes(s) 12 >>> DrawPlots() 13 >>> SaveWindow() In the -nowin mode, we specify the View3DAttributes() to change the orientation since we cannot drag the plot around. The viewNormal vector specifies a vector from the origin to the camera, and the viewUp vector specifies the top of the camera (see Fig. 38, Sec. 4.5). We also need to specify the SaveWindowAttributes() since we are saving the plot to an image file (see Sec. 4.5). The /path/to/ points to the folder where you want to save your output images. After saving the plot to an image, we can exit the visit -cli -nowin environment and return to the terminal by pressing Ctrl+C . Instead of typing these commands one by one in the VisIt CLI, we can also use Python scripting which is much more efficient (especially when we are making a large amount of visualizations for a movie). To do this, we create a run.py VisIt script like the one shown in Code Lst. 3.2, which can be found at VisIt-Guide/sec_3/run.py 1 OpenDatabase(\"/path/to/sample_vector_field.vtk\") 2 AddPlot(\"Vector\", \"vec_field\") 3 4 v = VectorAttributes() 5 v.scaleByMagnitude = 0 6 v.autoScale = 0 7 v.scale = 2.0 8 v.minFlag = 1 9 v.maxFlag = 1 10 v.min = 0 11 v.max = 1e-8 12 v.colorTableName = 'hot' 13 v.nVectors = 1000 14 SetPlotOptions(v) 15 16 c = View3DAttributes() 17 c.viewNormal = (1.0, -1.0, 0.35) 18 c.viewUp = (0, 0, 1) 19 SetView3D(c) 20 s = SaveWindowAttributes() 21 s.format = s.PNG 22 s.outputToCurrentDirectory = 1 23 s.fileName = \"/path/to/output\" 24 SetSaveWindowAttributes(s) 25 DrawPlots() 26 SaveWindow() Code Listing 3.2: run.py Then we can run the script directly from the terminal. visit -cli -nowin -s run.py where the -s flag indicates that VisIt will use the run.py script. Documentation for the VisIt CLI can be found on their website and can be very helpful, but it is not comprehensive. Thankfully, the VisIt GUI provides a tool that converts actions taken in the GUI to a CLI script. In the toolbar, navigate to Controls \u2192 Command . . . which will open up a window as seen in Fig. 11. Within this window, we can start by pressing the Record button and performing any GUI commands. After we have completed any GUI commands that we would like to map onto the CLI counterparts, we can click \u25a0 Stop and the corresponding CLI commands will be displayed within the command box within the middle of the window. If we would like to create a CLI command file in which we could automate any repetitive commands, we could use the Make macro functionality in order to create a CLI command file to run. This can be especially useful to the user when trying to automate the visualization process if a particular visualization command might be difficult to code, as this feature will auto fill the corresponding GUI command into the CLI code. Figure 11: VisIT GUI to CLI window","title":"Interacting with VisIT CLI"},{"location":"Section4/","text":"VisIT Elements .link { text-align: center; font-size: 16px; } .textstuff { font-size: 17px; } The two main VisIt elements are the databases and the plots. The databases are the files that contain the data that we aim to visualize with VisIt. The plots are the visualizations we create with the data. In this section, we introduce and provide examples of different databases and plots, as well as other relevant aspects of VisIt, that we will later use for our numerical relativity visualizations. Databases Databases are files or collections of files that are loaded into VisIt for visualization. In numerical relativity, databases usually contain 3D spatial data at multiple time steps. However, VisIt also supports 1D and 2D databases. VisIt has an extensive list of file formats that it supports. When these file are loaded\u2014provided that they are generated and formatted properly\u2014VisIt automatically detects the type of data that the database contains (e.g. scalar or vector, 2D or 3D). In this section, we will describe a few file types that are commonly used in numerical relativity. HDF5 Data HDF5 (Hierarchical Data Format) data [8] is a file format that allows developers to store and manipulate large amounts of data. In numerical relativity, outputting the variables we are interested in visualizing often requires terabytes of data, which is why we use the HDF5 file format for the simulation output. Additionally, HDF5 has multi-threading support, which allows us to leverage parallel processing to speed up the scientific visualization process. HDF5 organizes data in two ways: groups and datasets. Groups can be thought of as links between data objects, such as a directory file structure that connects folders together. Datasets are packages of raw data that the file contains with additional information describing the data itself. The HDF5 data that the Illinois GRMHD code [4] outputs for visualization, stores datasets. Since outputting HDF5 data is done by the evolution code, we will not discuss how to generate HDF5 files. However, we will go over how to view the contents and structure of HDF5 files. We provide a sample HDF5 file that can be found at VisIt-Guide/sec_4/Bx.file_0.h5. This file is just 1 out of 128 separate files that together contain data for the x component of the magnetic field at a couple of times. While working with HDF5 data, there are two command line tools that are especially useful to know, h5ls and h5dump, which can be used to view the h5 data. The command h5dump displays the content of the HDF5 file. When executed with no options, this command displays (dumps) all of the raw data in the terminal. Several useful options that can allow the user to extract information from an HDF5 file more effectively are listed below. Viewing file contents: With the -n or -contents flag after the h5dump command (Fig. 12), we can list all of the data stored in the h5 file, which can be especially useful when trying to pick up minute pieces of information quickly from the file. Additionally, we are able to view the headers or titles of the data with corresponding information through the -H or -header flag after the h5dump command (Fig. 13), which can be used to extract specific details about the datasets themselves, such as their attributes and data types. Figure 12: h5dump with contents flag (h5dmp -n) Similarly, the h5ls command can be used to display data stored within the groups and datasets recursively. The output of h5ls is often more streamlined than the output of h5dump. When the -v flag is used with the h5ls command, the different properties of the dataset such as the storage capacity, file contents, and attributes are shown, providing a more detailed snapshot of the HDF5 file. Figure 13: h5dump with header flag (h5dump -H) Viewing datasets/groups: If we want to view the datasets or groups in an HDF5 file, we can use the -d \"Dataset Name\" or -g \"Group Name\" flag with the h5dump command. These flags allow us to analyze specific components of the data that we are interested as well as the raw data stored within the dataset. Some additional flags that might prove useful in combination with the h5dump command CLI tool might be the -A 0 flag, which suppresses attributes when displaying data from the h5 file and simplifies the output quite a bit. We could also index specific datasets or groups that have specific additions through the -N PATH flag, which matches any object within the h5 file the another object or attribute at a specific path. Within the h5ls CLI tool, we can index specific datasets by simply adding the path of the dataset within the h5 file. The -d or -data flag can be used in combination with the h5ls command in order to display the corresponding data within the specific dataset of the h5 file. VTK Files Another important data type used in these simulations are Visualization ToolKit (VTK) files. VTK files are ASCII or binary files that can easily be generated using Python scripts or similar methods. The VTK file format is versatile and allows users to convert a database to be plotted in VisIt. VTK files can store scalar, vector, or tensor data on 2D or 3D grids. We break the VTK file format down into six sections. Header: The header is the first line of a VTK file and contains the file version and identifier. The header is written as # vtk DataFile Version x.x where the x.x is the version number. Title: The title is a string limited to 256 characters. The title is not used by VisIt but should be a description of the data contained in the VTK file. Data Type: The data type can either be BINARY or ASCII. Reading and writing binary data is quicker. However, binary data is only portable across different machines if the machines have the same byte ordering. If the byte ordering between machines differed, then binary VTK files need to be preprocessed before they are able to be read by VisIt. Because we don\u2019t work with large datasets when using VTK files, we use ASCII data because of its flexibility and simplicity. Grid Structure: This section begins with a line containing DATASET followed by a keyword that describes the structure of the grid. The options are STRUCTURED_POINTS, STRUCTURED_GRID, UNSTRUCTURED_GRID, POLYDATA, STRUCTURED_POINTS, RECTILINEAR_GRID, or FIELD. Depend- ing on which option is used, there are additional lines that are required to specify the grid (e.g. the dimensions and spacing). Detailed information can be found in the VTK file format documentation: https://examples.vtk.org/site/VTKFileFormats/ Data Set Attributes: This section begins with either POINT_DATA or CELL_DATA followed by an integer specifying the number of points or cells of the data. The next line specifies the type of data using one of the keywords SCALARS, VECTORS, or TENSORS. Following this keyword are the dataName and dataType. The dataName is a short string-identifier and is the variable that shows up in VisIt when a VTK file is loaded as a database. The dataType\u2014which differs from the earlier ASCII vs binary data type\u2014describes the type of numerical data (e.g. int, float, double). Data: Following the first five sections, data is output. The structure of the data will depend on the grid chosen in step 4 as well as the type of data (scalar, vector, tensor). In Code Lst. 4.1.2, we show an example of a truncated VTK data file that contains vector field data. 1 # vtk DataFile Version 2.0 2 spin_vector 3 ASCII 4 DATASET STRUCTURED_POINTS 5 DIMENSIONS 3 3 3 6 ORIGIN -30 -30 -30 7 SPACING 30 30 30 8 POINT_DATA 27 9 VECTORS spinvec float 10 8.185832e-04 5.333040e-04 2.078931e-03 11 8.185832e-04 5.333040e-04 2.078931e-03 12 8.185832e-04 5.333040e-04 2.078931e-03 13 8.185832e-04 5.333040e-04 2.078931e-03 14 ... Code Lst. 4.1.2: Example of a VTK file Here, the header is # vtk DataFile Version 2.0, the title is spin_vector, and the data type is ASCII. The grid structure is DATASET STRUCTURED_POINTS, which is a 1D, 2D, or 3D grid with evenly spaced grid points. To fully specify the grid structure of STRUCTURED_POINTS, we must add the lines DIMENSIONS, ORIGIN, and SPACING. By setting DIMENSIONS to 3 3 3, we choose a 3\u00d73\u00d73 grid (which also implicitly chooses 3D). By setting ORIGIN to -30 -30 -30 and SPACING to 30 30 30, we set the grid to be [\u221230, 30] \u00d7 [\u221230, 30] \u00d7 [\u221230, 30] where the coordinates can take the values x, y, z \u2208 {\u221230, 0, 30}. The ORIGIN specifies the corner of the grid closest to the \u2212x, \u2212y, \u2212z quadrant and the SPACING specifies the distance between grid points. In the data set attributes section, we have the lines POINT_DATA 27 and VECTORS spinvec float. The first line communicates that we are specifying data on the grid points and that we have a total of 33 = 27 grid points. The second line specifies that our data is vector data (i.e. we need to specify a vector at each point on the grid). We set the dataName to spinvec and the dataType to float. After this section is the actual data, which is truncated but should contain 27 lines of 3 floats separated by spaces. With STRUCTURED_POINTS, the data is ordered with x increasing fastest, then y, then z. So the first four lines of data would correspond to the points (\u221230, \u221230, \u221230), (\u221230, \u221230, 0), (\u221230, \u221230, 30), (\u221230, 0, \u221230). Plots and Operators Once databases are loaded into VisIt, plots are created using the data to produce a visualization. Operators can be applied to the plots to modify the resulting information. Plots and operators both have settings that change different aspects of the visualization ranging from aesthetics to compute time and numerical accuracy. It is important to understand how different plots and operators are used and how their settings affect the resulting visualization. Volume Rendering Volume rendering, which is employed by the Volume plot, is a way of visualizing 3D scalar fields such as the fluid density. With volume rendering, different values in the scalar field are mapped to different colors and opacities. This mapping allows certain values to be emphasized. Additionally, because the mapping is continuous, volume rendering can create high-quality plots that can incorporate all the input data in the final rendered image with proper configuration. Since GRMHD simulations involve a fluid density (which is a scalar field) that is used to model neutron stars and accretion disks, volume rendering is an important tool for visualization in numerical relativity. Volume rendering within VisIt can be broken into three distinct methods: Splatting, 3D Texturing, and Ray Casting, however Ray Casting is essentially the only method that is used within scientific visualizations due to its precision. For both Splatting and 3D Texturing, the volume rendering methods are hardware accelerated, which means that they leverage the graphics card to produce the image. Unfortunately, this means that the dataset must fit onto the graphics card, so, as the dataset becomes larger, the data will have to be resampled and fed into the graphics card, resulting in a loss of quality within the images. On the other hand, Ray Casting is a more computationally intensive volume rendering technique and uses the entire dataset; however, the computational load can be parallelized to produce high quality images in a timely manner. Ray casting volume rendering works in three steps. First, the scalar database must be loaded into VisIt. From here, we specify a camera/viewing angle (think a camera positioned at a point in 3D space pointed at the data). From this camera angle, rays are shot out from each pixel of the camera and intersect with the volume data\u2019s cells. After the rays interact with the data, VisIt assigns a color and opacity to each pixel based on the \u201ctransfer function\u201d, which is the configuration settings set by the user that controls exactly how VisIt decides the pixel\u2019s colors and opacity. An example of ray casting volume rendering used to visualize a magnetized accretion disk that surrounds a binary black hole system can be seen in Fig. 14. For the remainder of the guide, we will refer to ray casting volume rendering as simply volume rendering. For our visualizations, we find that the following Volume plot settings are the most important. colorControlPointList : colorbar used for plot The colorbar is created through a series of color points placed at different relative density values. The colorControlPoint field takes in the RGBA color value and the density data distribution percentage. Unlike isosurface rendering, rendering automatically fills in the missing color values. Thus, we don\u2019t need to create an elaborate color table with too many intermediate colors. Figure 14: Ray casting volume rendering of a magnetized accretion disk around a binary black hole system freeformOpacity : Opacity map used for plot Instead of filling up the colorbar with different color palettes, we are able to exercise fine control over what density values are displayed through the 256-bit freeform array.The colorbar is projected over this array with each value corresponding to a unique density distribution percentage. A 0 corresponds to complete transparency whereas 256 corresponds to complete opacity. In terms of array positioning, the first index corresponds to the lowest density value (this is the outermost layer of the disk/neutron star). Similarly, the last index position corresponds to the highest density value. By assigning different opacity values to different array positions we are able to \u201cactivate\u201d different parts of the volume plot (for example we can emphasize the higher densities in an accretion disk by increasing the opacity of the higher density values relative to lower densities). opacityAttenuation : Adjusts overall transparency While the freeform array helps control the finer transparency details, we can also increase or decrease the overall transparency of the volume plot. This is often done at the end after constructing the colorbar and opacity array (for example we decrease the opacityAttenuation when we want to be able to see a black hole that is obstructed by the accretion disk). colorVarMin/Max: : Changes limits on colorbar If we want to only visualize a certain range of the data, we can explicitly specify the minimum and maximum density values after setting useColorVarMin/Max to true. In volume plots of the density, we actually plot the logarithm of a normalized rest-mass density log(\u03c10 /\u03c1max ). Because 0 of this, we always set colorVarMax to 0. For the accretion disk, we set colorVarMin to \u22124. This range of (\u22124, 0) is reflected by the colorbar in Fig. 17. Note that changes in min and max values should be followed up with corresponding changes in the opacityAttenuation array since opacityAttenuation assigns opacity relative to the range specified by colorVarMax/Min. For instance, if the first half of opacityAttenuation is filled with zeros, then the densities with log(\u03c10 /\u03c1max ) \u2208 (\u22124, \u22122) will be transparent. If we increase colorVarMin to \u22122 while 0 keeping opacityAttenuation the same, then the densities with log(\u03c10 /\u03c1max ) \u2208 (\u22122, \u22121) 0 will be transparent. Note that values outside the range (colorVarMin,colorVarMax) are transparent. samplesPerRay: : Adjusts smoothness and resolution of plot As mentioned before, ray casting creates the plot by shooting rays and sampling the points in its path. By increasing the number of samples that are being cast through the data for each ray, we are able to improve the overall quality of the image. Having too few sample points along a ray gives rise to sampling artifacts such as rings or voids and decreases the overall \u201dsmoothness\u201d. However, sampling more points takes longer to render. We observe a 1:1 correlation between changes in image rendering time and the number of samples per ray. To get a better grasp of the volume rendering process, we will be visualizing a 3D model of density VTK file through both the VisIt GUI and then through the VisIt CLI. This file containing this 3D data can be found at VisIt-Guide/sec 4/sample density.vtk In the GUI, begin by opening up the sample density.vtk file as a database. This can be done by clicking Open and navigating to sample density.vtk in the file explorer that opens up. From here, add a volume plot by clicking Add \u2192 Volume \u2192 density (Fig. 15) and click Draw in order to create the plot. Now we need to draw the sample density and choose the camera/viewing angle in a satisfactory way. Next, open up the volume rendering settings in PlotAtts \u2192 Volume . . . , which will open a window as in Fig. 16. In order to activate ray casting, we will need to change the Rendering Method field from Default Rendering to Ray Casting: compositing. Additionally, we will want to increase the Samples per ray from 500 to 10000. Since the Ray Casting rendering method is computationally expensive, make sure to finalize any adjustments to the viewing angle or the model framing before activating the Ray Casting rendering process. The resulting visualization should look similar to Fig. 17. Within the transfer function, there are two distinct characteristics that we can experiment with: color and opacity. Starting off with color, the smoothing attribute controls how VisIt will interpolate between the specified color points to create a colorbar that is used to represent the density values plotted within the model. There are three distinct options on how VisIt chooses to interpolate the color points: Linear, Cubic Spline, and None. With Linear interpolation, VisIt will create a simple gradient between each color point and numerically fill in each value. With Cubic Spline, VisIt will create a piece-wise cubic polynomial in order to calculate the color point values, which can create a different type of gradient across the colorbar. With None, VisIT will not interpolate the values in between the specified color points, which creates a colorbar with discrete sections of color. Figure 15: Creating a volume rendering plot Figure 16: Volume rendering settings The following is the corresponding CLI script in order to recreate the Volume Rendering image in Fig. 17. Figure 17: Volume rendering of the sample density file Figure 18: Colorbar with linear interpolation Figure 19: Colorbar with cubic spline interpolation Figure 20: Colorbar with no interpolation 1 OpenDatabase(\"sample_density.vtk\", 0) 2 AddPlot(\"Volume\", \"density\", 1, 1) 3 # Volume Attributes 4 VolumeAtts = VolumeAttributes() 5 VolumeAtts.rendererType = VolumeAtts.Raycasting 6 VolumeAtts.samplesPerRay = 10000 7 8 #CubicSpline Smoothing 9 VolumeAtts.colorControlPoints.smoothing = 10 VolumeAtts.colorControlPoints.CubicSpline 11 12 SetPlotOptions(VolumeAtts) 13 s = SaveWindowAttributes() 14 s.format = s.PNG 15 s.outputToCurrentDirectory = 1 16 s.fileName=\"/path/to/output\" 17 SetSaveWindowAttributes(s) 18 DrawPlots() 19 SaveWindow() Code Listing 4.2.1: run_vol.py Isosurface Rendering Like volume rendering, isosurface rendering is a way of visualizing 3D (as well as 2D) scalar fields. The main advantage of isosurface rendering is that it is much less (about 10 times less, depending on the number of isosurfaces) computationally expensive than volume rendering. With this increase in computing speed, isosurface rendering loses detail and realism compared to volume rendering. As the name suggests, isosurface rendering plots the data using isosurfaces: surfaces in which every point has the same data value. Isosurface rendering in VisIt uses the Pseudocolor plot with the Isosurface slicing operator applied. The Pseudocolor plot is a general-purpose plot that different operators can be applied to. The pseudocolor settings include the color table, and determine the color of specific isosurfaces. The Isosurface operator extracts the data and linearly interpolates values between the data minimum and maximum, with each interpolated value being referred to as a level. By default, VisIt constructs 10 levels across the data, however the specifications of these levels can be modified by the user by either percentages between the minimum and maximum of the data such as 5 %, 15 %, or 20%, or through explicitly specifying the level values themselves such using a comma-separated list of values (e.g. (\u22122.6, \u22122.43, \u22122.32, . . .)). Figure 21: Isosurface rendering of a massive accretion disk around a black hole In Fig. 21, we use isosurface rendering to plot the fluid density of a massive accretion disk around a black hole (here the Slice operator is used to view the interior of the disk). Since we are working with an Isosurface operator applied to a Pseudocolor plot, we will need to experiment with their respective settings when creating a visualization using isosurface rendering. We find that the following parameters are the most important to consider when developing isosurface visualizations. contourMethod : Specifies the values of the isosurfaces VisIt offers three methods to select the specific isosurfaces that are plotted: Level, Percent, and Value. If we choose Level, then VisIt will drawn N evenly spaced isosurfaces between a specified minimum and maximum value (see min/max below) where N is a positive integer specified by the contourNLevels field. If we have min=1, max=10, and contourNLevels=10, then 10 isosurfaces will be placed at the values 1, 2, 3, . . . , 10. The Percent method works sim- ilarly, but instead of drawing evenly spaced isosurfaces between min and max, it draws surfaces using an array of percentages (i.e. numbers between 0 and 1) specified in the contourPercent field. If we have min=0, max=10, and contourPercent=(0.0, 0.1, 0.2, 0.3, 0.9), then 5 isosurfaces will be placed at the values 0, 1, 2, 3, 9. Lastly, if we choose the Value method, then we can specify the exact values at which isosurfaces using an array of real numbers specified by the contourValue field. This method doesn\u2019t require min and max to be specified. If we have contourValue=(0.0, 1.23, 3.14, 7.0, 7.01, 9.87), then 6 isosurfaces will be placed at the values 0, 1.23, 3.14, 7, 7.01, 9.87. Since Value gives us the most control over the isosurfaces, we commonly use this method. Having a larger number of isosurfaces spread across the desired range increases the detail of the visualization. However, when the number of isosurfaces is increased, the opacity of the isosurfaces should be decreased accordingly so that the interior isosurfaces are still visible. min/max : Adjusts the range of data plotted If we wish to use a specific range of data, then we must set minFlag and maxFlag to 1 (true) in both the pseudocolor and isosurface settings (unless we are using contourMethod=Value in the isosurface settings, in which case it doesn\u2019t matter). Then we can specify the minimum and maximum values for the color table (isosurfaces) by changing the min and max fields in the pseudocolor (isosurface) settings. If we leave min/maxFlag off, then the minimum/maximum values will be the absolute minimum/maximum values of the entire dataset. colorTableName : Sets the color table used by the plot The name of the color table used is set in the pseudocolor settings. The specifics about creating and exporting a color table are discussed in Sec. 4.4. opacityType : Sets the opacity of the isosurfaces In the pseudocolor settings, we set the opacityType field to either Constant or ColorTable. If we set it to Constant, then we can set the opacity of all isosurfaces to an opacity specified by the opacity field (which is a number between 0 and 1). If we set it to ColorTable, then the opacity of each shell will be set according to the color table specified by the colorTableName field. The opacity of the isosurfaces is an important parameter. If the opacity is too high, then the outermost shells will conceal the inner shells and detail will be lost. If the opacity is too low, then the object we are visualizing will be almost transparent. Using the opacity from the color table gives us finer control over the opacities of each shell, which allows us to strike the right balance. To better understand the isosurface rendering, we will be visualizing the same sample file we visualized using volume rendering in the previous section: VisIt-Guide/sec 4/sample density.vtk . We will create a visualization in the GUI and provide a CLI script that replicates the visualization. In the VisIt GUI, begin by opening up the sample density.vtk as a database, which can be done within the toolbar\u2019s File \u2192 Open file, writing the path of the file within the database window, and loading the aforementioned file. From here, we will want to add Pseudocolor\u2192density and the Operators\u2192Slicing\u2192Isosurface as seen in Fig. 22. Then we can click on Draw in order to create a rendering of the data {: style=\"text-align: center;\"} Figure 22: Setup for the isosurface rendering 1 <?xml version=\"1.0\"?> 2 <Object name=\"ColorTable\"> 3 <Field name=\"Version\" type=\"string\">3.0.0</Field> 4 <Object name=\"ColorControlPointList\"> 5 <Object name=\"ColorControlPoint\"> 6 <Field name=\"colors\" type=\"unsignedCharArray\" 7 length=\"4\">13 0 255 8 </Field> 8 <Field name=\"position\" type=\"float\">0.00</Field> 9 </Object> 10 ... Code Listing 1: First few lines of bhbhdisk.ct At this point there are quite a few different settings we can adjust in order to improve on the quality of the model, such as the pseudocolor settings of the model which is largely controlled by the model\u2019s color table. Colortables are critical to the structure of the visualization, as the color table is essential in highlighting different attributes of the plot. In order to better understand the structure of color tables so we can design and implement our own custom color tables within our models, we break down the example color table as seem in Code Listing 1. Within Visit, color tables are broken up into a series of discretely defined list 26 of colors within XML file under a .ct file extension. Within the XML file, the are listed within a ColorControlPointList in which each distinct objects within the list define a color value at a specific position between the colorbar. Looking at 1, we can see that there are two fields of interest within each ColorControlPoint: the position field parameter and the colors field parameter. An example of a fully detailed colorbar can be found at VisIt-Guide/sec_4/bhbhdisk.ct The colors field parameter defines the color and opacity value at that specific point within the colorbar in a Red-Green-Blue-Alpha (RGBA) color value. The RGBA color value defines a specific color through a mixture of Red, Green, and Blue pixel color values, which are all defined as an integer between 0 to 256. The Alpha aspect of the RGBA color value can be thought of as the associated opacity value for that specific color, which is also an integer between 0 to 256. The position field parameter is a float value defined between 0.00 to 1.00 that is associated with the position of the corresponding RGBA color value within the colorbar. For example, if this position field parameter float value is defined to be 0.5, then the RGBA color value defined within the ColorControlPoint would be associated to the middle of the colorbar. Essentially, VisIt will take these set of discrete color points defined across the colorbar and will interpolate the color points in order to generate a fully continuous colorbar used to map the different density values within the visualization. There are three distinct methods of interpolation that VisIt can use to generate the colorbar from this pre-defined color point list: CubicSpline, Linear, and None. With Linear interpolation, VisIt will create a simple gradient between each color point and numerically fill in each value. With Cubic Spline, VisIt will create a piece-wise cubic polynomial in order to calculate the color point values, which can create a different type of gradient across the colorbar. With None, VisIT will not interpolate the values in between the specified color points, which creates a colorbar with discrete sections of color. Now that we have a better understanding of exactly how the color table is set up, we can move onto implementing it and utilizing its properties within our visualization. We can begin by opening up the pseudocolor settings window as seen in 23 by navigating to PlotAtts\u2192Pseudocolor. . . on the GUI toolbar. In the Color section of this window, we can adjust the color table and the opacity used by the plot. If we change the Opacity setting in this section from Full opacity to From color table as well as the Color Table setting to our custom colorbar, we can directly adjust colorbar and the different opacity levels used in the plot through the settings delineated within the color table XML file, which gives us finer control over the visualization. Now all of the color settings are imported from the color table. To create a new color table for experimentation, we can open the color table window by navigating to Controls\u2192Color table... in the GUI toolbar. We describe how to create and export a color table in Sec. 4.4. After the color table is created and exported, we will be 27 able to find the color table in the color table dropdown menu of the pseudocolor plot options window. To experiment with color table settings, we can either modify and re-export the color table in the color table settings window (Controls\u2192Color table...) or directly modify the .ct file found in \u223c/.visit/ (which is where color tables export to). Additionally, the clarity and resolution of the visualization can also be adjusted by experi- menting with the isosurface rendering settings. Found at OpAtts\u2192Slicing\u2192Isosurface. . . , we can experiment with the isosurface operator characteristics. As mentioned previously, we can adjust the number of isosurfaces and the values each isosurface corresponds to. Figure 23: Adjusting pseudocolor plot attributes and isosurface operator attributes After some experimentation we expect the rendering to be similar to the image in Fig. 24. This image can be replicated by using the bhbhdisk.ct colorbar provided within the manual, as well as using 25 levels within the rendering process. Figure 24: Isosurface rendering final image 1 ActivateDatabase(\"sample_density.vtk\") 2 AddPlot(\"Pseudocolor\", \"density\", 1, 1) 3 AddOperator(\"Isosurface\", 1) 4 5 IsosurfaceAtts = IsosurfaceAttributes() 6 IsosurfaceAtts.contourNLevels = 25 7 IsosurfaceAtts.contourMethod = IsosurfaceAtts.Level 8 SetOperatorOptions(IsosurfaceAtts, 0, 1) 9 10 DrawPlots() Code Listing 4.2.2: Isosurface Rendering CLI Commands Vector Fields In this section, we will be making vector plots similar to section 4. The file containing the vector field data we will be plotting is VisIt-Guide/sec 4/sample vector field.vtk, which is included with this manual. This file contains data for the simple vector field F (x, y, z) = x\u02c6x + y \u02c6y + z \u02c6z. We will give instructions on how to create a plot in the VisIt GUI, and then provide a script to make the same plot using the VisIt CLI. In the GUI, first open sample vector field.vtk as a database.Then create a Vector plot, choosing vec field as the variable name. If we try clicking Draw, then the plot will look empty. We will need to adjust some settings before the plot is useful. To do this, open the PlotAtts dropdown menu and select Vector (Fig. 25). On the window that opens up, navigate to the Glyphs tab on the top. The reason why no vectors are showing up is because they are being autoscaled and scaled by magnitude. Since the vector magnitude varies a lot across the grid (very large near the origin and very small away from the origin), these two options aren\u2019t good choices for a plot of this data, so uncheck those two boxes. Now, all the vectors will be the same size. In addition to this, let\u2019s increase the size of the vectors by setting the scale to 2. Now, your window should look like Fig. 26. To retain information about the magnitude of the vectors, we can apply a colorbar to the vectors. To do this, navigate to the Data tab in the vector plot attributes window. Then in the colorbar dropdown menu, choose the hot colorbar. Finally, to increase the number of vectors in our plot, navigate to the Vectors tab and set the vector amount to 1000. These two tabs should look like Fig. 27. Finally, click Draw. Your plot should look like Fig. 28 (after rotating the plot with your cursor). You are encouraged to explore some of the settings to see how they affect the plot. The CLI script that recreates the plot is in Code Lst. 4.2.3 and can also be found at VisIt-Guide/sec 4/run vector.py. . We can run it as follows: visit -cli -nowin -s run_vector.py Figure 25: VisIt GUI vector attributes Figure 26: Vector Glyph attributes Figure 27: Vector data and vectors attributes Figure 27: Vector data and vectors attributes Figure 28: VisIt GUI vector field plot 1 from visit import * 2 3 OpenDatabase(\"/path/to/sample_vector_field.vtk\") 4 AddPlot(\"Vector\", \"vec_field\") 5 6 v = VectorAttributes() 7 v.scaleByMagnitude = 0 8 v.autoScale = 0 9 v.scale = 2.0 10 v.colorTableName = 'hot' 11 v.nVectors = 1000 12 SetPlotOptions(v) 13 14 c = View3DAttributes() 15 c.viewNormal = (1.0, -1.0, 0.35) 16 c.viewUp = (0, 0, 1) 17 SetView3D(c) 18 s = SaveWindowAttributes() 19 s.format = s.PNG 20 s.outputToCurrentDirectory = 1 21 s.fileName = \"/path/to/output\" 22 SetSaveWindowAttributes(s) 23 DrawPlots() 24 SaveWindow() Code Listing 4.2.3: run vector.py Now that we know how to create vector plots, we will go over some important Vector plot settings. scale, scaleByMagnitude, autoScale, headSize : Vector size These settings affect the size of the vectors in the vector plot. The parameter scaleByMagnitude scales the size of the vector drawn by VisIt depending on the magnitude of the vector field at that location. If the range of magnitudes of the vectors that we want to plot isn\u2019t too large, then we use this option to convey the magnitude of the vector field. However, if the range of magnitudes is large, then it is hard to create a balanced plot: either the vectors with the smallest magnitudes won\u2019t be visible or the vectors with the largest magnitude will be too large. In the case that the range of magnitudes is too large, then it is a good idea to encode the magnitude of the vectors in their color rather than in their size. Then scaleByMagnitude is turned off, all of the vectors will be the same size. The autoScale option automatically normalizes the size of the vectors. We usually turn this option off in favor of manually setting a normalization by changing the scale option. It is important to note that the autoScale and scale options scale the size of all the vectors regardless of whether scaleByMagnitude is turned on or off. The headSize changes the size of the head of the vector relative to its length. The thickness of the stem can changed using the stemWidth option colorByMag, colorTableName, vectorColor : Vector color If the option colorByMag is turned off, then all the vectors will be the same color. This color is specified by changing vectorColor to the desired RGBA tuple. For example, for opaque green vectors, we set vectorColor = (0, 255, 0, 255). If the option colorByMag is turned on, then the color of the vectors will be determined by their magnitudes and the color table specified by the colorTableName option. By default, the color table will run over the entire range of magnitudes present in the data. If we want to restrict this range, we can turn on the options minFlag and maxFlag and specify the minimum and maximum magnitudes by changing min and max. glyphLocation, nVectors, useStride : Vector placement The choices for glyphLocation are AdaptsToMeshResolution and UniformInSpace. VisIt uses AdaptsToMeshResolution as a default. In this case, areas with a finer grid (for example when using adaptive mesh refinement) will have a denser distribution of vectors while areas with a coarser grid will have a coarser distribution of vectors. Sometimes, this can lead to awkward-looking plots where VisIt places most of the vectors in the region where the grid is the finest. If we find AdaptsToMeshResolution causes the vectors to be too unevenly distributed across the plot, then we set glyphLocation to UniformInSpace to place vectors uniformly regardless of the grid. If useStride is set to false (which is the default), then VisIt will attempt to place a fixed number of vectors specified by the nVectors field (note that this is the number of vectors VisIt places before any selection operators are applied). In the case that there are too many vectors or that the vectors are placed too close to each other, we can set useStride to true. Doing this allows us to set the spacing between adjacent vectors by changing the stride field. It is also helpful to note that by default, the vectors VisIt draws represent the vector field at the tail of the vector. To change this, we can change vectorOrigin option from Tail to Head or Middle. By default, VisIt will place vectors across the entire grid which doesn\u2019t give us precise control over the visualization. In a later section (Sec. 5.4) we will describe how to use expressions and selection operators to restrict the vector plot to specific locations. Streamline Integration Streamline integration is another way to visualize vector fields in VisIt. In many cases, it can be more intuitive than vector plots. Since VisIt allows us to specify the seed points for streamlines, we can emphasize the parts of the vector field that we want to focus on. Given a stationary smooth vector field F i and an initial condition xi(\u03bb = 0), there exists a unique streamline x(\u03bb) that satisfies dxi d\u03bb = F i. The streamline traces a particle\u2019s movement through the vector field. For example, in an electric field Ei, a streamline seeded by a point x0 traces the movement of a positive charge through Ei that starts at x0. In practice, numerical integrators look at the vector field around some starting point x(t) and predict the position of the particle that moves along this vector field after some small time dt. Then the process is repeated for the new starting point x(t + dt). In this section, we will be visualizing the same vector field we used in section 4.2.3 but this time using streamlines. In the GUI, we open sample vector field.vtk as a database. Streamlines plot is actually the integral curve operator applied to the pseudocolor plot. In the Add plots dropdown, navigate to: Pseudocolor \u2192 operators \u2192 IntegralCurve \u2192 vec field (Fig. 29). Figure 29: Adding a streamline plot Next, we need to pick seed points to use. To do this, we open the OpAtts (operator attributes) dropdown menu at the top of the window and select: Integral Curves \u2192 IntegralCurve. Since our vector field is spherically symmetric, we will choose seed points that lie on the surface of a sphere. In the Source tab of the integral curve operator attributes window that opens up, select Sphere. Set Radius to \u20185\u2019 (note that Origin is already set to \u20180 0 0\u2019 by default). Next, we set Samples in Latitude and Samples in Longitude to \u201810\u2019 and set Samples in R to \u20181\u2019. These settings will pick points uniformly distributed (with respect to the \u03b8 and \u03d5 spherical coordinates) on the surface of a radius 5 sphere. Additionally, in the Integration tab, change Integration Direction to Both so that the seed points integrate parallel and anti-parallel to the vector field. Finally, in the Appearance tab, change Color by to Vector magnitude. Note that the color table that is used is set by the pseudocolor settings (remember that IntegralCurve is an operator applied to a Pseudocolor plot). The different settings we applied are shown in Fig. 30 Click Apply and then click Draw. Our plot should look like Fig. 31 (as we can see, the field lines are radial as in a point charge.). When recreating this image in the CLI, we will use a different method to choose our points. Instead of using VisIt\u2019s built-in seed generator to create a circle of seed points, we can use a Python tuple. For example, if we want to use n seed points {(xi, yi, zi}n i=1, then we can set the pointList attribute equal to (x1, y1, z1, x2, y2, z2, . . . , xn, yn, zn). Figure 30: Integral Curve Attributes Figure 30: Integral Curve Attributes Figure 31: Example Streamline Plot This way, we can write our own scripts to generate seed points. In the following example, we use NumPy. Another option is to read from a previously created text file. The CLI script that recreates the plot is in Code Lst. 4.2.4 and can also be found at VisIt-Guide/sec 4/sample density.vtk . 1 import numpy as np 2 from visit import * 3 4 R = 5.; num_samples = 10 5 thetas = np.linspace(0, np.pi, num_samples) 6 phis = np.linspace(0, 2*np.pi, num_samples) 7 points = [] 8 for phi in phis: 9 for theta in thetas: 10 x = R*np.cos(phi)*np.sin(theta) 11 y = R*np.sin(phi)*np.sin(theta) 12 z = R*np.cos(theta) 13 points.extend([x, y, z]) 14 15 OpenDatabase(\"sample_vector_field.vtk\") 16 AddPlot(\"Pseudocolor\", \"vec_field\") 17 AddOperator(\"IntegralCurve\") 18 19 p = PseudocolorAttributes() 20 p.minFlag = 1; p.min = 0 21 SetPlotOptions(p) 22 l = IntegralCurveAttributes(); l.sourceType = l.PointList 23 l.pointList = tuple(points); l.integrationDirection = l.Both 24 SetOperatorOptions(l) 25 26 c = View3DAttributes() 27 c.viewNormal = (1.0, -0.35, 0.35); c.viewUp = (0, 0, 1) 28 SetView3D(c) 29 s = SaveWindowAttributes(); s.format = s.PNG 30 s.outputToCurrentDirectory = 1; s.fileName = \"streamline_fol/output\" 31 SetSaveWindowAttributes(s) 32 DrawPlots() 33 SaveWindow() Code Listing 4.2.4: run streamline.py Now that we know how to create streamline plots from a set of seed points, we will go over some important integration settings. For our visualizations, we primarily tune the following integration parameters. PseudocolorAttributes() : Streamline color In the CLI, changing the color of the streamlines is done by changing the PseudocolorAttributes() corresponding to the plot (it seems that in the CLI, the streamlines are automatically colored by magnitude which cannot be changed). To have constant color streamlines, a constant color table must be created (see Sec. 4.4 for how to create a custom color table). This can be applied to the streamlines plot by setting colorTableName to the new color table. As usual with settings pertaining to color, we can set the bounds of the color table by turning on minFlag, maxFlag and changing min, max. maxStepLength : Maximum step length taken at each integration step In practice, decreasing the maximum step length increases the smoothness of the streamline. Integrators commonly increase the step length when the magnitude of the vector field is greater, which can lead to jagged streamlines in areas where the field is strong. If you find that your streamlines are jagged, decrease maxStepLength until your streamlines are smooth. However, if your step length is too small, then your streamlines can get caught up in numerical errors. It is important to note that decreasing the step length will decrease the overall length of your streamline, which can be counteracted by increasing maxSteps. maxSteps : Number of integration steps taken For a fixed maxStepLength, increasing the number of integration steps typically increases the length of the streamline. Since integrating more steps increases computational complexity, we recommend starting with a smaller number of steps (\u2248 1000) and increasing the number of steps until you are satisfied with your image. A helpful way to visualize your seed points is by setting the number of steps to 1-10. If you increase maxSteps but you don\u2019t see any change in the length of your streamlines, try using a different integrationType and maxStepLength. integrationDirection : Integrate parallel or anti-parallel with the vector field You can integrate your seed points along the vector field using the Forward option (think the movement of a positive charge in an electric field) and you can integrate your seed points against the vector field using the Backward option (think the movement of a negative charge in an electric field). To integrate in both directions, use the Both option. integrationType : Integration algorithm used Integration methods affect the stability of the streamline. Lower-order integrators such as Euler (first-order) or Leapfrog (second-order) are less accurate at following the exact solution than Runge-Kutta (fourth-order) methods. However, streamline integration in 3D is very finicky, and we sometimes have used Euler/Leapfrog to get better images. DormandPrince : Runge-Kutta-Dormand-Prince This is VisIt\u2019s most advanced integrator, which allows the user to pick tolerances that match the simulation data. It also uses an adaptive step length which you can limit by changing maxStepLength. We recommend defaulting to this integrator and experimenting with the settings before trying other options. RK4 : Runge-Kutta 4 This is a standard RK4 fourth-order integrator that uses a fixed step length that the user can change by changing maxStepLength (this setting limits the maximum step length for adaptive step integrators and sets the step length for fixed step integrators). Euler/Leapfrog : Euler implements the standard first-order Euler method integrator and Leapfrog is a second-order integrator. These are also fixed step length integrators. Since lower-order integrators are more prone to error, we don\u2019t recommend using these unless you\u2019ve exhausted the other options. Expressions There are often mathematical relationships derived from the different variables that exist in our simulation data we will want to visualize. To address this need within scientific visualizations, VisIt allows us to create mathematical expressions from database variables. Figure 32: Expression window within VisIt In the GUI, expressions can be created and edited in the expressions window at Controls\u2192Expressions. On the left-hand side, there is an expression list that contains a list of different expressions that have either been automatically created by VisIt or manually created by the user (Fig. 32). On the right-hand side, we see the definitions for the mathematical expression that we have selected from the expression list, which can be broken down into the Standard editor or the Python expression editor. In order to create a new expression, there is a New button at the bottom left corner of the editor. From here, the expression can be defined using the Python expression editor window or the standard editor window. There are multiple different options based on what type of variable is being edited, found in the Type drop-down menu, which changes the use of the application of the mathematical expression as expected. We commonly use expressions in VisIt to normalize and transform the simulation data when creating the visualization. For instance, in our visualizations of the fluid rest-mass density, we plot the density in the units of initial maximum density as log(\u03c10/\u03c1max 0 (0)) instead of just \u03c10 so that we can have more clarity. As an example, we will create this expression using the sample density.vtk density file we visualized in Sec. 4.2.1 and Sec. 4.2.2. In VisIt, begin by navigating to Controls \u2192 Expressions and create a new expression within the expression window. Within this situ- ation, we would like to transform the density variable, and after a simple examination of the sample density.vtk file, we can find that the max variable is 1200.0. Using this information, we can write the expression as seen within Fig. 33. After doing so, we use this variable by clicking the Apply button Figure 33: Set up for log \u03c1 expression From here, we can create an isosurface rendering of the density, which can be done following the steps listed in Sec. 4.2.2. The final image should look similar to Fig. 34. Another way to use expressions is to create a vector field from three scalar fields. If the data for the x, y, and z components of a vector field are contained in three separate scalar databases, then they must be combined into a vector field expression before we create Vector or IntegralCurve plots with the vector field data. For HDF5 data, the individual scalar databases must be cast onto the same mesh before they are combined into a vector expression. We will use HDF5 databases Bx.file * database, By.file * database, Bz.file * database that contain magnetic field data that is output by the Illinois GRMHD code as an example. After opening up these databases as the same type (in this case it would be CarpetHDF5), we must create new scalar expressions of these databases after they have been cast onto the Carpet AMR-grid. Figure 34: Isosurface rendering of log(\u03c1) - sample density This is done with conn cmfe() method. For the Bx.file * database which has the HDF5 prefix MHD EVOVLE, we would do: conn_cmfe( , ) Using this expression, we create new expressions Bx, By, Bz for the three components of the magnetic field that all share the same grid. To do this on the GUI for Bx, we create a new Scalar mesh variable in the expressions window. We name it Bx and input the entire conn cmfe() command shown above into the definition. We repeat the process for By and Bz. Then to create a vector field, we create a new Vector mesh variable. We name it Bvec and input {Bx, By, Bz} into the definition. The expressions for Bx and Bvec are shown in Fig. Figure 35: Creating a vector expression from scalar HDF5 databases Figure 35: Creating a vector expression from scalar HDF5 databases In the command line, this can be done using Code Lst. 4.3 which can also be found at VisIt-Guide/sec 4/define_vec_field.py . 1 OpenDatabase(\"/path/to/data/Bx.file_* database\", 0, \"CarpetHDF5_2.1\") 2 OpenDatabase(\"/path/to/data/By.file_* database\", 0, \"CarpetHDF5_2.1\") 3 OpenDatabase(\"/path/to/data/Bz.file_* database\", 0, \"CarpetHDF5_2.1\") 4 5 DefineScalarExpression(Bx, \"conn_cmfe(</path/to/data/Bx.file_* \\ 6 database[0]id:MHD_EVOLVE--Bx>, <Carpet AMR-grid>)\") 7 DefineScalarExpression(Bx, \"conn_cmfe(</path/to/data/By.file_* \\ 8 database[0]id:MHD_EVOLVE--By>, <Carpet AMR-grid>)\") 9 DefineScalarExpression(Bx, \"conn_cmfe(</path/to/data/Bz.file_* \\ 10 database[0]id:MHD_EVOLVE--Bz>, <Carpet AMR-grid>)\") 11 12 DefineVectorExpression(\"Bvec\", \"{Bx, By, Bz}\") Code Listing 4.3: define vec field.py Exporting Attributes A typical workflow when using VisIt is to experiment with plot/operator settings using the more intuitive GUI, and then implementing these settings in the CLI so they can be applied to a whole suite of visualizations. Thankfully, if you need to change a lot of settings, you don\u2019t need to write a separate line of code for each setting like in the run vector.py example (Code Lst. 4.2.3). Instead, VisIt allows your to export plot/operator settings in the GUI as .xml files which can then be loaded in the CLI. For example, if you are making a visualization that includes a volume plot, you will probably want to finely tune things like the color table and opacity values until you are satisfied with an image. If you don\u2019t want to use any of the default VisIt color tables, then the first step would be to create your own color table. First we launch the VisIt GUI, then we open up the color table settings by opening the Controls dropdown menu in the toolbar and clicking Color table (Fig. 36). In the window that opens up, we can change the settings to our liking. When creating a new color table, the first step is to choose the number of colors we want. Changing this field will change the number of \u201ccolor tabs\u201d in the window. To change each individual color, we can click the \u201ctab\u201d and change the RGB values respectively. We can also specify an alpha value, which determines the transparency of the color (0 is transparent, 255 is opaque). Changing the opacities is especially useful when using isosurface rendering. This is because there is an option to use the opacity from the color table which gives us finer control over the opacity of the isosurfaces. We can also choose how the colors are smoothed into each other. Figure 36: Creating color tables When we are done, we need to export the color table so it can be used in other parts of VisIt. First, we give the color table a name in the Name field (in the example below, we name our custom black and yellow color table my colortable). Then we click New and then Export to save this color table in \u223c/.visit/ (e.g. our color table saves as \u223c/.visit/my colortable.ct). Now, we are able to access this color table from the CLI. For example in Code Lst. 4.2.3, we can write v.colorTableName = 'my_colortable' instead of v.colorTableName = 'hot' to use our custom color table for the vector plot. To be more precise with our custom color table, we can open up the exported .ct file to change the exact locations and the specific RBGA values of each color. If we want to use custom color tables on another machine, we need to copy all the .ct files from the first machine to the \u223c/.visit/ folder on the second machine. The next step in specifying settings for our volume plot would be to experiment with and export the volume settings as an .xml file. First, we load up whichever database we want to visualize using a volume plot. Then we open up the volume settings in the GUI by navigating to Volume in the PlotAtts dropdown menu in the GUI toolbar. We then configure our volume settings to our liking (we can choose the custom color table that we just made). When we are satisfied with the plot, we can click Save which opens a file explorer. We then enter where we want to save your volume attributes .xml file before saving (Fig. 37) Figure 37: Exporting attributes to .xml files Now that we have a volume attributes .xml file saved, instead of specifying the volume settings one by one in the CLI like shown in Code Lst. 4.4. 1 v = VolumeAttributes() 2 v.attribute1 = x1 3 v.attribute2 = x2 4 ... 5 SetPlotOptions(v) Code Listing 4.4: Changing settings manually in CLI we can simply import our settings from the .xml file like shown in Code Lst. 4.4 1 v = VolumeAttributes() 2 LoadAttribute('/path/to/my_volume.xml', v) 3 SetPlotOptions(v) Code Listing 4.4: Importing settings from a .xml file We usually like to store the more commonly reused settings, or more complicated settings such as color tables or the freeformOpacity volume setting in .ct and .xml files. For some settings that we change very often, it is still useful to directly set them in the CLI. Commonly, we load a saved .xml file, and then override specific settings with our own choices. Figure 38: View 3D diagram Finalizing Images After you\u2019ve decided on the plots, operators, and settings, the last step is to decide how you want to present your 3D visualization. The first step is to set the View3DAttributes, which basically determine where you place and point the camera and how far it zooms in on the plot. You\u2019ve already seen these options in all of the CLI sample scripts we\u2019ve shown previously. The three most important parameters are focus, viewNormal, viewUp, and imageZoom. The focus is where the camera points, which is commonly set to the main object being visualized. The viewNormal specifies the location of the viewer/camera and the viewUp specifies which direction is \u2018up\u2019 in the final image. See Fig. 38 for a better understanding. The imageZoom simply controls how zoomed in the camera is on the focus. In your script, to set the view of your plot, add lines like 1 c = View3DAttributes() 2 c.viewNormal = (1.0, 1.0, 1.0) 3 c.viewUp = (0.0, 0.0, 1.0) 4 c.focus = (0.0, 0.0, 0.0) 5 c.imageZoom = 1 6 SetView3D(c) Setting Options Manually in CLI The next things to change when finalizing an image would be the annotations. The VisIt labels and legends aren\u2019t super customizable, so the numerical relativity visualizations we make don\u2019t make use of them. With the exception of the t/M label, we finalize our images by removing all VisIt legends and labels, and adding our own with image editors like GIMP or Photoshop. However, we will still briefly go over some of the options you have. Figure 39: Text Annotations o open the annotation settings in the GUI, click Annotation in the Control dropdown menu. The setting that you might want to change first is the background color, which can be found in Colors tab of the window that opens up. Change this to something that will make your visualization stand out. To add text to your image, in the Objects tab, click the Text button on the upper left, and configure things like the position, content, and font (Fig. 39). You can turn off things like the legends (e.g. colorbars), axes, and bounding boxes by unchecking the boxes in the General and 3D tabs. Below in Code Lst. 4.5, we provide a code snippet that applies these annotation settings we\u2019ve discussed. 1 a = AnnotationAttributes() 2 a.backgroundMode = a.Solid 3 a.backgroundColor = (155, 155, 155, 255) #gray 4 a.legendInfoFlag = 0 5 a.userInfoFlag = 0 6 a.axes3D.visible = 0 7 a.axes3D.triadFlag = 0 8 a.axes3D.bboxFlag = 0 9 SetAnnotationAttributes(a) 10 11 txt = CreateAnnotationObject(\"Text2D\") 12 txt.position = (0.75, 0.95) #(x,y) where x and y range from 0 to 1 13 txt.useForegroundForTextColor = 0 14 txt.textColor = (255, 255, 255, 255) 15 txt.fontBold = 1 16 txt.fontFamily = txt.Times 17 txt.text = \"t/M = {}\".format(int(t/M)) Code Listing 4.5: Applying annotation settings The final step is to specify the SaveWindowAttributes, which deal with the format of the saved image file. You can choose where the image is saved, and the aspect ratio of the image, among other settings. An example is shown in Code Lst. 4.5. 1 s = SaveWindowAttributes() 2 s.format = s.PNG 3 s.outputToCurrentDirectory = 1 #so we can choose where to output 4 s.fileName = \"/path/to/output\" 5 s.width = 1920 #creates a 1920 X 1080 image 6 s.height = 1080 7 s.resConstraint = s.NoConstraint 8 SetSaveWindowAttributes(s) Code Listing 4.5: Saving a plot to an image file","title":"VisIT Elements"},{"location":"Section4/#visit-elements","text":".link { text-align: center; font-size: 16px; } .textstuff { font-size: 17px; } The two main VisIt elements are the databases and the plots. The databases are the files that contain the data that we aim to visualize with VisIt. The plots are the visualizations we create with the data. In this section, we introduce and provide examples of different databases and plots, as well as other relevant aspects of VisIt, that we will later use for our numerical relativity visualizations.","title":"VisIT Elements"},{"location":"Section4/#databases","text":"Databases are files or collections of files that are loaded into VisIt for visualization. In numerical relativity, databases usually contain 3D spatial data at multiple time steps. However, VisIt also supports 1D and 2D databases. VisIt has an extensive list of file formats that it supports. When these file are loaded\u2014provided that they are generated and formatted properly\u2014VisIt automatically detects the type of data that the database contains (e.g. scalar or vector, 2D or 3D). In this section, we will describe a few file types that are commonly used in numerical relativity.","title":"Databases"},{"location":"Section4/#hdf5-data","text":"HDF5 (Hierarchical Data Format) data [8] is a file format that allows developers to store and manipulate large amounts of data. In numerical relativity, outputting the variables we are interested in visualizing often requires terabytes of data, which is why we use the HDF5 file format for the simulation output. Additionally, HDF5 has multi-threading support, which allows us to leverage parallel processing to speed up the scientific visualization process. HDF5 organizes data in two ways: groups and datasets. Groups can be thought of as links between data objects, such as a directory file structure that connects folders together. Datasets are packages of raw data that the file contains with additional information describing the data itself. The HDF5 data that the Illinois GRMHD code [4] outputs for visualization, stores datasets. Since outputting HDF5 data is done by the evolution code, we will not discuss how to generate HDF5 files. However, we will go over how to view the contents and structure of HDF5 files. We provide a sample HDF5 file that can be found at VisIt-Guide/sec_4/Bx.file_0.h5. This file is just 1 out of 128 separate files that together contain data for the x component of the magnetic field at a couple of times. While working with HDF5 data, there are two command line tools that are especially useful to know, h5ls and h5dump, which can be used to view the h5 data. The command h5dump displays the content of the HDF5 file. When executed with no options, this command displays (dumps) all of the raw data in the terminal. Several useful options that can allow the user to extract information from an HDF5 file more effectively are listed below. Viewing file contents: With the -n or -contents flag after the h5dump command (Fig. 12), we can list all of the data stored in the h5 file, which can be especially useful when trying to pick up minute pieces of information quickly from the file. Additionally, we are able to view the headers or titles of the data with corresponding information through the -H or -header flag after the h5dump command (Fig. 13), which can be used to extract specific details about the datasets themselves, such as their attributes and data types. Figure 12: h5dump with contents flag (h5dmp -n) Similarly, the h5ls command can be used to display data stored within the groups and datasets recursively. The output of h5ls is often more streamlined than the output of h5dump. When the -v flag is used with the h5ls command, the different properties of the dataset such as the storage capacity, file contents, and attributes are shown, providing a more detailed snapshot of the HDF5 file. Figure 13: h5dump with header flag (h5dump -H) Viewing datasets/groups: If we want to view the datasets or groups in an HDF5 file, we can use the -d \"Dataset Name\" or -g \"Group Name\" flag with the h5dump command. These flags allow us to analyze specific components of the data that we are interested as well as the raw data stored within the dataset. Some additional flags that might prove useful in combination with the h5dump command CLI tool might be the -A 0 flag, which suppresses attributes when displaying data from the h5 file and simplifies the output quite a bit. We could also index specific datasets or groups that have specific additions through the -N PATH flag, which matches any object within the h5 file the another object or attribute at a specific path. Within the h5ls CLI tool, we can index specific datasets by simply adding the path of the dataset within the h5 file. The -d or -data flag can be used in combination with the h5ls command in order to display the corresponding data within the specific dataset of the h5 file.","title":"HDF5 Data"},{"location":"Section4/#vtk-files","text":"Another important data type used in these simulations are Visualization ToolKit (VTK) files. VTK files are ASCII or binary files that can easily be generated using Python scripts or similar methods. The VTK file format is versatile and allows users to convert a database to be plotted in VisIt. VTK files can store scalar, vector, or tensor data on 2D or 3D grids. We break the VTK file format down into six sections. Header: The header is the first line of a VTK file and contains the file version and identifier. The header is written as # vtk DataFile Version x.x where the x.x is the version number. Title: The title is a string limited to 256 characters. The title is not used by VisIt but should be a description of the data contained in the VTK file. Data Type: The data type can either be BINARY or ASCII. Reading and writing binary data is quicker. However, binary data is only portable across different machines if the machines have the same byte ordering. If the byte ordering between machines differed, then binary VTK files need to be preprocessed before they are able to be read by VisIt. Because we don\u2019t work with large datasets when using VTK files, we use ASCII data because of its flexibility and simplicity. Grid Structure: This section begins with a line containing DATASET followed by a keyword that describes the structure of the grid. The options are STRUCTURED_POINTS, STRUCTURED_GRID, UNSTRUCTURED_GRID, POLYDATA, STRUCTURED_POINTS, RECTILINEAR_GRID, or FIELD. Depend- ing on which option is used, there are additional lines that are required to specify the grid (e.g. the dimensions and spacing). Detailed information can be found in the VTK file format documentation: https://examples.vtk.org/site/VTKFileFormats/ Data Set Attributes: This section begins with either POINT_DATA or CELL_DATA followed by an integer specifying the number of points or cells of the data. The next line specifies the type of data using one of the keywords SCALARS, VECTORS, or TENSORS. Following this keyword are the dataName and dataType. The dataName is a short string-identifier and is the variable that shows up in VisIt when a VTK file is loaded as a database. The dataType\u2014which differs from the earlier ASCII vs binary data type\u2014describes the type of numerical data (e.g. int, float, double). Data: Following the first five sections, data is output. The structure of the data will depend on the grid chosen in step 4 as well as the type of data (scalar, vector, tensor). In Code Lst. 4.1.2, we show an example of a truncated VTK data file that contains vector field data. 1 # vtk DataFile Version 2.0 2 spin_vector 3 ASCII 4 DATASET STRUCTURED_POINTS 5 DIMENSIONS 3 3 3 6 ORIGIN -30 -30 -30 7 SPACING 30 30 30 8 POINT_DATA 27 9 VECTORS spinvec float 10 8.185832e-04 5.333040e-04 2.078931e-03 11 8.185832e-04 5.333040e-04 2.078931e-03 12 8.185832e-04 5.333040e-04 2.078931e-03 13 8.185832e-04 5.333040e-04 2.078931e-03 14 ... Code Lst. 4.1.2: Example of a VTK file Here, the header is # vtk DataFile Version 2.0, the title is spin_vector, and the data type is ASCII. The grid structure is DATASET STRUCTURED_POINTS, which is a 1D, 2D, or 3D grid with evenly spaced grid points. To fully specify the grid structure of STRUCTURED_POINTS, we must add the lines DIMENSIONS, ORIGIN, and SPACING. By setting DIMENSIONS to 3 3 3, we choose a 3\u00d73\u00d73 grid (which also implicitly chooses 3D). By setting ORIGIN to -30 -30 -30 and SPACING to 30 30 30, we set the grid to be [\u221230, 30] \u00d7 [\u221230, 30] \u00d7 [\u221230, 30] where the coordinates can take the values x, y, z \u2208 {\u221230, 0, 30}. The ORIGIN specifies the corner of the grid closest to the \u2212x, \u2212y, \u2212z quadrant and the SPACING specifies the distance between grid points. In the data set attributes section, we have the lines POINT_DATA 27 and VECTORS spinvec float. The first line communicates that we are specifying data on the grid points and that we have a total of 33 = 27 grid points. The second line specifies that our data is vector data (i.e. we need to specify a vector at each point on the grid). We set the dataName to spinvec and the dataType to float. After this section is the actual data, which is truncated but should contain 27 lines of 3 floats separated by spaces. With STRUCTURED_POINTS, the data is ordered with x increasing fastest, then y, then z. So the first four lines of data would correspond to the points (\u221230, \u221230, \u221230), (\u221230, \u221230, 0), (\u221230, \u221230, 30), (\u221230, 0, \u221230).","title":"VTK Files"},{"location":"Section4/#plots-and-operators","text":"Once databases are loaded into VisIt, plots are created using the data to produce a visualization. Operators can be applied to the plots to modify the resulting information. Plots and operators both have settings that change different aspects of the visualization ranging from aesthetics to compute time and numerical accuracy. It is important to understand how different plots and operators are used and how their settings affect the resulting visualization.","title":"Plots and Operators"},{"location":"Section4/#volume-rendering","text":"Volume rendering, which is employed by the Volume plot, is a way of visualizing 3D scalar fields such as the fluid density. With volume rendering, different values in the scalar field are mapped to different colors and opacities. This mapping allows certain values to be emphasized. Additionally, because the mapping is continuous, volume rendering can create high-quality plots that can incorporate all the input data in the final rendered image with proper configuration. Since GRMHD simulations involve a fluid density (which is a scalar field) that is used to model neutron stars and accretion disks, volume rendering is an important tool for visualization in numerical relativity. Volume rendering within VisIt can be broken into three distinct methods: Splatting, 3D Texturing, and Ray Casting, however Ray Casting is essentially the only method that is used within scientific visualizations due to its precision. For both Splatting and 3D Texturing, the volume rendering methods are hardware accelerated, which means that they leverage the graphics card to produce the image. Unfortunately, this means that the dataset must fit onto the graphics card, so, as the dataset becomes larger, the data will have to be resampled and fed into the graphics card, resulting in a loss of quality within the images. On the other hand, Ray Casting is a more computationally intensive volume rendering technique and uses the entire dataset; however, the computational load can be parallelized to produce high quality images in a timely manner. Ray casting volume rendering works in three steps. First, the scalar database must be loaded into VisIt. From here, we specify a camera/viewing angle (think a camera positioned at a point in 3D space pointed at the data). From this camera angle, rays are shot out from each pixel of the camera and intersect with the volume data\u2019s cells. After the rays interact with the data, VisIt assigns a color and opacity to each pixel based on the \u201ctransfer function\u201d, which is the configuration settings set by the user that controls exactly how VisIt decides the pixel\u2019s colors and opacity. An example of ray casting volume rendering used to visualize a magnetized accretion disk that surrounds a binary black hole system can be seen in Fig. 14. For the remainder of the guide, we will refer to ray casting volume rendering as simply volume rendering. For our visualizations, we find that the following Volume plot settings are the most important. colorControlPointList : colorbar used for plot The colorbar is created through a series of color points placed at different relative density values. The colorControlPoint field takes in the RGBA color value and the density data distribution percentage. Unlike isosurface rendering, rendering automatically fills in the missing color values. Thus, we don\u2019t need to create an elaborate color table with too many intermediate colors. Figure 14: Ray casting volume rendering of a magnetized accretion disk around a binary black hole system freeformOpacity : Opacity map used for plot Instead of filling up the colorbar with different color palettes, we are able to exercise fine control over what density values are displayed through the 256-bit freeform array.The colorbar is projected over this array with each value corresponding to a unique density distribution percentage. A 0 corresponds to complete transparency whereas 256 corresponds to complete opacity. In terms of array positioning, the first index corresponds to the lowest density value (this is the outermost layer of the disk/neutron star). Similarly, the last index position corresponds to the highest density value. By assigning different opacity values to different array positions we are able to \u201cactivate\u201d different parts of the volume plot (for example we can emphasize the higher densities in an accretion disk by increasing the opacity of the higher density values relative to lower densities). opacityAttenuation : Adjusts overall transparency While the freeform array helps control the finer transparency details, we can also increase or decrease the overall transparency of the volume plot. This is often done at the end after constructing the colorbar and opacity array (for example we decrease the opacityAttenuation when we want to be able to see a black hole that is obstructed by the accretion disk). colorVarMin/Max: : Changes limits on colorbar If we want to only visualize a certain range of the data, we can explicitly specify the minimum and maximum density values after setting useColorVarMin/Max to true. In volume plots of the density, we actually plot the logarithm of a normalized rest-mass density log(\u03c10 /\u03c1max ). Because 0 of this, we always set colorVarMax to 0. For the accretion disk, we set colorVarMin to \u22124. This range of (\u22124, 0) is reflected by the colorbar in Fig. 17. Note that changes in min and max values should be followed up with corresponding changes in the opacityAttenuation array since opacityAttenuation assigns opacity relative to the range specified by colorVarMax/Min. For instance, if the first half of opacityAttenuation is filled with zeros, then the densities with log(\u03c10 /\u03c1max ) \u2208 (\u22124, \u22122) will be transparent. If we increase colorVarMin to \u22122 while 0 keeping opacityAttenuation the same, then the densities with log(\u03c10 /\u03c1max ) \u2208 (\u22122, \u22121) 0 will be transparent. Note that values outside the range (colorVarMin,colorVarMax) are transparent. samplesPerRay: : Adjusts smoothness and resolution of plot As mentioned before, ray casting creates the plot by shooting rays and sampling the points in its path. By increasing the number of samples that are being cast through the data for each ray, we are able to improve the overall quality of the image. Having too few sample points along a ray gives rise to sampling artifacts such as rings or voids and decreases the overall \u201dsmoothness\u201d. However, sampling more points takes longer to render. We observe a 1:1 correlation between changes in image rendering time and the number of samples per ray. To get a better grasp of the volume rendering process, we will be visualizing a 3D model of density VTK file through both the VisIt GUI and then through the VisIt CLI. This file containing this 3D data can be found at VisIt-Guide/sec 4/sample density.vtk In the GUI, begin by opening up the sample density.vtk file as a database. This can be done by clicking Open and navigating to sample density.vtk in the file explorer that opens up. From here, add a volume plot by clicking Add \u2192 Volume \u2192 density (Fig. 15) and click Draw in order to create the plot. Now we need to draw the sample density and choose the camera/viewing angle in a satisfactory way. Next, open up the volume rendering settings in PlotAtts \u2192 Volume . . . , which will open a window as in Fig. 16. In order to activate ray casting, we will need to change the Rendering Method field from Default Rendering to Ray Casting: compositing. Additionally, we will want to increase the Samples per ray from 500 to 10000. Since the Ray Casting rendering method is computationally expensive, make sure to finalize any adjustments to the viewing angle or the model framing before activating the Ray Casting rendering process. The resulting visualization should look similar to Fig. 17. Within the transfer function, there are two distinct characteristics that we can experiment with: color and opacity. Starting off with color, the smoothing attribute controls how VisIt will interpolate between the specified color points to create a colorbar that is used to represent the density values plotted within the model. There are three distinct options on how VisIt chooses to interpolate the color points: Linear, Cubic Spline, and None. With Linear interpolation, VisIt will create a simple gradient between each color point and numerically fill in each value. With Cubic Spline, VisIt will create a piece-wise cubic polynomial in order to calculate the color point values, which can create a different type of gradient across the colorbar. With None, VisIT will not interpolate the values in between the specified color points, which creates a colorbar with discrete sections of color. Figure 15: Creating a volume rendering plot Figure 16: Volume rendering settings The following is the corresponding CLI script in order to recreate the Volume Rendering image in Fig. 17. Figure 17: Volume rendering of the sample density file Figure 18: Colorbar with linear interpolation Figure 19: Colorbar with cubic spline interpolation Figure 20: Colorbar with no interpolation 1 OpenDatabase(\"sample_density.vtk\", 0) 2 AddPlot(\"Volume\", \"density\", 1, 1) 3 # Volume Attributes 4 VolumeAtts = VolumeAttributes() 5 VolumeAtts.rendererType = VolumeAtts.Raycasting 6 VolumeAtts.samplesPerRay = 10000 7 8 #CubicSpline Smoothing 9 VolumeAtts.colorControlPoints.smoothing = 10 VolumeAtts.colorControlPoints.CubicSpline 11 12 SetPlotOptions(VolumeAtts) 13 s = SaveWindowAttributes() 14 s.format = s.PNG 15 s.outputToCurrentDirectory = 1 16 s.fileName=\"/path/to/output\" 17 SetSaveWindowAttributes(s) 18 DrawPlots() 19 SaveWindow() Code Listing 4.2.1: run_vol.py","title":"Volume Rendering"},{"location":"Section4/#isosurface-rendering","text":"Like volume rendering, isosurface rendering is a way of visualizing 3D (as well as 2D) scalar fields. The main advantage of isosurface rendering is that it is much less (about 10 times less, depending on the number of isosurfaces) computationally expensive than volume rendering. With this increase in computing speed, isosurface rendering loses detail and realism compared to volume rendering. As the name suggests, isosurface rendering plots the data using isosurfaces: surfaces in which every point has the same data value. Isosurface rendering in VisIt uses the Pseudocolor plot with the Isosurface slicing operator applied. The Pseudocolor plot is a general-purpose plot that different operators can be applied to. The pseudocolor settings include the color table, and determine the color of specific isosurfaces. The Isosurface operator extracts the data and linearly interpolates values between the data minimum and maximum, with each interpolated value being referred to as a level. By default, VisIt constructs 10 levels across the data, however the specifications of these levels can be modified by the user by either percentages between the minimum and maximum of the data such as 5 %, 15 %, or 20%, or through explicitly specifying the level values themselves such using a comma-separated list of values (e.g. (\u22122.6, \u22122.43, \u22122.32, . . .)). Figure 21: Isosurface rendering of a massive accretion disk around a black hole In Fig. 21, we use isosurface rendering to plot the fluid density of a massive accretion disk around a black hole (here the Slice operator is used to view the interior of the disk). Since we are working with an Isosurface operator applied to a Pseudocolor plot, we will need to experiment with their respective settings when creating a visualization using isosurface rendering. We find that the following parameters are the most important to consider when developing isosurface visualizations. contourMethod : Specifies the values of the isosurfaces VisIt offers three methods to select the specific isosurfaces that are plotted: Level, Percent, and Value. If we choose Level, then VisIt will drawn N evenly spaced isosurfaces between a specified minimum and maximum value (see min/max below) where N is a positive integer specified by the contourNLevels field. If we have min=1, max=10, and contourNLevels=10, then 10 isosurfaces will be placed at the values 1, 2, 3, . . . , 10. The Percent method works sim- ilarly, but instead of drawing evenly spaced isosurfaces between min and max, it draws surfaces using an array of percentages (i.e. numbers between 0 and 1) specified in the contourPercent field. If we have min=0, max=10, and contourPercent=(0.0, 0.1, 0.2, 0.3, 0.9), then 5 isosurfaces will be placed at the values 0, 1, 2, 3, 9. Lastly, if we choose the Value method, then we can specify the exact values at which isosurfaces using an array of real numbers specified by the contourValue field. This method doesn\u2019t require min and max to be specified. If we have contourValue=(0.0, 1.23, 3.14, 7.0, 7.01, 9.87), then 6 isosurfaces will be placed at the values 0, 1.23, 3.14, 7, 7.01, 9.87. Since Value gives us the most control over the isosurfaces, we commonly use this method. Having a larger number of isosurfaces spread across the desired range increases the detail of the visualization. However, when the number of isosurfaces is increased, the opacity of the isosurfaces should be decreased accordingly so that the interior isosurfaces are still visible. min/max : Adjusts the range of data plotted If we wish to use a specific range of data, then we must set minFlag and maxFlag to 1 (true) in both the pseudocolor and isosurface settings (unless we are using contourMethod=Value in the isosurface settings, in which case it doesn\u2019t matter). Then we can specify the minimum and maximum values for the color table (isosurfaces) by changing the min and max fields in the pseudocolor (isosurface) settings. If we leave min/maxFlag off, then the minimum/maximum values will be the absolute minimum/maximum values of the entire dataset. colorTableName : Sets the color table used by the plot The name of the color table used is set in the pseudocolor settings. The specifics about creating and exporting a color table are discussed in Sec. 4.4. opacityType : Sets the opacity of the isosurfaces In the pseudocolor settings, we set the opacityType field to either Constant or ColorTable. If we set it to Constant, then we can set the opacity of all isosurfaces to an opacity specified by the opacity field (which is a number between 0 and 1). If we set it to ColorTable, then the opacity of each shell will be set according to the color table specified by the colorTableName field. The opacity of the isosurfaces is an important parameter. If the opacity is too high, then the outermost shells will conceal the inner shells and detail will be lost. If the opacity is too low, then the object we are visualizing will be almost transparent. Using the opacity from the color table gives us finer control over the opacities of each shell, which allows us to strike the right balance. To better understand the isosurface rendering, we will be visualizing the same sample file we visualized using volume rendering in the previous section: VisIt-Guide/sec 4/sample density.vtk . We will create a visualization in the GUI and provide a CLI script that replicates the visualization. In the VisIt GUI, begin by opening up the sample density.vtk as a database, which can be done within the toolbar\u2019s File \u2192 Open file, writing the path of the file within the database window, and loading the aforementioned file. From here, we will want to add Pseudocolor\u2192density and the Operators\u2192Slicing\u2192Isosurface as seen in Fig. 22. Then we can click on Draw in order to create a rendering of the data {: style=\"text-align: center;\"} Figure 22: Setup for the isosurface rendering 1 <?xml version=\"1.0\"?> 2 <Object name=\"ColorTable\"> 3 <Field name=\"Version\" type=\"string\">3.0.0</Field> 4 <Object name=\"ColorControlPointList\"> 5 <Object name=\"ColorControlPoint\"> 6 <Field name=\"colors\" type=\"unsignedCharArray\" 7 length=\"4\">13 0 255 8 </Field> 8 <Field name=\"position\" type=\"float\">0.00</Field> 9 </Object> 10 ... Code Listing 1: First few lines of bhbhdisk.ct At this point there are quite a few different settings we can adjust in order to improve on the quality of the model, such as the pseudocolor settings of the model which is largely controlled by the model\u2019s color table. Colortables are critical to the structure of the visualization, as the color table is essential in highlighting different attributes of the plot. In order to better understand the structure of color tables so we can design and implement our own custom color tables within our models, we break down the example color table as seem in Code Listing 1. Within Visit, color tables are broken up into a series of discretely defined list 26 of colors within XML file under a .ct file extension. Within the XML file, the are listed within a ColorControlPointList in which each distinct objects within the list define a color value at a specific position between the colorbar. Looking at 1, we can see that there are two fields of interest within each ColorControlPoint: the position field parameter and the colors field parameter. An example of a fully detailed colorbar can be found at VisIt-Guide/sec_4/bhbhdisk.ct The colors field parameter defines the color and opacity value at that specific point within the colorbar in a Red-Green-Blue-Alpha (RGBA) color value. The RGBA color value defines a specific color through a mixture of Red, Green, and Blue pixel color values, which are all defined as an integer between 0 to 256. The Alpha aspect of the RGBA color value can be thought of as the associated opacity value for that specific color, which is also an integer between 0 to 256. The position field parameter is a float value defined between 0.00 to 1.00 that is associated with the position of the corresponding RGBA color value within the colorbar. For example, if this position field parameter float value is defined to be 0.5, then the RGBA color value defined within the ColorControlPoint would be associated to the middle of the colorbar. Essentially, VisIt will take these set of discrete color points defined across the colorbar and will interpolate the color points in order to generate a fully continuous colorbar used to map the different density values within the visualization. There are three distinct methods of interpolation that VisIt can use to generate the colorbar from this pre-defined color point list: CubicSpline, Linear, and None. With Linear interpolation, VisIt will create a simple gradient between each color point and numerically fill in each value. With Cubic Spline, VisIt will create a piece-wise cubic polynomial in order to calculate the color point values, which can create a different type of gradient across the colorbar. With None, VisIT will not interpolate the values in between the specified color points, which creates a colorbar with discrete sections of color. Now that we have a better understanding of exactly how the color table is set up, we can move onto implementing it and utilizing its properties within our visualization. We can begin by opening up the pseudocolor settings window as seen in 23 by navigating to PlotAtts\u2192Pseudocolor. . . on the GUI toolbar. In the Color section of this window, we can adjust the color table and the opacity used by the plot. If we change the Opacity setting in this section from Full opacity to From color table as well as the Color Table setting to our custom colorbar, we can directly adjust colorbar and the different opacity levels used in the plot through the settings delineated within the color table XML file, which gives us finer control over the visualization. Now all of the color settings are imported from the color table. To create a new color table for experimentation, we can open the color table window by navigating to Controls\u2192Color table... in the GUI toolbar. We describe how to create and export a color table in Sec. 4.4. After the color table is created and exported, we will be 27 able to find the color table in the color table dropdown menu of the pseudocolor plot options window. To experiment with color table settings, we can either modify and re-export the color table in the color table settings window (Controls\u2192Color table...) or directly modify the .ct file found in \u223c/.visit/ (which is where color tables export to). Additionally, the clarity and resolution of the visualization can also be adjusted by experi- menting with the isosurface rendering settings. Found at OpAtts\u2192Slicing\u2192Isosurface. . . , we can experiment with the isosurface operator characteristics. As mentioned previously, we can adjust the number of isosurfaces and the values each isosurface corresponds to. Figure 23: Adjusting pseudocolor plot attributes and isosurface operator attributes After some experimentation we expect the rendering to be similar to the image in Fig. 24. This image can be replicated by using the bhbhdisk.ct colorbar provided within the manual, as well as using 25 levels within the rendering process. Figure 24: Isosurface rendering final image 1 ActivateDatabase(\"sample_density.vtk\") 2 AddPlot(\"Pseudocolor\", \"density\", 1, 1) 3 AddOperator(\"Isosurface\", 1) 4 5 IsosurfaceAtts = IsosurfaceAttributes() 6 IsosurfaceAtts.contourNLevels = 25 7 IsosurfaceAtts.contourMethod = IsosurfaceAtts.Level 8 SetOperatorOptions(IsosurfaceAtts, 0, 1) 9 10 DrawPlots() Code Listing 4.2.2: Isosurface Rendering CLI Commands","title":"Isosurface Rendering"},{"location":"Section4/#vector-fields","text":"In this section, we will be making vector plots similar to section 4. The file containing the vector field data we will be plotting is VisIt-Guide/sec 4/sample vector field.vtk, which is included with this manual. This file contains data for the simple vector field F (x, y, z) = x\u02c6x + y \u02c6y + z \u02c6z. We will give instructions on how to create a plot in the VisIt GUI, and then provide a script to make the same plot using the VisIt CLI. In the GUI, first open sample vector field.vtk as a database.Then create a Vector plot, choosing vec field as the variable name. If we try clicking Draw, then the plot will look empty. We will need to adjust some settings before the plot is useful. To do this, open the PlotAtts dropdown menu and select Vector (Fig. 25). On the window that opens up, navigate to the Glyphs tab on the top. The reason why no vectors are showing up is because they are being autoscaled and scaled by magnitude. Since the vector magnitude varies a lot across the grid (very large near the origin and very small away from the origin), these two options aren\u2019t good choices for a plot of this data, so uncheck those two boxes. Now, all the vectors will be the same size. In addition to this, let\u2019s increase the size of the vectors by setting the scale to 2. Now, your window should look like Fig. 26. To retain information about the magnitude of the vectors, we can apply a colorbar to the vectors. To do this, navigate to the Data tab in the vector plot attributes window. Then in the colorbar dropdown menu, choose the hot colorbar. Finally, to increase the number of vectors in our plot, navigate to the Vectors tab and set the vector amount to 1000. These two tabs should look like Fig. 27. Finally, click Draw. Your plot should look like Fig. 28 (after rotating the plot with your cursor). You are encouraged to explore some of the settings to see how they affect the plot. The CLI script that recreates the plot is in Code Lst. 4.2.3 and can also be found at VisIt-Guide/sec 4/run vector.py. . We can run it as follows: visit -cli -nowin -s run_vector.py Figure 25: VisIt GUI vector attributes Figure 26: Vector Glyph attributes Figure 27: Vector data and vectors attributes Figure 27: Vector data and vectors attributes Figure 28: VisIt GUI vector field plot 1 from visit import * 2 3 OpenDatabase(\"/path/to/sample_vector_field.vtk\") 4 AddPlot(\"Vector\", \"vec_field\") 5 6 v = VectorAttributes() 7 v.scaleByMagnitude = 0 8 v.autoScale = 0 9 v.scale = 2.0 10 v.colorTableName = 'hot' 11 v.nVectors = 1000 12 SetPlotOptions(v) 13 14 c = View3DAttributes() 15 c.viewNormal = (1.0, -1.0, 0.35) 16 c.viewUp = (0, 0, 1) 17 SetView3D(c) 18 s = SaveWindowAttributes() 19 s.format = s.PNG 20 s.outputToCurrentDirectory = 1 21 s.fileName = \"/path/to/output\" 22 SetSaveWindowAttributes(s) 23 DrawPlots() 24 SaveWindow() Code Listing 4.2.3: run vector.py Now that we know how to create vector plots, we will go over some important Vector plot settings. scale, scaleByMagnitude, autoScale, headSize : Vector size These settings affect the size of the vectors in the vector plot. The parameter scaleByMagnitude scales the size of the vector drawn by VisIt depending on the magnitude of the vector field at that location. If the range of magnitudes of the vectors that we want to plot isn\u2019t too large, then we use this option to convey the magnitude of the vector field. However, if the range of magnitudes is large, then it is hard to create a balanced plot: either the vectors with the smallest magnitudes won\u2019t be visible or the vectors with the largest magnitude will be too large. In the case that the range of magnitudes is too large, then it is a good idea to encode the magnitude of the vectors in their color rather than in their size. Then scaleByMagnitude is turned off, all of the vectors will be the same size. The autoScale option automatically normalizes the size of the vectors. We usually turn this option off in favor of manually setting a normalization by changing the scale option. It is important to note that the autoScale and scale options scale the size of all the vectors regardless of whether scaleByMagnitude is turned on or off. The headSize changes the size of the head of the vector relative to its length. The thickness of the stem can changed using the stemWidth option colorByMag, colorTableName, vectorColor : Vector color If the option colorByMag is turned off, then all the vectors will be the same color. This color is specified by changing vectorColor to the desired RGBA tuple. For example, for opaque green vectors, we set vectorColor = (0, 255, 0, 255). If the option colorByMag is turned on, then the color of the vectors will be determined by their magnitudes and the color table specified by the colorTableName option. By default, the color table will run over the entire range of magnitudes present in the data. If we want to restrict this range, we can turn on the options minFlag and maxFlag and specify the minimum and maximum magnitudes by changing min and max. glyphLocation, nVectors, useStride : Vector placement The choices for glyphLocation are AdaptsToMeshResolution and UniformInSpace. VisIt uses AdaptsToMeshResolution as a default. In this case, areas with a finer grid (for example when using adaptive mesh refinement) will have a denser distribution of vectors while areas with a coarser grid will have a coarser distribution of vectors. Sometimes, this can lead to awkward-looking plots where VisIt places most of the vectors in the region where the grid is the finest. If we find AdaptsToMeshResolution causes the vectors to be too unevenly distributed across the plot, then we set glyphLocation to UniformInSpace to place vectors uniformly regardless of the grid. If useStride is set to false (which is the default), then VisIt will attempt to place a fixed number of vectors specified by the nVectors field (note that this is the number of vectors VisIt places before any selection operators are applied). In the case that there are too many vectors or that the vectors are placed too close to each other, we can set useStride to true. Doing this allows us to set the spacing between adjacent vectors by changing the stride field. It is also helpful to note that by default, the vectors VisIt draws represent the vector field at the tail of the vector. To change this, we can change vectorOrigin option from Tail to Head or Middle. By default, VisIt will place vectors across the entire grid which doesn\u2019t give us precise control over the visualization. In a later section (Sec. 5.4) we will describe how to use expressions and selection operators to restrict the vector plot to specific locations.","title":"Vector Fields"},{"location":"Section4/#streamline-integration","text":"Streamline integration is another way to visualize vector fields in VisIt. In many cases, it can be more intuitive than vector plots. Since VisIt allows us to specify the seed points for streamlines, we can emphasize the parts of the vector field that we want to focus on. Given a stationary smooth vector field F i and an initial condition xi(\u03bb = 0), there exists a unique streamline x(\u03bb) that satisfies dxi d\u03bb = F i. The streamline traces a particle\u2019s movement through the vector field. For example, in an electric field Ei, a streamline seeded by a point x0 traces the movement of a positive charge through Ei that starts at x0. In practice, numerical integrators look at the vector field around some starting point x(t) and predict the position of the particle that moves along this vector field after some small time dt. Then the process is repeated for the new starting point x(t + dt). In this section, we will be visualizing the same vector field we used in section 4.2.3 but this time using streamlines. In the GUI, we open sample vector field.vtk as a database. Streamlines plot is actually the integral curve operator applied to the pseudocolor plot. In the Add plots dropdown, navigate to: Pseudocolor \u2192 operators \u2192 IntegralCurve \u2192 vec field (Fig. 29). Figure 29: Adding a streamline plot Next, we need to pick seed points to use. To do this, we open the OpAtts (operator attributes) dropdown menu at the top of the window and select: Integral Curves \u2192 IntegralCurve. Since our vector field is spherically symmetric, we will choose seed points that lie on the surface of a sphere. In the Source tab of the integral curve operator attributes window that opens up, select Sphere. Set Radius to \u20185\u2019 (note that Origin is already set to \u20180 0 0\u2019 by default). Next, we set Samples in Latitude and Samples in Longitude to \u201810\u2019 and set Samples in R to \u20181\u2019. These settings will pick points uniformly distributed (with respect to the \u03b8 and \u03d5 spherical coordinates) on the surface of a radius 5 sphere. Additionally, in the Integration tab, change Integration Direction to Both so that the seed points integrate parallel and anti-parallel to the vector field. Finally, in the Appearance tab, change Color by to Vector magnitude. Note that the color table that is used is set by the pseudocolor settings (remember that IntegralCurve is an operator applied to a Pseudocolor plot). The different settings we applied are shown in Fig. 30 Click Apply and then click Draw. Our plot should look like Fig. 31 (as we can see, the field lines are radial as in a point charge.). When recreating this image in the CLI, we will use a different method to choose our points. Instead of using VisIt\u2019s built-in seed generator to create a circle of seed points, we can use a Python tuple. For example, if we want to use n seed points {(xi, yi, zi}n i=1, then we can set the pointList attribute equal to (x1, y1, z1, x2, y2, z2, . . . , xn, yn, zn). Figure 30: Integral Curve Attributes Figure 30: Integral Curve Attributes Figure 31: Example Streamline Plot This way, we can write our own scripts to generate seed points. In the following example, we use NumPy. Another option is to read from a previously created text file. The CLI script that recreates the plot is in Code Lst. 4.2.4 and can also be found at VisIt-Guide/sec 4/sample density.vtk . 1 import numpy as np 2 from visit import * 3 4 R = 5.; num_samples = 10 5 thetas = np.linspace(0, np.pi, num_samples) 6 phis = np.linspace(0, 2*np.pi, num_samples) 7 points = [] 8 for phi in phis: 9 for theta in thetas: 10 x = R*np.cos(phi)*np.sin(theta) 11 y = R*np.sin(phi)*np.sin(theta) 12 z = R*np.cos(theta) 13 points.extend([x, y, z]) 14 15 OpenDatabase(\"sample_vector_field.vtk\") 16 AddPlot(\"Pseudocolor\", \"vec_field\") 17 AddOperator(\"IntegralCurve\") 18 19 p = PseudocolorAttributes() 20 p.minFlag = 1; p.min = 0 21 SetPlotOptions(p) 22 l = IntegralCurveAttributes(); l.sourceType = l.PointList 23 l.pointList = tuple(points); l.integrationDirection = l.Both 24 SetOperatorOptions(l) 25 26 c = View3DAttributes() 27 c.viewNormal = (1.0, -0.35, 0.35); c.viewUp = (0, 0, 1) 28 SetView3D(c) 29 s = SaveWindowAttributes(); s.format = s.PNG 30 s.outputToCurrentDirectory = 1; s.fileName = \"streamline_fol/output\" 31 SetSaveWindowAttributes(s) 32 DrawPlots() 33 SaveWindow() Code Listing 4.2.4: run streamline.py Now that we know how to create streamline plots from a set of seed points, we will go over some important integration settings. For our visualizations, we primarily tune the following integration parameters. PseudocolorAttributes() : Streamline color In the CLI, changing the color of the streamlines is done by changing the PseudocolorAttributes() corresponding to the plot (it seems that in the CLI, the streamlines are automatically colored by magnitude which cannot be changed). To have constant color streamlines, a constant color table must be created (see Sec. 4.4 for how to create a custom color table). This can be applied to the streamlines plot by setting colorTableName to the new color table. As usual with settings pertaining to color, we can set the bounds of the color table by turning on minFlag, maxFlag and changing min, max. maxStepLength : Maximum step length taken at each integration step In practice, decreasing the maximum step length increases the smoothness of the streamline. Integrators commonly increase the step length when the magnitude of the vector field is greater, which can lead to jagged streamlines in areas where the field is strong. If you find that your streamlines are jagged, decrease maxStepLength until your streamlines are smooth. However, if your step length is too small, then your streamlines can get caught up in numerical errors. It is important to note that decreasing the step length will decrease the overall length of your streamline, which can be counteracted by increasing maxSteps. maxSteps : Number of integration steps taken For a fixed maxStepLength, increasing the number of integration steps typically increases the length of the streamline. Since integrating more steps increases computational complexity, we recommend starting with a smaller number of steps (\u2248 1000) and increasing the number of steps until you are satisfied with your image. A helpful way to visualize your seed points is by setting the number of steps to 1-10. If you increase maxSteps but you don\u2019t see any change in the length of your streamlines, try using a different integrationType and maxStepLength. integrationDirection : Integrate parallel or anti-parallel with the vector field You can integrate your seed points along the vector field using the Forward option (think the movement of a positive charge in an electric field) and you can integrate your seed points against the vector field using the Backward option (think the movement of a negative charge in an electric field). To integrate in both directions, use the Both option. integrationType : Integration algorithm used Integration methods affect the stability of the streamline. Lower-order integrators such as Euler (first-order) or Leapfrog (second-order) are less accurate at following the exact solution than Runge-Kutta (fourth-order) methods. However, streamline integration in 3D is very finicky, and we sometimes have used Euler/Leapfrog to get better images. DormandPrince : Runge-Kutta-Dormand-Prince This is VisIt\u2019s most advanced integrator, which allows the user to pick tolerances that match the simulation data. It also uses an adaptive step length which you can limit by changing maxStepLength. We recommend defaulting to this integrator and experimenting with the settings before trying other options. RK4 : Runge-Kutta 4 This is a standard RK4 fourth-order integrator that uses a fixed step length that the user can change by changing maxStepLength (this setting limits the maximum step length for adaptive step integrators and sets the step length for fixed step integrators). Euler/Leapfrog : Euler implements the standard first-order Euler method integrator and Leapfrog is a second-order integrator. These are also fixed step length integrators. Since lower-order integrators are more prone to error, we don\u2019t recommend using these unless you\u2019ve exhausted the other options.","title":"Streamline Integration"},{"location":"Section4/#expressions","text":"There are often mathematical relationships derived from the different variables that exist in our simulation data we will want to visualize. To address this need within scientific visualizations, VisIt allows us to create mathematical expressions from database variables. Figure 32: Expression window within VisIt In the GUI, expressions can be created and edited in the expressions window at Controls\u2192Expressions. On the left-hand side, there is an expression list that contains a list of different expressions that have either been automatically created by VisIt or manually created by the user (Fig. 32). On the right-hand side, we see the definitions for the mathematical expression that we have selected from the expression list, which can be broken down into the Standard editor or the Python expression editor. In order to create a new expression, there is a New button at the bottom left corner of the editor. From here, the expression can be defined using the Python expression editor window or the standard editor window. There are multiple different options based on what type of variable is being edited, found in the Type drop-down menu, which changes the use of the application of the mathematical expression as expected. We commonly use expressions in VisIt to normalize and transform the simulation data when creating the visualization. For instance, in our visualizations of the fluid rest-mass density, we plot the density in the units of initial maximum density as log(\u03c10/\u03c1max 0 (0)) instead of just \u03c10 so that we can have more clarity. As an example, we will create this expression using the sample density.vtk density file we visualized in Sec. 4.2.1 and Sec. 4.2.2. In VisIt, begin by navigating to Controls \u2192 Expressions and create a new expression within the expression window. Within this situ- ation, we would like to transform the density variable, and after a simple examination of the sample density.vtk file, we can find that the max variable is 1200.0. Using this information, we can write the expression as seen within Fig. 33. After doing so, we use this variable by clicking the Apply button Figure 33: Set up for log \u03c1 expression From here, we can create an isosurface rendering of the density, which can be done following the steps listed in Sec. 4.2.2. The final image should look similar to Fig. 34. Another way to use expressions is to create a vector field from three scalar fields. If the data for the x, y, and z components of a vector field are contained in three separate scalar databases, then they must be combined into a vector field expression before we create Vector or IntegralCurve plots with the vector field data. For HDF5 data, the individual scalar databases must be cast onto the same mesh before they are combined into a vector expression. We will use HDF5 databases Bx.file * database, By.file * database, Bz.file * database that contain magnetic field data that is output by the Illinois GRMHD code as an example. After opening up these databases as the same type (in this case it would be CarpetHDF5), we must create new scalar expressions of these databases after they have been cast onto the Carpet AMR-grid. Figure 34: Isosurface rendering of log(\u03c1) - sample density This is done with conn cmfe() method. For the Bx.file * database which has the HDF5 prefix MHD EVOVLE, we would do: conn_cmfe( , ) Using this expression, we create new expressions Bx, By, Bz for the three components of the magnetic field that all share the same grid. To do this on the GUI for Bx, we create a new Scalar mesh variable in the expressions window. We name it Bx and input the entire conn cmfe() command shown above into the definition. We repeat the process for By and Bz. Then to create a vector field, we create a new Vector mesh variable. We name it Bvec and input {Bx, By, Bz} into the definition. The expressions for Bx and Bvec are shown in Fig. Figure 35: Creating a vector expression from scalar HDF5 databases Figure 35: Creating a vector expression from scalar HDF5 databases In the command line, this can be done using Code Lst. 4.3 which can also be found at VisIt-Guide/sec 4/define_vec_field.py . 1 OpenDatabase(\"/path/to/data/Bx.file_* database\", 0, \"CarpetHDF5_2.1\") 2 OpenDatabase(\"/path/to/data/By.file_* database\", 0, \"CarpetHDF5_2.1\") 3 OpenDatabase(\"/path/to/data/Bz.file_* database\", 0, \"CarpetHDF5_2.1\") 4 5 DefineScalarExpression(Bx, \"conn_cmfe(</path/to/data/Bx.file_* \\ 6 database[0]id:MHD_EVOLVE--Bx>, <Carpet AMR-grid>)\") 7 DefineScalarExpression(Bx, \"conn_cmfe(</path/to/data/By.file_* \\ 8 database[0]id:MHD_EVOLVE--By>, <Carpet AMR-grid>)\") 9 DefineScalarExpression(Bx, \"conn_cmfe(</path/to/data/Bz.file_* \\ 10 database[0]id:MHD_EVOLVE--Bz>, <Carpet AMR-grid>)\") 11 12 DefineVectorExpression(\"Bvec\", \"{Bx, By, Bz}\") Code Listing 4.3: define vec field.py","title":"Expressions"},{"location":"Section4/#exporting-attributes","text":"A typical workflow when using VisIt is to experiment with plot/operator settings using the more intuitive GUI, and then implementing these settings in the CLI so they can be applied to a whole suite of visualizations. Thankfully, if you need to change a lot of settings, you don\u2019t need to write a separate line of code for each setting like in the run vector.py example (Code Lst. 4.2.3). Instead, VisIt allows your to export plot/operator settings in the GUI as .xml files which can then be loaded in the CLI. For example, if you are making a visualization that includes a volume plot, you will probably want to finely tune things like the color table and opacity values until you are satisfied with an image. If you don\u2019t want to use any of the default VisIt color tables, then the first step would be to create your own color table. First we launch the VisIt GUI, then we open up the color table settings by opening the Controls dropdown menu in the toolbar and clicking Color table (Fig. 36). In the window that opens up, we can change the settings to our liking. When creating a new color table, the first step is to choose the number of colors we want. Changing this field will change the number of \u201ccolor tabs\u201d in the window. To change each individual color, we can click the \u201ctab\u201d and change the RGB values respectively. We can also specify an alpha value, which determines the transparency of the color (0 is transparent, 255 is opaque). Changing the opacities is especially useful when using isosurface rendering. This is because there is an option to use the opacity from the color table which gives us finer control over the opacity of the isosurfaces. We can also choose how the colors are smoothed into each other. Figure 36: Creating color tables When we are done, we need to export the color table so it can be used in other parts of VisIt. First, we give the color table a name in the Name field (in the example below, we name our custom black and yellow color table my colortable). Then we click New and then Export to save this color table in \u223c/.visit/ (e.g. our color table saves as \u223c/.visit/my colortable.ct). Now, we are able to access this color table from the CLI. For example in Code Lst. 4.2.3, we can write v.colorTableName = 'my_colortable' instead of v.colorTableName = 'hot' to use our custom color table for the vector plot. To be more precise with our custom color table, we can open up the exported .ct file to change the exact locations and the specific RBGA values of each color. If we want to use custom color tables on another machine, we need to copy all the .ct files from the first machine to the \u223c/.visit/ folder on the second machine. The next step in specifying settings for our volume plot would be to experiment with and export the volume settings as an .xml file. First, we load up whichever database we want to visualize using a volume plot. Then we open up the volume settings in the GUI by navigating to Volume in the PlotAtts dropdown menu in the GUI toolbar. We then configure our volume settings to our liking (we can choose the custom color table that we just made). When we are satisfied with the plot, we can click Save which opens a file explorer. We then enter where we want to save your volume attributes .xml file before saving (Fig. 37) Figure 37: Exporting attributes to .xml files Now that we have a volume attributes .xml file saved, instead of specifying the volume settings one by one in the CLI like shown in Code Lst. 4.4. 1 v = VolumeAttributes() 2 v.attribute1 = x1 3 v.attribute2 = x2 4 ... 5 SetPlotOptions(v) Code Listing 4.4: Changing settings manually in CLI we can simply import our settings from the .xml file like shown in Code Lst. 4.4 1 v = VolumeAttributes() 2 LoadAttribute('/path/to/my_volume.xml', v) 3 SetPlotOptions(v) Code Listing 4.4: Importing settings from a .xml file We usually like to store the more commonly reused settings, or more complicated settings such as color tables or the freeformOpacity volume setting in .ct and .xml files. For some settings that we change very often, it is still useful to directly set them in the CLI. Commonly, we load a saved .xml file, and then override specific settings with our own choices. Figure 38: View 3D diagram","title":"Exporting Attributes"},{"location":"Section4/#finalizing-images","text":"After you\u2019ve decided on the plots, operators, and settings, the last step is to decide how you want to present your 3D visualization. The first step is to set the View3DAttributes, which basically determine where you place and point the camera and how far it zooms in on the plot. You\u2019ve already seen these options in all of the CLI sample scripts we\u2019ve shown previously. The three most important parameters are focus, viewNormal, viewUp, and imageZoom. The focus is where the camera points, which is commonly set to the main object being visualized. The viewNormal specifies the location of the viewer/camera and the viewUp specifies which direction is \u2018up\u2019 in the final image. See Fig. 38 for a better understanding. The imageZoom simply controls how zoomed in the camera is on the focus. In your script, to set the view of your plot, add lines like 1 c = View3DAttributes() 2 c.viewNormal = (1.0, 1.0, 1.0) 3 c.viewUp = (0.0, 0.0, 1.0) 4 c.focus = (0.0, 0.0, 0.0) 5 c.imageZoom = 1 6 SetView3D(c) Setting Options Manually in CLI The next things to change when finalizing an image would be the annotations. The VisIt labels and legends aren\u2019t super customizable, so the numerical relativity visualizations we make don\u2019t make use of them. With the exception of the t/M label, we finalize our images by removing all VisIt legends and labels, and adding our own with image editors like GIMP or Photoshop. However, we will still briefly go over some of the options you have. Figure 39: Text Annotations o open the annotation settings in the GUI, click Annotation in the Control dropdown menu. The setting that you might want to change first is the background color, which can be found in Colors tab of the window that opens up. Change this to something that will make your visualization stand out. To add text to your image, in the Objects tab, click the Text button on the upper left, and configure things like the position, content, and font (Fig. 39). You can turn off things like the legends (e.g. colorbars), axes, and bounding boxes by unchecking the boxes in the General and 3D tabs. Below in Code Lst. 4.5, we provide a code snippet that applies these annotation settings we\u2019ve discussed. 1 a = AnnotationAttributes() 2 a.backgroundMode = a.Solid 3 a.backgroundColor = (155, 155, 155, 255) #gray 4 a.legendInfoFlag = 0 5 a.userInfoFlag = 0 6 a.axes3D.visible = 0 7 a.axes3D.triadFlag = 0 8 a.axes3D.bboxFlag = 0 9 SetAnnotationAttributes(a) 10 11 txt = CreateAnnotationObject(\"Text2D\") 12 txt.position = (0.75, 0.95) #(x,y) where x and y range from 0 to 1 13 txt.useForegroundForTextColor = 0 14 txt.textColor = (255, 255, 255, 255) 15 txt.fontBold = 1 16 txt.fontFamily = txt.Times 17 txt.text = \"t/M = {}\".format(int(t/M)) Code Listing 4.5: Applying annotation settings The final step is to specify the SaveWindowAttributes, which deal with the format of the saved image file. You can choose where the image is saved, and the aspect ratio of the image, among other settings. An example is shown in Code Lst. 4.5. 1 s = SaveWindowAttributes() 2 s.format = s.PNG 3 s.outputToCurrentDirectory = 1 #so we can choose where to output 4 s.fileName = \"/path/to/output\" 5 s.width = 1920 #creates a 1920 X 1080 image 6 s.height = 1080 7 s.resConstraint = s.NoConstraint 8 SetSaveWindowAttributes(s) Code Listing 4.5: Saving a plot to an image file","title":"Finalizing Images"},{"location":"Section5/","text":"Typical VisIT Workflow in Numerical Relativity In this section, we will go over some typical plots you might want to make when visualizing numerical relativity datasets. Specifically, we will cover general methods that apply to all types of astrophysical systems before going more in-depth with examples after this section. We will cover how we visualize black holes and their spin vectors, fluid density fields, fluid velocity fields, and magnetic fields. The raw data that we use, have been generated by the Illinois GRMHD code. Three-dimensional HDF5 data can be loaded directly into VisIt, however, some plots will require some preprocessing before they can visualized in VisIt. In these cases, we will explain how we process simulation output into something that VisIt can use. Black Holes and Spin Vectors Black holes form an integral component for numerical relativity simulations and being able to plot them successfully is often a good first check for testing one\u2019s visualization software. The first thing to do is to preprocess the simulation output into .3d files that can be used by VisIt. At each time step, the horizon finder in Illinois GRMHD generates an ASCII file named like h.t120064.ah1.gp. The 120064 corresponds to the iteration number (i.e. the time in the simulation) and the ah1 is the label for the black hole. For example, in a binary black hole simulation, ah1 ah2 would correspond to the two black holes in the binary and ah3 would be the remnant (once it appears). These files contain a variety of information about the black hole apparent horizon, but for visualization purposes, we are only interested in the global x, global y, and global z columns, which contain a list of (x, y, z) coordinate values that trace the black hole horizon. If you are using some other code, you will need a horizon finder that outputs a list of points on the horizon surface. To visualize these points, we want to create a .3d file containing data for a constant scalar field. If the points we are interested in from the .gp file are (xi, yi, zi) with i \u2208 {1, 2, . . . , n} then the .3d file we want to create will look like 1 x y z bh1p 2 x1 y1 z1 0 3 x2 y2 z2 0 4 ... 5 xn yn zn 0 bh1.3d This creates a constant scalar field with some value (here we choose 0) that is only defined at points on the black hole horizon. From these, we can visualize the black hole by connecting these points to form a surface in VisIt and then choosing a color table that maps the value 0 to black. To visualize this file, the first thing we need to do is to enable the Delaunay operator, which creates a closed surface from our list of points. This operator is disabled by default in VisIt and the only way to enable it is through the GUI. To do this, navigate to Plugin Manager in the Options dropdown menu. Then check the box next to Delaunay in the Operators before clicking Apply . Now, the option will be enabled for your account on the machine you are using. If another user is using VisIt, they will need to also enable this option. Additionally, if we use a different machine, we will need to enable this option. We will not need to enable this option every time we launch VisIt on a given machine, so once we enable it on the GUI, we can access the operator normally in the CLI. After these steps, plotting the black hole is quite simple. The actual plot we use in VisIt is the pseudocolor plot, which we then apply the Delaunay operator to. First, load the .3d file, then add the pseudocolor plot and apply the Delaunay operator. Finally, choose a color table that maps the value we have chosen for our constant field to black. In our case, the gray color table maps 0 to black. After talking about the optional spin vector, we will provide a script that does the above plotting. To visualize the spin vector of the black hole, we will need a diagnostic file that lists the three components of the black hole angular momentum (Jx, Jy, Jz ) at each time. To actually visualize the spin vector, we will use a rather \u201chacky\u201d method involving the Vector plot. Since VisIt doesn\u2019t allow us to place vectors by hand, we will create a constant vector field using a .vtk file and then restrict the plot to a small area around the black hole. The spin vec.vtk file looks like 1 # vtk DataFile Version 2.0 2 spin_vector 3 ASCII 4 DATASET STRUCTURED_POINTS 5 DIMENSIONS 3 3 3 6 ORIGIN -30 -30 -30 7 SPACING 30 30 30 8 POINT_DATA 27 9 VECTORS spinvec float 10 Jx Jy Jz 11 Jx Jy Jz 12 ... spin vec.vtk where the Jx Jy Jz line is repeated a total of 27 times (since in this .vtk file, we are specifying a vector field on a 3 \u00d7 3 \u00d7 3 grid). This essentially creates a uniform vector field with the chosen values in the region x, y, z \u2208 (\u221230, 30). To plot only one vector on the black hole, you will first need the \u201ccenter of mass\u201d (x0, y0, z0) of the black hole, which you can get by averaging all the points in the .3d file. To plot the vector in VisIt, open this spin vec.vtk file and add a vector plot. In the vector set- tings ( PlotAtts \u2192 Vector ), select Uniformly located throughout mesh for Vector placement in the Vectors tab. Set Color to Constant and select your desired color in the Data tab. Finally, turn off Autoscale and select your desired scale in the Glyphs tab. Next, add the Box operator to the Vector plot. In the box operator settings ( OpAtts \u2192 Selection \u2192 Box ), select Some for Amount of cell in the range and set the x, y, z limits to (x0, y0, z0) \u00b1 (0.0005, 0.0005, 0.0005). We choose these numbers based on the grid resolution. This way, only a single vector is plotted at the center of the box. Below is code that will plot a black hole and its spin vector and you can see the result in Fig. 40. 1 from visit import * 2 3 x0, y0, z0 = 0., 0., 0. #center of mass of black hole 4 OpenDatabase(\"/path/to/bh1.3d\") 5 OpenDatabase(\"/path/to/spinvec.vtk\") 6 ActivateDatabase(\"/path/to/bh1.3d\") 7 AddPlot(\"Pseudocolor\", \"bh1p\") #plot index 0 8 ActivateDatabase(\"/path/to/spinvec.vtk\") 9 AddPlot(\"Vector\", \"spinvec\") #plot index 1 10 SetActivePlots(0) #only apply options/operators to bh1 plot 11 Pseudo = PseudocolorAttributes(); Pseudo.colorTableName = \"gray\" 12 SetPlotOptions(Pseudo) 13 AddOperator(\"Delaunay\") 14 SetActivePlots(1) #only apply options/operators to spinvec plot 15 Vec = VectorAttributes(); Vec.glyphLocation = Vec.UniformInSpace 16 Vec.autoScale = 0; Vec.scale = 110; Vec.colorByMag = 0 #constant color 17 Vec.vectorColor = (0, 255, 0, 255) #green 18 SetPlotOptions(Vec) 19 AddOperator(\"Box\") 20 BoxAtts = BoxAttributes() 21 BoxAtts.minx = x0 - 0.0005; BoxAtts.maxx = x0 + 0.0005 22 BoxAtts.miny = y0 - 0.0005; BoxAtts.maxy = y0 + 0.0005 23 BoxAtts.minz = z0 - 0.0005; BoxAtts.maxz = z0 + 0.0005 24 SetOperatorOptions(BoxAtts) 25 a = AnnotationAttributes() 26 a.backgroundMode = a . Solid; a.backgroundColor = (155, 155, 155, 255) 27 SetAnnotationAttributes(a) 28 c = View3DAttributes() 29 c.viewNormal = (0.5, -1, 0); c.imageZoom = 300; c.viewUp = (0, 0, 1) 30 SetView3D(c) 31 s = SaveWindowAttributes() 32 s.format = s.PNG; s.outputToCurrentDirectory = 1 33 s.fileName = \"/path/to/output\" 34 SetSaveWindowAttributes(s) 35 DrawPlots(); SaveWindow() Plotting a black hole with a spin vector Figure 40: A tilted black hole with its spin vector. The black ellipse is the apparent horizon. Density A core aspect of numerical relativity simulations are the fluid dynamics of the system. Therefore, accurately plotting the behavior of the fluid is critical to gaining insight into the simulation\u2019s evolution. To plot the fluid density, we either use the Isosurface operator applied to the Pseudocolor plot (Sec. 4.2.2) or the Volume plot (Sec. 4.2.1). In this section, we will focus on how to use these rendering techniques to best showcase numerical relativity data. The Illinois GRMHD code outputs the fluid density data as HDF5 scalar data named rho b. When plotting this data, we will first consider the color table. The color table is important since it determines what the fluid density\u2014which we\u2019ve used to probe accretion disks and neutron stars\u2014will look like in the final visualization. By choosing the color table, we choose the color assigned to each density value. When choosing a color table, the goal (aside from aesthetics) is to be able to differentiate between different density values in the final image. Refer to Sec. 4.2.2, Sec. 4.4 for information related to creating and exploring a color table. Once we have a color table, it is then processed by VisIt through another .xml file, which contains information on how the pseudocolor will be plotted onto the data within the visualization, as seen be- low. A full example of the pseudocolor XML file can be found at VisIt-Guide/sec 5/rho_pseudo.xml 1 <?xml version=\"1.0\"?> 2 <Object name=\"PseudocolorAttributes\"> 3 <Field name=\"minFlag\" type=\"bool\">true</Field> 4 <Field name=\"min\" type=\"double\">-4</Field> 5 <Field name=\"maxFlag\" type=\"bool\">true</Field> 6 <Field name=\"max\" type=\"double\">-0.001</Field> 7 <Field name=\"colorTableName\" type=\"string\">bhbhdisk</Field> 8 <Field name=\"opacityType\" type=\"string\">ColorTable</Field> 9 <Field name=\"opacityVariable\" type=\"string\">logrho</Field> 10 <Field name=\"opacityVarMin\" type=\"double\">-4</Field> 11 <Field name=\"opacityVarMax\" type=\"double\">-0.001</Field> 12 ... 13 </Object> rho_pseudo.xml There are several interesting attributes to be aware of within this xml file, as they will directly influence the resultant visualization. Starting from the top of the xml file, the min and max fields directly correspond to the maximum and minimum values in which the colorbar will interpolate its values as mentioned above. The colorTableName field refers to the color table that VisIt will use within its pseudoplots as found within the /home/ USERNAME /.VisIt directory. The opacityType field corresponds to where VisIt will pull the opacity value mapping within the modeling process. Generally speaking, the minFlag, maxFlag, opacityVarMinFlag, opacityVarMaxFlag fields should be set to False; however it can also provide useful information during the visualization development process. Isosurface During the isosurface rendering process, there are different considerations one needs to take into account. The following is an example of an XML that controls the configuration surrounding the isosurface rendering operator: 1 <?xml version=\"1.0\"?> 2 <Object name=\"IsosurfaceAttributes\"> 3 <Field name=\"contourNLevels\" type=\"int\">21</Field> 4 <Field name=\"contourValue\" type=\"doubleVector\">-2.6 5 -2.5 -2.4 -2.3 -2.2 -2.1 -2.0 -1.9 -1.8 -1.7 -1.6 -1.5 6 -1.4 -1.3 -1.2 -1.1 -1.0 -0.9 -0.8 -0.7 -0.6</Field> 7 <Field name=\"contourPercent\" type=\"doubleVector\">0.1</Field> 8 <Field name=\"contourMethod\" type=\"string\">Value</Field> 9 <Field name=\"variable\" type=\"string\">logrho</Field> 10 ... iso.xml The first field parameter to note in this xml file is the contourMethod field. Essentially building off the concepts discussed within Sec. 4.2.2, this field parameter lets VisIt know what method it should use when calculating the contour shells within the model\u2019s visualization. There are two methods that VisIt uses in order to generate the shells or the levels within the visualization: Percentage and Value. With the Percentage parameter, VisIt will interpolate the different contour levels by dividing the range between the minimum/maximum density by either a percentage set by the user or interpolation. Alternatively, the Value parameter will allow the user to set which specific values within data to create contour shells as seen within the contourValue field, giving the user more control over their model. Generally speaking, the greater the quantity of shells within a visualization, the higher the quality of the image, so be sure to assess the computational capabilities at hand when creating these figures. Visualizations in numerical relativity are usually created on high performance computing systems due to the volume of data and computational intensity of the tasks. Experimenting to understand the limits of the high performance computing systems is vital to the efficiency in the visualization tasks. Knowing exactly how long a visualization might take to complete as well as the resources used within the visualization process is especially important to the visualization process. We lay out the VisIt-CLI code for creating and loading up isosurface and pseudocolor attribute files shown within the following python script: 1 from visit import * 2 3 # plotting density data with isosurface rendering 4 5 6 #adding the pseudocolorplot 7 # loading the density data into visit 8 densityplot = ActivateDatabase(Path_to_Density_data) 9 10 #loading up the pseudocolorplot xml settings into the plot 11 #-> GUI equivilant to changing the Pseudocolor plot settings 12 #through the dropdown menu 13 LoadAttribute(Path_to_Pseudocolor_plot_xmlfile, densityplot) 14 15 # adding the pseudocolor plot 16 AddPlot(\"Pseudocolor\", \"density\") 17 SetActivePlots(plot_idxs.index(\"density\")) 18 #loading up plotting data 19 SetPlotOptions(densityplot) 20 21 # Adding the Isosurface operator 22 23 #loading in the isosurface operator 24 iso = IsosurfaceAttributes() 25 #adding isosurface operator settings 26 LoadAttribute(Path_to_iso_xml, iso) 27 #adding operator to plot 28 AddOperator(\"Isosurface\") 29 #making sure the plot has the operator xml settings 30 SetOperatorOptions(iso) Code Listing 5.2.1: plot_density_isosurface.py Volume Similar to the isosurface rendering plot, the volume rendering plot is also primarily controlled through the volume rendering xml settings in Sec. 4.2.1. The following is an example xml file that controls the volume rendering plot configurations: 1 <?xml version=\"1.0\"?> 2 <Object name=\"VolumeAttributes\"> 3 <Field name=\"legendFlag\" type=\"bool\">false</Field> 4 <Field name=\"lightingFlag\" type=\"bool\">false</Field> 5 <Field name=\"opacityAttenuation\" type=\"float\">1</Field> 6 <Field name=\"samplesPerRay\" type=\"int\">1000</Field> 7 <Object name=\"colorControlPoints\"> 8 <Object name=\"ColorControlPointList\"> 9 <Object name=\"ColorControlPoint\"> 10 <Field name=\"colors\" type=\"unsignedCharArray\" 11 length=\"4\"> 255 255 255 255 </Field> 12 <Field name=\"position\" type=\"float\">0</Field> 13 </Object> 14 ... iso.xml Breaking down the important attributes of this xml file, there are several important field parameters and considerations to make during the visualization development process. As mentioned previously, the colorControlPointList field parameter controls the pseudocolor plot within the volume rendering plot, delineating the different density values across the plot. The samplesPerRay parameter controls the overall quality of the image, as the smoothness and resolution of the plot is proportional to the magnitude of this field parameter. However, it should be duly noted that volume rendering is a computationally taxing operation to conduct, with this process being nearly ten times more resource intensive than isosurface rendering. Therefore, the operation becomes exponentially more computationally intensive with a higher magnitude of samplesPerRay, so be weary of the capabilities of the high performance computing systems when developing these visualizations. Adjusting the opacityAttenuation will also influence the overall transparency of the disk at the cost of computational intensity within the visualization. Generally speaking, it may be useful to adjust the colorbar and viewing angle through different rendering techniques before experimenting with the volume renderings in order to understand how different iterations of the visualization may appear. We use the volume attributes as shown in the volume rendering section. 1 from visit import * 2 3 4 # volume rendering in VisIT 5 6 #loading in the density data into VisIT 7 ActivateDatabase(path_to_density_data) 8 #creating an instance where we could set the volume attributes 9 density_atts = VolumeAttributes() 10 #loading in our xml settings for the density attributes 11 LoadAttribute(path_to_volume_xml_file, density_atts) 12 #creating a volume plot with the logrho variable 13 AddPlot(\"Volume\", \"logrho\") 14 SetActivePlots(plot_idxs.index(\"density\")) 15 #making sure the volume plot has the proper settings 16 SetPlotOptions(rho_atts) Code Listing 5.2.2: plot_density_volume.py Magnetic Field Lines Streamlines (or integral curves) are the plots that we use to visualize the magnetic field in GRMHD simulation data. This is because the IntegralCurve plot allows you to specify the exact locations of the seed points from which VisIt will integrate. The general information pertaining to the IntegralCurve plot, such as the important attributes, can be found in section 4.2.4. This section will instead focus on how to choose seed points to create magnetic field lines that reveal important physics in the simulation data. The Illinois GRMHD code outputs the magnetic field data as three HDF5 scalar fields Bx, By, Bz. To combine these into a vector field in VisIt, follow the directions in section 4.3. Similarly, the process of drawing field lines is the same as specified in section 4.2.4. We use two methods to draw magnetic field lines: particle seeds and grid seeds. Particle Seeds In GRMHD magnetic field lines are attached to particles of matter (i.e. the field lines are \u201dfrozen in\u201d to the matter particles). Whenever a particle of matter moves, then the magnetic field line should move with it. For example, the magnetic field lines in a magnetized rotating neutron star would rotate with the star. The Illinois GRMHD code keeps track of the x, y, and z positions of a selected group of n fluid particles (n is usually chosen to be between 1000 and 10, 000) at every iteration: {(xi(t), yi(t), zi(t))}n i=1. These locations are tracked by integrating an initial set of particles {(xi(0), yi(0), zi(0))}n i=1 along the fluid velocity field. In order to visualize a magnetic field line that follows the motion of the fluid\u2014as it should\u2014we use the locations of particles as seed points for our magnetic field lines. The simulation outputs the positions of n particles at all times {(xi(t), yi(t), zi(t))}n i=1 so we have a large option of particles to choose from. In practice, we don\u2019t draw field lines with all n particles, but instead choose a subset of m particles to follow (usually m < 100 but it depends on the system) These m particles are chosen so that the magnetic field lines drawn at the initial time t = 0 using the seeds {(xik (0), yik (0), zik (0))}m k=1 represent the physics that we want to probe on. Then the positions of these m particles are used to seed the magnetic field lines in all subsequent frames t \u2265 0. As a result, the magnetic field lines drawn follow the flow of the matter. Fig. 41 shows a binary neutron star simulation with magnetic field lines at two times t/M=5 and t/M=696. At t/M=5, which is close to the initial time t/M=0, the magnetic field lines look dipole like and showcase the magnetic field present in the binary system. Then at t/M=696, notice how the magnetic field lines are still seeded from within the two neutron stars. If we don\u2019t use particle seeds to seed magnetic field lines here, then the visualized magnetic fields wouldn\u2019t follow the neutron stars as they inspiral. Figure 41: Particle seeded field lines in binary neutron stars The process of choosing which particles to follow\u2014as mentioned earlier\u2014comes down to choosing which particles at t = 0 create a visualization that best showcases the physics of the system. The initial magnetic fields in numerical relativity simulations of merging neutron stars are commonly poloidal. Additionally, if the object that this magnetic field permeates has nonzero angular momentum, the angular momentum or spin axis usually is in alignment with the axis of the poloidal magnetic field. For this reason, we usually choose particles that form rings around this spin/magnetic-field axis. For example, each neutron star in the binary neutron star system of Fig. 41 initially has a poloidal magnetic field axis pointing in the vertical direction (\u00b1\u02c6z). Then we choose rings of points that lie in the xy-plane, which is orthogonal to the magnetic field axis. On the left panel of Fig. 41, the collection of smaller magnetic field line loops close to each neutron are created by a ring of points inside the neutron star with a larger radius. The field lines that extend further from the stars are created by a ring of points inside the neutron star with a smaller radius. Choosing the seed point rings that create nice visualizations still requires experimentation. Below in Code Lst. 5.3.1 (which can be found at VisIt-Guide/sec_5/seed_maker.py ), we provide a simple Python code that can draw these types of rings. There are options to choose where the rings are centered as well as the direction of the spin/magnetic-field axis. Below, we provide a summary of the different parameters of this script. centers : Center of the compact object This parameter is found in line 4 of seed_maker.py. It consists of a list of 3-tuples (each entry is a float) where each 3-tuple is the center of the compact object you want to place field lines around. pairs : Radius, height pairs that describe the ring This parameter is found in line 5 of seed_maker.py. It consists of a list of 2-tuples (each entry is a float). Each 2-tuple is of the form (radius, height). The radius specifies the radius of the ring and the height specifies the height of the ring with respect to the spin axis. spins : Axis that rings are orthogonal to This parameter is found in line 6 of seed_maker.py. It consists of a list of 3-tuples (each entry is a float) where each 3-tuple specifies the axis we want the ring of seed points to be orthogonal to. This axis usually coincides with the angular momentum axis (e.g. the spin axis of a black hole). num_seeds_per_ring: : Number of seeds per ring This parameter is found in line 7 of seed_maker.py. It consists of a list of integers that specify the number of seeds in each ring centers : Adjusts smoothness and resolution of plot As mentioned before, ray casting creates the plot by shooting rays and sampling the points in its path. By increasing the number of samples that are being cast through the data for each ray, we are able to improve the overall quality of the image. Having too few sample points along a ray gives rise to sampling artifacts such as rings or voids and decreases the overall \u201dsmoothness\u201d. However, sampling more points takes longer to render. We observe a 1:1 correlation between changes in image rendering time and the number of samples per ray. offsets : An angle to offset the seed placement This parameter is found in line 8 of seed_maker.py. It consists of a list of floats. These numbers specify an offset in the position of the individual points on the ring. Adding an offset of \u03c0 would rotate the points on the ring by 180\u25e6. reflectZ : Reflect seeds across equatorial plane Turning on this parameter reflects all the seeds across the equatorial plane. This equatorial plane is the plane orthogonal to the spin axis. 1 import numpy as np 2 3 # centers, pairs, spins, num_seeds_per_ring must have same length 4 centers = [(0., 0., 0.), (0., 0., 0.)] # list of 3-tuple centers (x, y, z) 5 pairs = [(3.0, 1.), (1., 1.)] # list of 2-tuple pairs(radius, height) 6 spins = [(0., 0., 1.), (0., 0., 1.)] # list of 3-tuple spins (Jx, Jy, Jz) 7 num_seeds_per_ring = [8, 8] # list of ints number of seeds per ring 8 offsets = [np.pi/8, np.pi/8] # offset in the angles of phi chosen 9 reflectZ = True 10 11 with open(\"seeds_0.txt\",\"w+\") as f: 12 f.write(\"{} {} {}\\n\".format(\"x\", \"y\", \"z\")) 13 for cen, pair, spin, num_steps, offset in zip(centers, pairs, spins, num_seeds_per_ring, offsets): 14 r, h = pair 15 spin_vec = np.array(spin); cen_vec = np.array(cen) 16 spin_vec /= np.linalg.norm(spin_vec) 17 u_vec = np.array([51., 50., 49.]) #random vector not parallel to spin 18 u_vec /= np.linalg.norm(u_vec) 19 #gram schmidt step 20 u_vec = u_vec - ( np.dot(u_vec, spin_vec) / np.dot(spin_vec, spin_vec ))*spin_vec 21 v_vec = np.cross(spin_vec, u_vec) 22 for phi in np.linspace(0 + offset, 2*np.pi + offset, num_steps, endpoint=False): 23 c = r*np.cos(phi); s = r*np.sin(phi) 24 p1 = cen_vec + c*u_vec + s*v_vec + h*spin_vec 25 f.write(\"{} {} {} {}\\n\".format(str(p1[0]), str(p1[1]), str(p1 [2]))) 26 if reflectZ: 27 p2 = cen_vec + c*u_vec + s*v_vec - h*spin_vec 28 f.write(\"{} {} {} {}\\n\".format(str(p2[0]), str(p2[1]), str (p2[2]))) Code Listing 5.3.1 seed maker.py Figure 42: Seed point rings orthogonal to spin Two rings of a specified radius are generated at a specified height above and below the plane orthogonal to the spin axis. As an example, in Fig. 42, four rings that lie on planes orthogonal to the spin vector of a tilted black hole are shown. Now we need to find which particle seeds among the total number of n seeds are closest to our chosen idealized seed points. This can be done by using a nearest-neighbor search using a K-D tree. In Python, you can load all the particles into scipy.spatial.KDTree and use the query method to return the nearest particle to an input point. After you choose the set of particles closest to your chosen seed points, you can use this set of particles to seed the magnetic field lines for the remainder of the simulation data. Grid Seeds While particle seeds are used to visualize the magnetic field in fluids such as neutron stars or accretion disks, we don\u2019t use them to visualize the magnetic field lines extending from the poles of black holes, since particles there are either captured or escape in jets. For black holes, we use grid points, which are just points we choose around the black hole that aren\u2019t attached to any fluid particles. To capture a potential jet, we choose points around black holes in a similar fashion to the way we choose idealized seed points. In particular, we want to draw two rings of seed points above and below the plane orthogonal to the spin axis of the black hole. Fig. 43 shows a spinning black hole surrounded by a gaseous accretion disk with twisted magnetic field lines seeded by a ring of points above the black hole. Throughout the evolution, make sure to have these rings of seed points follow the position and the spin of the black hole. When integrating these grid seeds that are around a black hole, make sure that the integrationDirection is not set to Both. We don\u2019t want the field lines to integrate into the black hole horizon. To do this, create a separate plot for the field lines above and below the black hole. For each of these plots, try setting the integrationDirection to different combinations of Forward and Backward so make sure the field lines integrate away from the horizon. Figure 43: Grid point seeded field lines above black hole Explicit examples and code that magnetic field lines seeded by particles and grid points can be found in the case studies later in the guide (Sec. 6, Sec. 7.3). Fluid Velocity Arrows We use the Vector plot (introduced in section 4.2.3) to visualize the fluid velocity vector field in GRMHD simulation data. We choose to use this plot rather than a streamline plot since it allows us to assess the behavior of the velocity field in areas of interest. For example, to determine if there is an incipient relativistic jet in a region that contains collimated magnetic fields, all of the velocities should be pointing in the direction of the jet. A vector plot allows us to populate the area of interest with many vectors pointing in the direction of the fluid velocity field. By looking at the behavior of these arrows, we can determine if the behavior of the fluid velocity fields matches our hypothesis. Like the magnetic field, the Illinois GRMHD code outputs the fluid velocity field data as three HDF5 scalar fields vx, vy, vz. By itself, the vector plot will place vectors of all magnitudes all over the grid. In numerical relativity, we are mostly interested in relativistic velocities in specific areas, as for example where a jet may form. We will use a combination of expressions and operators to plot the arrows we are interested in. These steps are often quite involved and require experimentation to get them right. For this reason, we usually only make vector plots of the fluid velocity at a handful of interesting times, rather than for a movie of the entire evolution. 1 #combining vx, vy, vz into vector expression 2 DefineVectorExpression(\"vVec_temp\",\"{vx,vy,vz}\") 3 4 #if magnitude(vVec_temp) > 0.5, use original data, 5 #else, set to {0,0,0} 6 DefineVectorExpression(\"vVec\",\"if(gt(magnitude(vVec_temp), \\ 7 0.5), vVec_temp, {0,0,0})\") 8 9 # below: only show arrows where the 10 #log(b^2/2*rho) plot is larger than -0.5 11 DefineVectorExpression(\"vVec\",\"if(gt(logbsq2r, -0.5), \\ 12 vVec_temp, {0,0,0})\") Code Listing 5.4: Restricting velocity plot After loading in the three scalar fields and combining them into a vector expression, new expressions can be created. For example, vectors can be filtered out based on their magnitude. On line 3 of the code listing above (Code Lst. 5.4), vectors with magnitudes less than 0.5c are set to zero so that only the relativistic velocities > 0.5c are shown. This number is arbitrary and can be changed to suit ones needs. Vectors can also be filtered out based on the values of other plots. For example, jets form in areas where the force-free parameter b2 /(2\u03c10 ) (see Sec. 7.4) is greater than some cutoff bigger than unity, so we might want to only plot vectors in these areas. On line \u2401 5, vectors in areas where log b2 /(2\u03c10 ) are less than \u22120.5 are set to zero. Note that to do this comparison, you will also need to load and define the logbsq2r scalar field. Note that in Code Lst. 5.4, we only choose to use one of the restrictions, so only one of lines 6 and 7 or 11 and 12 should be used. Figure 44: Restricting a vector plot of fluid velocity Figure 44: Restricting a vector plot of fluid velocity Once the vector data is loaded and filtered using expressions (if desired), selection operators can be added to the plot to restrict the plot to a physical region. On the GUI, these can be found in Operators \u2192 Selection. There are only a limited amount of options, but multiple selection operators can be applied if desired. The Box/Cylinder restricts the plot to the region inside (or outside if the Inverse option is selected) the shape. There is also a Clip operator, which can restrict the plot to inside or outside a sphere, or to one side of a plane. Below, there is an example of a vector plot of fluid velocity data from a GRMHD simulation before and after applying expressions and slicing operators (Fig. 44). Specifically, all vectors with magnitude less than 0.25c were set to zero and the plot was restricted to inside a cylinder that lies along the vertical axis. During this process of selecting different regions with selection operators, make sure you are also experimenting with the different vector attribute settings. Since GRMHD simulations commonly use finer grids in areas around compact objects, like black holes or neutron stars, the AdaptsToMeshResolution setting will place more arrows in the areas with a finer grid (as you can see in Fig. 44). So switching to UniformInSpace might give better results. If you find that different combinations of selection operators and vector settings don\u2019t give you a satisfactory visualization, another method is to create multiple vector plots using the same data. Then you can apply different operators and have different settings for different regions. Below is a visualization example that uses vector fluid velocity plots to visualize the relativistic jet following a binary black hole merger (Fig. 45). Explicit examples and code that visualize fluid velocity arrows can be found in the case studies later in the guide (see Sec. 7.4). In the following sections we will apply the knowledge we learned by walking through the steps taken to create visualizations from a select cases of GRMHD simulations done by the Illinois Relativity Group. Figure 45: Visualization with fluid velocity arrows","title":"Typical VisIT Workflow"},{"location":"Section5/#typical-visit-workflow-in-numerical-relativity","text":"In this section, we will go over some typical plots you might want to make when visualizing numerical relativity datasets. Specifically, we will cover general methods that apply to all types of astrophysical systems before going more in-depth with examples after this section. We will cover how we visualize black holes and their spin vectors, fluid density fields, fluid velocity fields, and magnetic fields. The raw data that we use, have been generated by the Illinois GRMHD code. Three-dimensional HDF5 data can be loaded directly into VisIt, however, some plots will require some preprocessing before they can visualized in VisIt. In these cases, we will explain how we process simulation output into something that VisIt can use.","title":"Typical VisIT Workflow in Numerical Relativity"},{"location":"Section5/#black-holes-and-spin-vectors","text":"Black holes form an integral component for numerical relativity simulations and being able to plot them successfully is often a good first check for testing one\u2019s visualization software. The first thing to do is to preprocess the simulation output into .3d files that can be used by VisIt. At each time step, the horizon finder in Illinois GRMHD generates an ASCII file named like h.t120064.ah1.gp. The 120064 corresponds to the iteration number (i.e. the time in the simulation) and the ah1 is the label for the black hole. For example, in a binary black hole simulation, ah1 ah2 would correspond to the two black holes in the binary and ah3 would be the remnant (once it appears). These files contain a variety of information about the black hole apparent horizon, but for visualization purposes, we are only interested in the global x, global y, and global z columns, which contain a list of (x, y, z) coordinate values that trace the black hole horizon. If you are using some other code, you will need a horizon finder that outputs a list of points on the horizon surface. To visualize these points, we want to create a .3d file containing data for a constant scalar field. If the points we are interested in from the .gp file are (xi, yi, zi) with i \u2208 {1, 2, . . . , n} then the .3d file we want to create will look like 1 x y z bh1p 2 x1 y1 z1 0 3 x2 y2 z2 0 4 ... 5 xn yn zn 0 bh1.3d This creates a constant scalar field with some value (here we choose 0) that is only defined at points on the black hole horizon. From these, we can visualize the black hole by connecting these points to form a surface in VisIt and then choosing a color table that maps the value 0 to black. To visualize this file, the first thing we need to do is to enable the Delaunay operator, which creates a closed surface from our list of points. This operator is disabled by default in VisIt and the only way to enable it is through the GUI. To do this, navigate to Plugin Manager in the Options dropdown menu. Then check the box next to Delaunay in the Operators before clicking Apply . Now, the option will be enabled for your account on the machine you are using. If another user is using VisIt, they will need to also enable this option. Additionally, if we use a different machine, we will need to enable this option. We will not need to enable this option every time we launch VisIt on a given machine, so once we enable it on the GUI, we can access the operator normally in the CLI. After these steps, plotting the black hole is quite simple. The actual plot we use in VisIt is the pseudocolor plot, which we then apply the Delaunay operator to. First, load the .3d file, then add the pseudocolor plot and apply the Delaunay operator. Finally, choose a color table that maps the value we have chosen for our constant field to black. In our case, the gray color table maps 0 to black. After talking about the optional spin vector, we will provide a script that does the above plotting. To visualize the spin vector of the black hole, we will need a diagnostic file that lists the three components of the black hole angular momentum (Jx, Jy, Jz ) at each time. To actually visualize the spin vector, we will use a rather \u201chacky\u201d method involving the Vector plot. Since VisIt doesn\u2019t allow us to place vectors by hand, we will create a constant vector field using a .vtk file and then restrict the plot to a small area around the black hole. The spin vec.vtk file looks like 1 # vtk DataFile Version 2.0 2 spin_vector 3 ASCII 4 DATASET STRUCTURED_POINTS 5 DIMENSIONS 3 3 3 6 ORIGIN -30 -30 -30 7 SPACING 30 30 30 8 POINT_DATA 27 9 VECTORS spinvec float 10 Jx Jy Jz 11 Jx Jy Jz 12 ... spin vec.vtk where the Jx Jy Jz line is repeated a total of 27 times (since in this .vtk file, we are specifying a vector field on a 3 \u00d7 3 \u00d7 3 grid). This essentially creates a uniform vector field with the chosen values in the region x, y, z \u2208 (\u221230, 30). To plot only one vector on the black hole, you will first need the \u201ccenter of mass\u201d (x0, y0, z0) of the black hole, which you can get by averaging all the points in the .3d file. To plot the vector in VisIt, open this spin vec.vtk file and add a vector plot. In the vector set- tings ( PlotAtts \u2192 Vector ), select Uniformly located throughout mesh for Vector placement in the Vectors tab. Set Color to Constant and select your desired color in the Data tab. Finally, turn off Autoscale and select your desired scale in the Glyphs tab. Next, add the Box operator to the Vector plot. In the box operator settings ( OpAtts \u2192 Selection \u2192 Box ), select Some for Amount of cell in the range and set the x, y, z limits to (x0, y0, z0) \u00b1 (0.0005, 0.0005, 0.0005). We choose these numbers based on the grid resolution. This way, only a single vector is plotted at the center of the box. Below is code that will plot a black hole and its spin vector and you can see the result in Fig. 40. 1 from visit import * 2 3 x0, y0, z0 = 0., 0., 0. #center of mass of black hole 4 OpenDatabase(\"/path/to/bh1.3d\") 5 OpenDatabase(\"/path/to/spinvec.vtk\") 6 ActivateDatabase(\"/path/to/bh1.3d\") 7 AddPlot(\"Pseudocolor\", \"bh1p\") #plot index 0 8 ActivateDatabase(\"/path/to/spinvec.vtk\") 9 AddPlot(\"Vector\", \"spinvec\") #plot index 1 10 SetActivePlots(0) #only apply options/operators to bh1 plot 11 Pseudo = PseudocolorAttributes(); Pseudo.colorTableName = \"gray\" 12 SetPlotOptions(Pseudo) 13 AddOperator(\"Delaunay\") 14 SetActivePlots(1) #only apply options/operators to spinvec plot 15 Vec = VectorAttributes(); Vec.glyphLocation = Vec.UniformInSpace 16 Vec.autoScale = 0; Vec.scale = 110; Vec.colorByMag = 0 #constant color 17 Vec.vectorColor = (0, 255, 0, 255) #green 18 SetPlotOptions(Vec) 19 AddOperator(\"Box\") 20 BoxAtts = BoxAttributes() 21 BoxAtts.minx = x0 - 0.0005; BoxAtts.maxx = x0 + 0.0005 22 BoxAtts.miny = y0 - 0.0005; BoxAtts.maxy = y0 + 0.0005 23 BoxAtts.minz = z0 - 0.0005; BoxAtts.maxz = z0 + 0.0005 24 SetOperatorOptions(BoxAtts) 25 a = AnnotationAttributes() 26 a.backgroundMode = a . Solid; a.backgroundColor = (155, 155, 155, 255) 27 SetAnnotationAttributes(a) 28 c = View3DAttributes() 29 c.viewNormal = (0.5, -1, 0); c.imageZoom = 300; c.viewUp = (0, 0, 1) 30 SetView3D(c) 31 s = SaveWindowAttributes() 32 s.format = s.PNG; s.outputToCurrentDirectory = 1 33 s.fileName = \"/path/to/output\" 34 SetSaveWindowAttributes(s) 35 DrawPlots(); SaveWindow() Plotting a black hole with a spin vector Figure 40: A tilted black hole with its spin vector. The black ellipse is the apparent horizon.","title":"Black Holes and Spin Vectors"},{"location":"Section5/#density","text":"A core aspect of numerical relativity simulations are the fluid dynamics of the system. Therefore, accurately plotting the behavior of the fluid is critical to gaining insight into the simulation\u2019s evolution. To plot the fluid density, we either use the Isosurface operator applied to the Pseudocolor plot (Sec. 4.2.2) or the Volume plot (Sec. 4.2.1). In this section, we will focus on how to use these rendering techniques to best showcase numerical relativity data. The Illinois GRMHD code outputs the fluid density data as HDF5 scalar data named rho b. When plotting this data, we will first consider the color table. The color table is important since it determines what the fluid density\u2014which we\u2019ve used to probe accretion disks and neutron stars\u2014will look like in the final visualization. By choosing the color table, we choose the color assigned to each density value. When choosing a color table, the goal (aside from aesthetics) is to be able to differentiate between different density values in the final image. Refer to Sec. 4.2.2, Sec. 4.4 for information related to creating and exploring a color table. Once we have a color table, it is then processed by VisIt through another .xml file, which contains information on how the pseudocolor will be plotted onto the data within the visualization, as seen be- low. A full example of the pseudocolor XML file can be found at VisIt-Guide/sec 5/rho_pseudo.xml 1 <?xml version=\"1.0\"?> 2 <Object name=\"PseudocolorAttributes\"> 3 <Field name=\"minFlag\" type=\"bool\">true</Field> 4 <Field name=\"min\" type=\"double\">-4</Field> 5 <Field name=\"maxFlag\" type=\"bool\">true</Field> 6 <Field name=\"max\" type=\"double\">-0.001</Field> 7 <Field name=\"colorTableName\" type=\"string\">bhbhdisk</Field> 8 <Field name=\"opacityType\" type=\"string\">ColorTable</Field> 9 <Field name=\"opacityVariable\" type=\"string\">logrho</Field> 10 <Field name=\"opacityVarMin\" type=\"double\">-4</Field> 11 <Field name=\"opacityVarMax\" type=\"double\">-0.001</Field> 12 ... 13 </Object> rho_pseudo.xml There are several interesting attributes to be aware of within this xml file, as they will directly influence the resultant visualization. Starting from the top of the xml file, the min and max fields directly correspond to the maximum and minimum values in which the colorbar will interpolate its values as mentioned above. The colorTableName field refers to the color table that VisIt will use within its pseudoplots as found within the /home/ USERNAME /.VisIt directory. The opacityType field corresponds to where VisIt will pull the opacity value mapping within the modeling process. Generally speaking, the minFlag, maxFlag, opacityVarMinFlag, opacityVarMaxFlag fields should be set to False; however it can also provide useful information during the visualization development process.","title":"Density"},{"location":"Section5/#isosurface","text":"During the isosurface rendering process, there are different considerations one needs to take into account. The following is an example of an XML that controls the configuration surrounding the isosurface rendering operator: 1 <?xml version=\"1.0\"?> 2 <Object name=\"IsosurfaceAttributes\"> 3 <Field name=\"contourNLevels\" type=\"int\">21</Field> 4 <Field name=\"contourValue\" type=\"doubleVector\">-2.6 5 -2.5 -2.4 -2.3 -2.2 -2.1 -2.0 -1.9 -1.8 -1.7 -1.6 -1.5 6 -1.4 -1.3 -1.2 -1.1 -1.0 -0.9 -0.8 -0.7 -0.6</Field> 7 <Field name=\"contourPercent\" type=\"doubleVector\">0.1</Field> 8 <Field name=\"contourMethod\" type=\"string\">Value</Field> 9 <Field name=\"variable\" type=\"string\">logrho</Field> 10 ... iso.xml The first field parameter to note in this xml file is the contourMethod field. Essentially building off the concepts discussed within Sec. 4.2.2, this field parameter lets VisIt know what method it should use when calculating the contour shells within the model\u2019s visualization. There are two methods that VisIt uses in order to generate the shells or the levels within the visualization: Percentage and Value. With the Percentage parameter, VisIt will interpolate the different contour levels by dividing the range between the minimum/maximum density by either a percentage set by the user or interpolation. Alternatively, the Value parameter will allow the user to set which specific values within data to create contour shells as seen within the contourValue field, giving the user more control over their model. Generally speaking, the greater the quantity of shells within a visualization, the higher the quality of the image, so be sure to assess the computational capabilities at hand when creating these figures. Visualizations in numerical relativity are usually created on high performance computing systems due to the volume of data and computational intensity of the tasks. Experimenting to understand the limits of the high performance computing systems is vital to the efficiency in the visualization tasks. Knowing exactly how long a visualization might take to complete as well as the resources used within the visualization process is especially important to the visualization process. We lay out the VisIt-CLI code for creating and loading up isosurface and pseudocolor attribute files shown within the following python script: 1 from visit import * 2 3 # plotting density data with isosurface rendering 4 5 6 #adding the pseudocolorplot 7 # loading the density data into visit 8 densityplot = ActivateDatabase(Path_to_Density_data) 9 10 #loading up the pseudocolorplot xml settings into the plot 11 #-> GUI equivilant to changing the Pseudocolor plot settings 12 #through the dropdown menu 13 LoadAttribute(Path_to_Pseudocolor_plot_xmlfile, densityplot) 14 15 # adding the pseudocolor plot 16 AddPlot(\"Pseudocolor\", \"density\") 17 SetActivePlots(plot_idxs.index(\"density\")) 18 #loading up plotting data 19 SetPlotOptions(densityplot) 20 21 # Adding the Isosurface operator 22 23 #loading in the isosurface operator 24 iso = IsosurfaceAttributes() 25 #adding isosurface operator settings 26 LoadAttribute(Path_to_iso_xml, iso) 27 #adding operator to plot 28 AddOperator(\"Isosurface\") 29 #making sure the plot has the operator xml settings 30 SetOperatorOptions(iso) Code Listing 5.2.1: plot_density_isosurface.py","title":"Isosurface"},{"location":"Section5/#volume","text":"Similar to the isosurface rendering plot, the volume rendering plot is also primarily controlled through the volume rendering xml settings in Sec. 4.2.1. The following is an example xml file that controls the volume rendering plot configurations: 1 <?xml version=\"1.0\"?> 2 <Object name=\"VolumeAttributes\"> 3 <Field name=\"legendFlag\" type=\"bool\">false</Field> 4 <Field name=\"lightingFlag\" type=\"bool\">false</Field> 5 <Field name=\"opacityAttenuation\" type=\"float\">1</Field> 6 <Field name=\"samplesPerRay\" type=\"int\">1000</Field> 7 <Object name=\"colorControlPoints\"> 8 <Object name=\"ColorControlPointList\"> 9 <Object name=\"ColorControlPoint\"> 10 <Field name=\"colors\" type=\"unsignedCharArray\" 11 length=\"4\"> 255 255 255 255 </Field> 12 <Field name=\"position\" type=\"float\">0</Field> 13 </Object> 14 ... iso.xml Breaking down the important attributes of this xml file, there are several important field parameters and considerations to make during the visualization development process. As mentioned previously, the colorControlPointList field parameter controls the pseudocolor plot within the volume rendering plot, delineating the different density values across the plot. The samplesPerRay parameter controls the overall quality of the image, as the smoothness and resolution of the plot is proportional to the magnitude of this field parameter. However, it should be duly noted that volume rendering is a computationally taxing operation to conduct, with this process being nearly ten times more resource intensive than isosurface rendering. Therefore, the operation becomes exponentially more computationally intensive with a higher magnitude of samplesPerRay, so be weary of the capabilities of the high performance computing systems when developing these visualizations. Adjusting the opacityAttenuation will also influence the overall transparency of the disk at the cost of computational intensity within the visualization. Generally speaking, it may be useful to adjust the colorbar and viewing angle through different rendering techniques before experimenting with the volume renderings in order to understand how different iterations of the visualization may appear. We use the volume attributes as shown in the volume rendering section. 1 from visit import * 2 3 4 # volume rendering in VisIT 5 6 #loading in the density data into VisIT 7 ActivateDatabase(path_to_density_data) 8 #creating an instance where we could set the volume attributes 9 density_atts = VolumeAttributes() 10 #loading in our xml settings for the density attributes 11 LoadAttribute(path_to_volume_xml_file, density_atts) 12 #creating a volume plot with the logrho variable 13 AddPlot(\"Volume\", \"logrho\") 14 SetActivePlots(plot_idxs.index(\"density\")) 15 #making sure the volume plot has the proper settings 16 SetPlotOptions(rho_atts) Code Listing 5.2.2: plot_density_volume.py","title":"Volume"},{"location":"Section5/#magnetic-field-lines","text":"Streamlines (or integral curves) are the plots that we use to visualize the magnetic field in GRMHD simulation data. This is because the IntegralCurve plot allows you to specify the exact locations of the seed points from which VisIt will integrate. The general information pertaining to the IntegralCurve plot, such as the important attributes, can be found in section 4.2.4. This section will instead focus on how to choose seed points to create magnetic field lines that reveal important physics in the simulation data. The Illinois GRMHD code outputs the magnetic field data as three HDF5 scalar fields Bx, By, Bz. To combine these into a vector field in VisIt, follow the directions in section 4.3. Similarly, the process of drawing field lines is the same as specified in section 4.2.4. We use two methods to draw magnetic field lines: particle seeds and grid seeds.","title":"Magnetic Field Lines"},{"location":"Section5/#particle-seeds","text":"In GRMHD magnetic field lines are attached to particles of matter (i.e. the field lines are \u201dfrozen in\u201d to the matter particles). Whenever a particle of matter moves, then the magnetic field line should move with it. For example, the magnetic field lines in a magnetized rotating neutron star would rotate with the star. The Illinois GRMHD code keeps track of the x, y, and z positions of a selected group of n fluid particles (n is usually chosen to be between 1000 and 10, 000) at every iteration: {(xi(t), yi(t), zi(t))}n i=1. These locations are tracked by integrating an initial set of particles {(xi(0), yi(0), zi(0))}n i=1 along the fluid velocity field. In order to visualize a magnetic field line that follows the motion of the fluid\u2014as it should\u2014we use the locations of particles as seed points for our magnetic field lines. The simulation outputs the positions of n particles at all times {(xi(t), yi(t), zi(t))}n i=1 so we have a large option of particles to choose from. In practice, we don\u2019t draw field lines with all n particles, but instead choose a subset of m particles to follow (usually m < 100 but it depends on the system) These m particles are chosen so that the magnetic field lines drawn at the initial time t = 0 using the seeds {(xik (0), yik (0), zik (0))}m k=1 represent the physics that we want to probe on. Then the positions of these m particles are used to seed the magnetic field lines in all subsequent frames t \u2265 0. As a result, the magnetic field lines drawn follow the flow of the matter. Fig. 41 shows a binary neutron star simulation with magnetic field lines at two times t/M=5 and t/M=696. At t/M=5, which is close to the initial time t/M=0, the magnetic field lines look dipole like and showcase the magnetic field present in the binary system. Then at t/M=696, notice how the magnetic field lines are still seeded from within the two neutron stars. If we don\u2019t use particle seeds to seed magnetic field lines here, then the visualized magnetic fields wouldn\u2019t follow the neutron stars as they inspiral. Figure 41: Particle seeded field lines in binary neutron stars The process of choosing which particles to follow\u2014as mentioned earlier\u2014comes down to choosing which particles at t = 0 create a visualization that best showcases the physics of the system. The initial magnetic fields in numerical relativity simulations of merging neutron stars are commonly poloidal. Additionally, if the object that this magnetic field permeates has nonzero angular momentum, the angular momentum or spin axis usually is in alignment with the axis of the poloidal magnetic field. For this reason, we usually choose particles that form rings around this spin/magnetic-field axis. For example, each neutron star in the binary neutron star system of Fig. 41 initially has a poloidal magnetic field axis pointing in the vertical direction (\u00b1\u02c6z). Then we choose rings of points that lie in the xy-plane, which is orthogonal to the magnetic field axis. On the left panel of Fig. 41, the collection of smaller magnetic field line loops close to each neutron are created by a ring of points inside the neutron star with a larger radius. The field lines that extend further from the stars are created by a ring of points inside the neutron star with a smaller radius. Choosing the seed point rings that create nice visualizations still requires experimentation. Below in Code Lst. 5.3.1 (which can be found at VisIt-Guide/sec_5/seed_maker.py ), we provide a simple Python code that can draw these types of rings. There are options to choose where the rings are centered as well as the direction of the spin/magnetic-field axis. Below, we provide a summary of the different parameters of this script. centers : Center of the compact object This parameter is found in line 4 of seed_maker.py. It consists of a list of 3-tuples (each entry is a float) where each 3-tuple is the center of the compact object you want to place field lines around. pairs : Radius, height pairs that describe the ring This parameter is found in line 5 of seed_maker.py. It consists of a list of 2-tuples (each entry is a float). Each 2-tuple is of the form (radius, height). The radius specifies the radius of the ring and the height specifies the height of the ring with respect to the spin axis. spins : Axis that rings are orthogonal to This parameter is found in line 6 of seed_maker.py. It consists of a list of 3-tuples (each entry is a float) where each 3-tuple specifies the axis we want the ring of seed points to be orthogonal to. This axis usually coincides with the angular momentum axis (e.g. the spin axis of a black hole). num_seeds_per_ring: : Number of seeds per ring This parameter is found in line 7 of seed_maker.py. It consists of a list of integers that specify the number of seeds in each ring centers : Adjusts smoothness and resolution of plot As mentioned before, ray casting creates the plot by shooting rays and sampling the points in its path. By increasing the number of samples that are being cast through the data for each ray, we are able to improve the overall quality of the image. Having too few sample points along a ray gives rise to sampling artifacts such as rings or voids and decreases the overall \u201dsmoothness\u201d. However, sampling more points takes longer to render. We observe a 1:1 correlation between changes in image rendering time and the number of samples per ray. offsets : An angle to offset the seed placement This parameter is found in line 8 of seed_maker.py. It consists of a list of floats. These numbers specify an offset in the position of the individual points on the ring. Adding an offset of \u03c0 would rotate the points on the ring by 180\u25e6. reflectZ : Reflect seeds across equatorial plane Turning on this parameter reflects all the seeds across the equatorial plane. This equatorial plane is the plane orthogonal to the spin axis. 1 import numpy as np 2 3 # centers, pairs, spins, num_seeds_per_ring must have same length 4 centers = [(0., 0., 0.), (0., 0., 0.)] # list of 3-tuple centers (x, y, z) 5 pairs = [(3.0, 1.), (1., 1.)] # list of 2-tuple pairs(radius, height) 6 spins = [(0., 0., 1.), (0., 0., 1.)] # list of 3-tuple spins (Jx, Jy, Jz) 7 num_seeds_per_ring = [8, 8] # list of ints number of seeds per ring 8 offsets = [np.pi/8, np.pi/8] # offset in the angles of phi chosen 9 reflectZ = True 10 11 with open(\"seeds_0.txt\",\"w+\") as f: 12 f.write(\"{} {} {}\\n\".format(\"x\", \"y\", \"z\")) 13 for cen, pair, spin, num_steps, offset in zip(centers, pairs, spins, num_seeds_per_ring, offsets): 14 r, h = pair 15 spin_vec = np.array(spin); cen_vec = np.array(cen) 16 spin_vec /= np.linalg.norm(spin_vec) 17 u_vec = np.array([51., 50., 49.]) #random vector not parallel to spin 18 u_vec /= np.linalg.norm(u_vec) 19 #gram schmidt step 20 u_vec = u_vec - ( np.dot(u_vec, spin_vec) / np.dot(spin_vec, spin_vec ))*spin_vec 21 v_vec = np.cross(spin_vec, u_vec) 22 for phi in np.linspace(0 + offset, 2*np.pi + offset, num_steps, endpoint=False): 23 c = r*np.cos(phi); s = r*np.sin(phi) 24 p1 = cen_vec + c*u_vec + s*v_vec + h*spin_vec 25 f.write(\"{} {} {} {}\\n\".format(str(p1[0]), str(p1[1]), str(p1 [2]))) 26 if reflectZ: 27 p2 = cen_vec + c*u_vec + s*v_vec - h*spin_vec 28 f.write(\"{} {} {} {}\\n\".format(str(p2[0]), str(p2[1]), str (p2[2]))) Code Listing 5.3.1 seed maker.py Figure 42: Seed point rings orthogonal to spin Two rings of a specified radius are generated at a specified height above and below the plane orthogonal to the spin axis. As an example, in Fig. 42, four rings that lie on planes orthogonal to the spin vector of a tilted black hole are shown. Now we need to find which particle seeds among the total number of n seeds are closest to our chosen idealized seed points. This can be done by using a nearest-neighbor search using a K-D tree. In Python, you can load all the particles into scipy.spatial.KDTree and use the query method to return the nearest particle to an input point. After you choose the set of particles closest to your chosen seed points, you can use this set of particles to seed the magnetic field lines for the remainder of the simulation data.","title":"Particle Seeds"},{"location":"Section5/#grid-seeds","text":"While particle seeds are used to visualize the magnetic field in fluids such as neutron stars or accretion disks, we don\u2019t use them to visualize the magnetic field lines extending from the poles of black holes, since particles there are either captured or escape in jets. For black holes, we use grid points, which are just points we choose around the black hole that aren\u2019t attached to any fluid particles. To capture a potential jet, we choose points around black holes in a similar fashion to the way we choose idealized seed points. In particular, we want to draw two rings of seed points above and below the plane orthogonal to the spin axis of the black hole. Fig. 43 shows a spinning black hole surrounded by a gaseous accretion disk with twisted magnetic field lines seeded by a ring of points above the black hole. Throughout the evolution, make sure to have these rings of seed points follow the position and the spin of the black hole. When integrating these grid seeds that are around a black hole, make sure that the integrationDirection is not set to Both. We don\u2019t want the field lines to integrate into the black hole horizon. To do this, create a separate plot for the field lines above and below the black hole. For each of these plots, try setting the integrationDirection to different combinations of Forward and Backward so make sure the field lines integrate away from the horizon. Figure 43: Grid point seeded field lines above black hole Explicit examples and code that magnetic field lines seeded by particles and grid points can be found in the case studies later in the guide (Sec. 6, Sec. 7.3).","title":"Grid Seeds"},{"location":"Section5/#fluid-velocity-arrows","text":"We use the Vector plot (introduced in section 4.2.3) to visualize the fluid velocity vector field in GRMHD simulation data. We choose to use this plot rather than a streamline plot since it allows us to assess the behavior of the velocity field in areas of interest. For example, to determine if there is an incipient relativistic jet in a region that contains collimated magnetic fields, all of the velocities should be pointing in the direction of the jet. A vector plot allows us to populate the area of interest with many vectors pointing in the direction of the fluid velocity field. By looking at the behavior of these arrows, we can determine if the behavior of the fluid velocity fields matches our hypothesis. Like the magnetic field, the Illinois GRMHD code outputs the fluid velocity field data as three HDF5 scalar fields vx, vy, vz. By itself, the vector plot will place vectors of all magnitudes all over the grid. In numerical relativity, we are mostly interested in relativistic velocities in specific areas, as for example where a jet may form. We will use a combination of expressions and operators to plot the arrows we are interested in. These steps are often quite involved and require experimentation to get them right. For this reason, we usually only make vector plots of the fluid velocity at a handful of interesting times, rather than for a movie of the entire evolution. 1 #combining vx, vy, vz into vector expression 2 DefineVectorExpression(\"vVec_temp\",\"{vx,vy,vz}\") 3 4 #if magnitude(vVec_temp) > 0.5, use original data, 5 #else, set to {0,0,0} 6 DefineVectorExpression(\"vVec\",\"if(gt(magnitude(vVec_temp), \\ 7 0.5), vVec_temp, {0,0,0})\") 8 9 # below: only show arrows where the 10 #log(b^2/2*rho) plot is larger than -0.5 11 DefineVectorExpression(\"vVec\",\"if(gt(logbsq2r, -0.5), \\ 12 vVec_temp, {0,0,0})\") Code Listing 5.4: Restricting velocity plot After loading in the three scalar fields and combining them into a vector expression, new expressions can be created. For example, vectors can be filtered out based on their magnitude. On line 3 of the code listing above (Code Lst. 5.4), vectors with magnitudes less than 0.5c are set to zero so that only the relativistic velocities > 0.5c are shown. This number is arbitrary and can be changed to suit ones needs. Vectors can also be filtered out based on the values of other plots. For example, jets form in areas where the force-free parameter b2 /(2\u03c10 ) (see Sec. 7.4) is greater than some cutoff bigger than unity, so we might want to only plot vectors in these areas. On line \u2401 5, vectors in areas where log b2 /(2\u03c10 ) are less than \u22120.5 are set to zero. Note that to do this comparison, you will also need to load and define the logbsq2r scalar field. Note that in Code Lst. 5.4, we only choose to use one of the restrictions, so only one of lines 6 and 7 or 11 and 12 should be used. Figure 44: Restricting a vector plot of fluid velocity Figure 44: Restricting a vector plot of fluid velocity Once the vector data is loaded and filtered using expressions (if desired), selection operators can be added to the plot to restrict the plot to a physical region. On the GUI, these can be found in Operators \u2192 Selection. There are only a limited amount of options, but multiple selection operators can be applied if desired. The Box/Cylinder restricts the plot to the region inside (or outside if the Inverse option is selected) the shape. There is also a Clip operator, which can restrict the plot to inside or outside a sphere, or to one side of a plane. Below, there is an example of a vector plot of fluid velocity data from a GRMHD simulation before and after applying expressions and slicing operators (Fig. 44). Specifically, all vectors with magnitude less than 0.25c were set to zero and the plot was restricted to inside a cylinder that lies along the vertical axis. During this process of selecting different regions with selection operators, make sure you are also experimenting with the different vector attribute settings. Since GRMHD simulations commonly use finer grids in areas around compact objects, like black holes or neutron stars, the AdaptsToMeshResolution setting will place more arrows in the areas with a finer grid (as you can see in Fig. 44). So switching to UniformInSpace might give better results. If you find that different combinations of selection operators and vector settings don\u2019t give you a satisfactory visualization, another method is to create multiple vector plots using the same data. Then you can apply different operators and have different settings for different regions. Below is a visualization example that uses vector fluid velocity plots to visualize the relativistic jet following a binary black hole merger (Fig. 45). Explicit examples and code that visualize fluid velocity arrows can be found in the case studies later in the guide (see Sec. 7.4). In the following sections we will apply the knowledge we learned by walking through the steps taken to create visualizations from a select cases of GRMHD simulations done by the Illinois Relativity Group. Figure 45: Visualization with fluid velocity arrows","title":"Fluid Velocity Arrows"},{"location":"Section6/","text":"MathJax = { tex: { inlineMath: [['$', '$'], ['\\\\(', '\\\\)']] } }; Case Study: Magnetars The first case study will be of a highly magnetized rotating neutron star, called a magnetar. These magnetars correspond to the simulations discussed in [9, 10] and describe the first magnetohydro- dynamic simulations in full general relativity of self-consistent rotating neutron stars (NSs) with ultrastrong mixed poloidal and toroidal magnetic fields. The visualizations of magnetars will use the following simulation output databases: rho_b.file_*.h5: HDF5 data of the fluid rest-mass density $\\rho_0$ Bx.file *.h5, By.file *.h5, Bz.file *.h5: HDF5 data of the magnetic field particles.mon: ASCII file containing the locations of a number of fluid particles Using these databases, we will make the following plots: Isosurface of Volume plot of log$\\left(\\frac{\\rho_0}{\\rho_0(0)}\\right)$, which will visualize the rotating neutron star (purple in Fig. 49). Here, we normalize by \u03c10 (0) which is the maximum density at $t = 0$ Integral curve plot of the poloidal field lines seeded by particles. Integral curve plot of the toroidal field lines seeded by particles. Creating an isosurface plot of the density follows the same procedure as in section 5.2. Other case studies will go more in-depth into density plotting as well. In this case study, we will focus on the plotting of magnetic field lines which is more complicated than in a typical dipole-like configuration, due to the simultaneous existence of poloidal and toroidal magnetic fields. Creating 2D slice plots of the density and magnetic fields, will make the process of finding points to seed the magnetic field lines easier, since it allows us to gauge the size of the system and the nature of the magnetic fields. The fact that the configuration is axisymmetric allows to choose any meridional slice that intersects the origin. We select the z-x plane. The other slice lies in the x-y plane(the equator). For example, in Fig. 46, we see that the toroidal portion of the magnetic field is strongest near the outer edge of the star (black field lines), thus when choosing where we want to place seed points for the toroidal field lines, we should choose seed points at the outer edge of the star and close to the equatorial plane z = 0. Likewise, we can see that the poloidal portion of the magnetic field is strongest near the center of the star, thus we should pick seed points close to the center for the poloidal field lines. Here, it is important to pick seed points inside the neutron star, since the next step would be to find the particle seeds closest to the chosen seed points. The grid is finer inside the neutron star, so choosing particles inside the neutron star will give us more accurate results. Without 2D slice plots this experimentation process for finding seed points will just take longer. However, we should have a general sense of the size of the system and how the magnetic field behaves. This is especially true when we have mixed poloidal and toroidal magnetic fields. Overall the process of finding proper seed points for magnetic field lines involves starting from an educated guess based on some information about the system, followed by lots of experimentation and fine-tuning of the seed points and the integral curve settings. Below, we provide some examples of some steps taken before creating a final image. Figure 46: 2D slices of a magnetar. Adapted from [9]. Poloidal Field Lines We will start by finding good seed points for the poloidal field lines. We pick rings of seed points near the center of the star since that is where the poloidal magnetic field is the strongest. To do this, we use seed maker.py (Code Lst. 5.3.1) with centers = [(0., 0., 0.), (0., 0., 0.)], pairs = [(2.5, 1.), (1., 1.)], spins = [(0., 0., 1.), (0., 0., 1.)], num_seeds_per_ring = [8,8], and offsets = [0., 0.] to generate the seed points. Note that the center of the neutron star is at the origin and its angular momentum is in the +z direction. We start with rings of radii 2.5 and 1, which are close to the center of the neutron star whose radius is 8.3. For the integral curve settings, we started by using the $integrationType=RK4$ integrator with $maxSteps=50000$ and $maxStepLength=100.$ These seed points and settings give us the image on the left side of Fig. 47. There are a few issues that we hope to fix with this image. First, the field lines are looping around too many times to the point where they look like ribbons (see Fig 47(a)). Ideally, we would want the field lines to integrate in a loop once. To fix this issue, we want to decrease the length of the field lines, which can be done by decreasing the number of steps by changing $maxSteps$ and by decreasing the step size by changing $maxStepLength.$ We decreased the number of steps from 50000 to 2000 and decreased the step size from 100 to 10. Sometimes, the opposite problem can happen, where the field lines are too short and need to be integrated further. This happens either when the field line integrates into a critical point of the magnetic field, or when it has already integrated $maxSteps$. In the former case, VisIt will output error messages to let you know. The best way to circumvent this issue is to increase the $maxStepLength$ or to use a different integrator. In the latter case, we can simply increase $maxSteps.$ Additionally, we would like to have the field lines generated by the ring of seed points with the larger radius to form closed loops that are smaller, thus we will increase the radius of that ring of points from 2.5 to 3. The changes we made above were the result of multiple different trials where each tested a different setting. We want to stress that the key to this process is experimentation. At first, we should get familiar with how each setting affects the plot by changing only one setting at a time. However, with more experience, we will develop more intuition regarding different settings. The changes we\u2019ve made, give us the image on the right side of Fig. 47(b). modify two figures here Figure 47: Poloidal field lines with different settings. Toroidal Field Lines Since toroidal field lines integrate around the entire star (i.e. will cover all angles of \u03d5), instead of forming closed loops that don\u2019t intersect, we will not be using as many points in our rings as in the poloidal case. We will create two rings with radii close to the outer edge of the star and a height of zero. The settings in seed maker.py are centers = [(0., 0., 0.), (0., 0., 0.)], pairs = [(5., 0.), (5.5, 0.)], spins = [(0., 0., 1.), (0., 0., 1.)], num_seeds_per_ring = [3,3], and offsets = [0., 0.] with reflectZ = False since we are picking a height of zero. For the integral curve settings, we will start with the integrationType=RK4, maxSteps=500, and maxStepLength=10. These seed points and settings give us the image in Fig. 48(a). This image looks quite nice already since we are using almost the same integration settings we found for the poloidal field lines. However, the coils of field lines don\u2019t integrate all the way around the star. To address this, we increase the number of steps from 500 to 5000. The changes we\u2019ve made give us the image on the right side of Fig. 48. (a) Before changes (b) After changes Figure 48: Toroidal field lines with various settings. Final Image and Summary Figure 49: A magnetar with mixed poloidal and toroidal field lines. Combining the poloidal and toroidal field lines we\u2019ve created we get the final image in Fig. 49. In this section, we discussed the steps taken to draw magnetic field lines with mixed poloidal and toroidal magnetic fields. The first step is to get a general understanding of the nature of the system and its magnetic fields. In this example, we knew from the 2D slice plots that the poloidal portion of the magnetic field was the strongest at the center of the star and that the toroidal portion was strongest near the outer edge of the star Using this information, we used picked points in the center (outer edge) of the star to seed poloidal (toroidal) magnetic field lines. To create an initial image, we used some arbitrary integral curve settings to serve as a default. After drawing the image using the first round of settings, we noticed what we need to tweak the seed points and integral curve for a better result. This step is usually carried out multiple times before we have an image that we are satisfied with. Some of the settings that are commonly changed/tuned to achieve a nice final image are listed below. num seeds per ring : Number of loops For the poloidal field lines Fig. 47, more seeds in a ring will increase the number of loops distributed across the \u03d5 angle. For toroidal field lines Fig. 48, it will increase the number of field line \u201ccoils\u201d, since every seed integrated long enough will produce a full \u201ccoil\u201d. (radius, height) pairs : Choosing which magnetic field portion to visualize Ideally, we\u2019ll have 2D slice plots so we can choose which portions of the magnetic field to visualize with our field lines. For less complicated purely poloidal magnetic fields, smaller radii create the largest rings while larger radii (up until the radius where the magnetic field switches directions) create smaller rings. maxStepLength and integrationType : Avoiding critical points in the magnetic field If our field lines are integrating into critical points, then they will terminate. To troubleshoot this issue, we can increase the maximum step length to integrate across these problem areas. We can also try different integrators (e.g. RK4, Leapfrog, DormandPrince). maxSteps and maxStepLength: : Create closed rings If our field lines are not integrating into critical points, then we can increase the number of steps or the step length so that they integrate into closed loops. Note that it is also possible to over-integrate. Since the magnetic field has a toroidal component, subsequent loops will increase the \u2018thickness\u2019 of the ring. Finally, to create visualizations at times after the initial time, we can use the same integration settings as we use at the initial time. For the seed points, like described earlier, we choose the nearest particles to each of our seed points, and use these particles as to seed the magnetic field lines at all subsequent times.","title":"Magnetars"},{"location":"Section6/#case-study-magnetars","text":"The first case study will be of a highly magnetized rotating neutron star, called a magnetar. These magnetars correspond to the simulations discussed in [9, 10] and describe the first magnetohydro- dynamic simulations in full general relativity of self-consistent rotating neutron stars (NSs) with ultrastrong mixed poloidal and toroidal magnetic fields. The visualizations of magnetars will use the following simulation output databases: rho_b.file_*.h5: HDF5 data of the fluid rest-mass density $\\rho_0$ Bx.file *.h5, By.file *.h5, Bz.file *.h5: HDF5 data of the magnetic field particles.mon: ASCII file containing the locations of a number of fluid particles Using these databases, we will make the following plots: Isosurface of Volume plot of log$\\left(\\frac{\\rho_0}{\\rho_0(0)}\\right)$, which will visualize the rotating neutron star (purple in Fig. 49). Here, we normalize by \u03c10 (0) which is the maximum density at $t = 0$ Integral curve plot of the poloidal field lines seeded by particles. Integral curve plot of the toroidal field lines seeded by particles. Creating an isosurface plot of the density follows the same procedure as in section 5.2. Other case studies will go more in-depth into density plotting as well. In this case study, we will focus on the plotting of magnetic field lines which is more complicated than in a typical dipole-like configuration, due to the simultaneous existence of poloidal and toroidal magnetic fields. Creating 2D slice plots of the density and magnetic fields, will make the process of finding points to seed the magnetic field lines easier, since it allows us to gauge the size of the system and the nature of the magnetic fields. The fact that the configuration is axisymmetric allows to choose any meridional slice that intersects the origin. We select the z-x plane. The other slice lies in the x-y plane(the equator). For example, in Fig. 46, we see that the toroidal portion of the magnetic field is strongest near the outer edge of the star (black field lines), thus when choosing where we want to place seed points for the toroidal field lines, we should choose seed points at the outer edge of the star and close to the equatorial plane z = 0. Likewise, we can see that the poloidal portion of the magnetic field is strongest near the center of the star, thus we should pick seed points close to the center for the poloidal field lines. Here, it is important to pick seed points inside the neutron star, since the next step would be to find the particle seeds closest to the chosen seed points. The grid is finer inside the neutron star, so choosing particles inside the neutron star will give us more accurate results. Without 2D slice plots this experimentation process for finding seed points will just take longer. However, we should have a general sense of the size of the system and how the magnetic field behaves. This is especially true when we have mixed poloidal and toroidal magnetic fields. Overall the process of finding proper seed points for magnetic field lines involves starting from an educated guess based on some information about the system, followed by lots of experimentation and fine-tuning of the seed points and the integral curve settings. Below, we provide some examples of some steps taken before creating a final image. Figure 46: 2D slices of a magnetar. Adapted from [9].","title":"Case Study: Magnetars"},{"location":"Section6/#poloidal-field-lines","text":"We will start by finding good seed points for the poloidal field lines. We pick rings of seed points near the center of the star since that is where the poloidal magnetic field is the strongest. To do this, we use seed maker.py (Code Lst. 5.3.1) with centers = [(0., 0., 0.), (0., 0., 0.)], pairs = [(2.5, 1.), (1., 1.)], spins = [(0., 0., 1.), (0., 0., 1.)], num_seeds_per_ring = [8,8], and offsets = [0., 0.] to generate the seed points. Note that the center of the neutron star is at the origin and its angular momentum is in the +z direction. We start with rings of radii 2.5 and 1, which are close to the center of the neutron star whose radius is 8.3. For the integral curve settings, we started by using the $integrationType=RK4$ integrator with $maxSteps=50000$ and $maxStepLength=100.$ These seed points and settings give us the image on the left side of Fig. 47. There are a few issues that we hope to fix with this image. First, the field lines are looping around too many times to the point where they look like ribbons (see Fig 47(a)). Ideally, we would want the field lines to integrate in a loop once. To fix this issue, we want to decrease the length of the field lines, which can be done by decreasing the number of steps by changing $maxSteps$ and by decreasing the step size by changing $maxStepLength.$ We decreased the number of steps from 50000 to 2000 and decreased the step size from 100 to 10. Sometimes, the opposite problem can happen, where the field lines are too short and need to be integrated further. This happens either when the field line integrates into a critical point of the magnetic field, or when it has already integrated $maxSteps$. In the former case, VisIt will output error messages to let you know. The best way to circumvent this issue is to increase the $maxStepLength$ or to use a different integrator. In the latter case, we can simply increase $maxSteps.$ Additionally, we would like to have the field lines generated by the ring of seed points with the larger radius to form closed loops that are smaller, thus we will increase the radius of that ring of points from 2.5 to 3. The changes we made above were the result of multiple different trials where each tested a different setting. We want to stress that the key to this process is experimentation. At first, we should get familiar with how each setting affects the plot by changing only one setting at a time. However, with more experience, we will develop more intuition regarding different settings. The changes we\u2019ve made, give us the image on the right side of Fig. 47(b). modify two figures here Figure 47: Poloidal field lines with different settings.","title":"Poloidal Field Lines"},{"location":"Section6/#toroidal-field-lines","text":"Since toroidal field lines integrate around the entire star (i.e. will cover all angles of \u03d5), instead of forming closed loops that don\u2019t intersect, we will not be using as many points in our rings as in the poloidal case. We will create two rings with radii close to the outer edge of the star and a height of zero. The settings in seed maker.py are centers = [(0., 0., 0.), (0., 0., 0.)], pairs = [(5., 0.), (5.5, 0.)], spins = [(0., 0., 1.), (0., 0., 1.)], num_seeds_per_ring = [3,3], and offsets = [0., 0.] with reflectZ = False since we are picking a height of zero. For the integral curve settings, we will start with the integrationType=RK4, maxSteps=500, and maxStepLength=10. These seed points and settings give us the image in Fig. 48(a). This image looks quite nice already since we are using almost the same integration settings we found for the poloidal field lines. However, the coils of field lines don\u2019t integrate all the way around the star. To address this, we increase the number of steps from 500 to 5000. The changes we\u2019ve made give us the image on the right side of Fig. 48. (a) Before changes (b) After changes Figure 48: Toroidal field lines with various settings.","title":"Toroidal Field Lines"},{"location":"Section6/#final-image-and-summary","text":"Figure 49: A magnetar with mixed poloidal and toroidal field lines. Combining the poloidal and toroidal field lines we\u2019ve created we get the final image in Fig. 49. In this section, we discussed the steps taken to draw magnetic field lines with mixed poloidal and toroidal magnetic fields. The first step is to get a general understanding of the nature of the system and its magnetic fields. In this example, we knew from the 2D slice plots that the poloidal portion of the magnetic field was the strongest at the center of the star and that the toroidal portion was strongest near the outer edge of the star Using this information, we used picked points in the center (outer edge) of the star to seed poloidal (toroidal) magnetic field lines. To create an initial image, we used some arbitrary integral curve settings to serve as a default. After drawing the image using the first round of settings, we noticed what we need to tweak the seed points and integral curve for a better result. This step is usually carried out multiple times before we have an image that we are satisfied with. Some of the settings that are commonly changed/tuned to achieve a nice final image are listed below. num seeds per ring : Number of loops For the poloidal field lines Fig. 47, more seeds in a ring will increase the number of loops distributed across the \u03d5 angle. For toroidal field lines Fig. 48, it will increase the number of field line \u201ccoils\u201d, since every seed integrated long enough will produce a full \u201ccoil\u201d. (radius, height) pairs : Choosing which magnetic field portion to visualize Ideally, we\u2019ll have 2D slice plots so we can choose which portions of the magnetic field to visualize with our field lines. For less complicated purely poloidal magnetic fields, smaller radii create the largest rings while larger radii (up until the radius where the magnetic field switches directions) create smaller rings. maxStepLength and integrationType : Avoiding critical points in the magnetic field If our field lines are integrating into critical points, then they will terminate. To troubleshoot this issue, we can increase the maximum step length to integrate across these problem areas. We can also try different integrators (e.g. RK4, Leapfrog, DormandPrince). maxSteps and maxStepLength: : Create closed rings If our field lines are not integrating into critical points, then we can increase the number of steps or the step length so that they integrate into closed loops. Note that it is also possible to over-integrate. Since the magnetic field has a toroidal component, subsequent loops will increase the \u2018thickness\u2019 of the ring. Finally, to create visualizations at times after the initial time, we can use the same integration settings as we use at the initial time. For the seed points, like described earlier, we choose the nearest particles to each of our seed points, and use these particles as to seed the magnetic field lines at all subsequent times.","title":"Final Image and Summary"},{"location":"Section7/","text":"Case Study: Black Hole with Accretion Disk The second case study will be of a black hole surrounded by an accretion disk, which we will refer to in this section as a BH-disk (BHD). BHDs can be found in active galactic nuclei or in the aftermath of binary neutron star mergers. The BHD data we will use in this section will be of a rapidly spinning black hole surrounded by a self-gravitating accretion disk where the spin of the BH is tilted with respect to the angular momentum of the disk. The accretion disk is seeded with a poloidal magnetic field. As matter accretes onto the BH, a relativistic jet develops. Visualizations of the BHD use the following simulation output databases: rho_b.file_*.h5: HDF5 data of the fluid rest-mass density $\\rho_0$ Bx.file *.h5, By.file *.h5, Bz.file *.h5: HDF5 data of the magnetic field vx.file *.h5, vy.file *.h5, vz.file *.h5: HDF5 data of the fluid velocity smallb2.file *.h5: HDF5 data of b2 \u2261 B2/(4\u03c0) where B is the magnitude of the magnetic field. h.t*.ah1.gp: Horizon data that lists a set of points on the apparent horizon of the black hole. BH diagnostics.ah1.gp: ASCII black hole diagnostic file containing information about the apparent horizon of the black hole. BHspin.mon: ASCII file containing the black hole spin vector at each iteration In this case study, we will focus on visualizations of the density, which was glossed over when we made visualizations of the magnetars in Sec. 6. We will go over in detail how to find good settings for visualizing the density using both isosurface and volume rendering techniques. Isosurface Rendering of Disk Using the databases mentioned above, we will make the following plots. Isosurface of Volume plot of log$\\left(\\frac{\\rho_0}{\\rho_0(0)}\\right)$, which will visualize the accretion disk. Pseudocolor plot of the apparent horizon of the black hole. Vector plot of the black hole spin. This section focuses on designing the BHD visualizations seen within in Figs. 50 and 51. There were a number of different visualization parameter decisions with their respective trade-offs made within this figures. To begin with, we created these visualizations using isosurface rendering as described in Sec. 4.2.2, utilizing layers of shells to model the different density values. Volume rendering is a more computational intensive operation in comparison to isosurface rendering, and isosurface rendering allows for a lot more flexibility when iterating through the visualization development process. The salient features for isosurface and volume rendering have been discussed in Sec. 4.2.2 and Sec. 4.2.1. Here we will discuss specific details regarding the visualization of BHDs using isosurface rendering. Figure 50: Isosurface zoom in of a massive BHD. At t = 0 the angular momentum of the disk is along the z axis, while the spin of the black hole (yellow arrow) is at 45\u25e6 from the z axis. Figure 51: Isosurface zoom out of the massive BHD of Fig. 50 Starting with the shells, the number amount of them and their distribution across the data play a vital role in what information is highlighted within the visualization. Within this simulation, there is significant variation in the fluid density within the inner torus of the BHD. Through experimentation, we found that there was quite a bit of fluid movement and variation for the fluid density values between -1 to -2 (log scale), therefore adding more shells within this region, can better communicate the fluid dynamics across the evolution. In the same light, the following parameters are different characteristics to be considered in order to maximize the information communicated: min and max : Disk size: Since we normalize our colorbar with the nital maximum density and take the logarithm of the resulting ratio, 0 reflects the maximum density value of the disk (typically found close to the disk). For the lower bound, we are typically interested in density values that are of the order 3 or 4 decades smaller than the maximum density. The magnitude of the minimum colorbar density is directly correlated to the size of the disk being visualized. This parameter can be adjusted within the isosurface and colorbar XML file as mentioned in Sec. 5.2.1 contourNLevels : Resolution of visualization Having more shells leads to sharper images, since we are able to capture more densities but the trade off is disk opacity. The more shells we have, the harder it is to keep the disk transparent and track all of the layers in one image. Fortunately, we found that the solution to this problem is to experiment with lighter colors and different opacity gradients as controlled within the colorbar, which we will review in later sections. contourValue : Disk smoothness As previously mentioned, there are usually specific regions of density that are more interesting and have more information to communicate than others, so focusing on creating more shells within this region of the data can be crucial to creating high quality visualizations. Unfortunately, there is no magic formula to figure out exactly what those regions of interest might be without iterating through different models and experimenting to see what shell configurations work best. imageZoom and viewNormal: : Perspective of disk The camera angle of the disk itself is crucial to what the visualization focuses on, as discussed within Sec. 4.5. Different levels of zoom and angles of the disk influence which information is largely communicated by the visualization, so experimenting on this end to figure out which perspective from the camera angle lends itself to a better visualization is something to consider when creating high quality visualizations. When modeling the visualization, it can be useful to think about what information should be communicated through the visualization, and let that guide the visualization process. For instance, Fig. 51 communicates the fluid dynamics of the outer torus and the overall disk across the evolution, whereas Fig. 50 communicates information regarding the fluid dynamics of the inner torus. Custom colorbars can be created and stored within the \u223c/.visit directory. As mentioned before hand in Sec. 5.2, the colorbar is created through an xml based file with the .ct file extension. Utilizing this feature, we create our own colorbars in order to bring more depth to the visualization and highlight different attributes, as seen within the template colorbar attached within the github. The following considerations were made when creating the colorbar: ColorControlPoint : Clarity of visualization: Within this case, since there are 21 shells across the BHD, VisIt will interpolate the correspond\ufffeing values within the colorbar and assign the color to the density value. As more shells are created within the visualization, it becomes increasingly more important to consider how the colorbar is structured in order to best communicate information within the visualization. After experimenting with different color schemes, it was found that darker colors with a limited color spectrum failed to highlight the different density shells. Although the visualization showed the overall variation in density, the minute details on how different layers of the structure change throughout the evolution was lost to the viewer. Incorporating a lighter color and opacity gradient across the pseudo-color plot allowed for more of the internal structures of the BHD to be displayed, allowing the communication of low-level information about the composition of the system. ColorControlPointList : Dynamics of density value : The spectrum of colors within the visualization should also be proportional to the magnitude of different colors packed within the colorbar. With a large number of shells being added to the visualization, there will be a lot more information that could be communicated to the viewer to show the dynamics of the torus throughout the evolution. ColorControlPoint : Distribution of density values : As mentioned beforehand, we can set distinct colors across the colorbar and VisIt will automatically interpolate between the different values in order to generate the colorbar. From here, VisIt will assign different color values to the corresponding shells within the isosurface rendering process. Leveraging this fact, it is important to be cognizant of what pockets of density values might be more important than others, so that more variation of colors are created in that region. In general, creating more color points can create more control over the smoothness between the difference colors across the colorbar. In order to better understand the thought process behind these choice s, we can take a look at some of the iterations through the visualization process. To begin, we first visualized the black hole with a limited color table (Fig. 52), from dark red to orange, that did not show the details in the shell variation as shown in Fig. 50. Figure 52: Black hole-disk visualization using a limited color table. Using this colorbar, the different shells within the disk around the black hole seem to merge together and are very difficult to distinguish. In order to better bring out the density distribution, we incorporate in Fig. 53 a wider spectrum of lighter colors with a corresponding opacity gradient that allowed for lighter densities to have more transparency in order to better highlight the internal structures of the jets and variation of densities. Figure 53: Black hole-disk visualization with improved color table. Volume Rendering of Disk In this section, we will make volume rendering of the same BHD data used in Sec. 7.1. Fig. 56 is created using volume rendering by utilizing ray tracing modeling techniques in order to create high-quality 3-D renderings of the density values across the BHD. Being the more computationally demanding rendering operation, the volume rendering visualization technique brings out a different texture throughout the density plotting, as it allows the visualizations to have a degree of transparency, definition, and quality that cannot be duplicated using isosurface rendering. To start off, we begin the visualization process by iterating through different view settings of the BHD through computationally less intensive rendering processes like isosurface rendering for instance. After making sure we have set up the proper angles for the model, we can switch over to the ray casting volume rendering modeling for the BHD. In terms of the ray casting, there are three important parameters that play a critical role in the nature of the visualization and the information highlighted within the visualization. Building on the information on the last section, our goal within this visualization would be to highlight the fluctuation of the fluid density values across the evolution in a visually appealing manner. In this light, the following parameters are different characteristics to be considered to in order to maximize the information communicated: colorControlPoints : Visual clarity : Within the volume rendering plot, the colorbar can be controlled primarily through the volume rendering file with the colorControlPointList parameter. Functioning similar to the pseudo-color plot XML file, the colorbar will take a set of RBGA color values associated with a density data distribution percentage. As mentioned above, the general scheme that we follow for generating a colorbar would be to create a diverse spectrum of light colors, as that will illuminate the variation of density across the BHD throughout the evolution with the most clarity and visual appeal. freeformOpacity : Model opacity profile : The volume rendering plot can be greatly influenced by the specific opacity profiles set within the visualization, as different opacity parameters will communicate different levels of information to the viewer. As mentioned in Sec. 4.2.1, the freeformOpacity parameter is crucial to the opacity profile of the visualization, influencing which density values have what level of opacity, as well as the overall disk opacity. By adjusting the different values of the freeformOpacity 256 array, different aspects of the colorbar and the model will be shown within the resultant visualization. Often on a case by case decision based on what aspect of the visualization we want to focus on, such as the BHD or different magnetic field lines, these parameters can be adjusted to perfect the visualization. samplesPerRay : Resolution and smoothness of plot : The volume rendering ray casting method visualizes the disks with striking detail and clarity by casting out a set number of rays from the camera onto the model and sampling the different density value points within the visualization. With a higher magnitude of sample points per ray, the visualization will have a higher resolution but will take more time for the visualization to render. Depending on the time frame and the computational capacity available to visualize the model, the samplesPerRay can be adjusted accordingly view.xml : Model framing : The camera angle of the visualization is critical to the visualization, as it not only controls the information communicated to the viewer, but also largely influences how the sample rays might interact with the density data to create the visualization. The camera angle is controlled through an xml file as seen within Fig. 38. Experimenting with the viewing normal angle, as well as the zoom of the camera, can showcase different aspects of the model during its evolution. Figure 54: Base image of the BHD through volume rendering In order to better understand the volume rendering process, we will visualize the BHD as seen in 7.1 through volume rendering. To begin, we can set the viewing angle of the visualization and create a base image to iterate our visualization. For more information on how to create a volume rendering image, please refer to our previous section on volume rendering in Sec. 4.2.1. Figure 55: Distribution of freeformOpacity values Although we can make out the shape of the disk, we need to experiment with the settings to make the visualization better. For instance, in Fig. 54, the entire BHD seems to be completely red even though there is a vibrant colorbar used in the model. In order to improve this behavior, we first look at the volume XML file used by VisIt that controls the hyper-parameters associated with this visualization. From here, we can see how the freeformOpacity of the visualization was structured. As seen within the top left corner of the visualization beside the colorbar, there seems to be a large bias towards the red region of the visualization with very little opacity across the rest of the colorbar. Modifying towards a wider distribution of the freeformOpacity values, in order to better depict the entire colorbar across the BHD, we created the final visualization as seen in Fig 56. Figure 56: Final image of the BHD with volume rendering Magnetic Field Lines around the Black Hole In addition to the plots mentioned in Sec. 7.2 we will also make an Integral curve plot of the magnetic field seeded by grid seeds around the black hole. Since we are interested in capturing the magnetic field around the black hole, we will be using grid seeds that are placed above and below the poles of the black hole as described in Sec. 5.3.2. Since we are using grid seeds, we are not visualizing individual magnetic field lines tied to particles and tracking how they change. Rather, we are visualizing the shape of the magnetic field around the black hole. See Fig. 43 for an example of magnetic field lines seeded by grid seeds in a BHD. In our BHD initial data, the magnetic field exists only inside the accretion disk. Thus, the vacuum in between the black hole and the disk contains no magnetic field. For this reason, integrating grid seeds placed around the black hole before sufficient accretion has taken place will not draw field lines, since the magnetic field will be zero in those regions. As the evolution proceeds and matter is accreted from the disk onto the black hole, the magnetic field lines seeded around the black hole will start to develop. Differential rotation of the matter due to frame-dragging causes the magnetic field to wind up and form a helical structure above the poles. Since our aim is to best capture these helical magnetic field lines above the black hole, we choose a late time after sufficient accretion has taken place to use for magnetic field line experimentation. To generate the grid seeds, we will use seed maker.py (Code Lst. 5.3.1). For grid seeds around a black hole, it is helpful to define the (radius, height) pairs in terms of the average radius r bh of the black hole horizon. Unless the mass of a black hole changes drastically (for example in a binary black hole merger), it is okay to find r bh at a fixed time and use that value for the entire remaining evolution. To find the value of r bh, we can use the h.t .ah1.gp horizon data which contains a list of points {(xi, yi, zi)} N i=1 on the apparent horizon. Find the average of these points (which is just the arithmetic mean (x, y, z) = 1 \u2044 N \u2211 N i=i (xi, yi, zi)) to find the center of the black hole. Then to find the average radius, we take the average distance of these points to the center ( r_bh = 1 \u2044 N \u2211 N i=i \u221a ((xi \u2212 x) 2 + (yi \u2212 y) 2 + (zi \u2212 z) 2 )). Then we can draw rings with radii and height that are ratios of r_bh (e.g. (r, h) = (0.6 r_bh, 1.1r_bh)). Since we are dealing with a system where the black hole spin and the accretion disk angular momentum are tilted with respect to each other and the disk is self-gravitating with a mass comparable or even larger than the black hole mass, the black hole\u2019s spin will precess. Therefore we want the grid seeds to follow this precession, so we set up a script to automatically read the black hole spin from the BHspin.mon file to the spins field in seed maker.py. We also need to track the movement of the black hole by reading the location of the black hole from BH diagnostics.ah1.gp file. In seed maker.py, we make an initial guess: centers = [(x1, y1, z1)], pairs = [(0.2*r bh, 1.8*r bh)], spins = [(Jx bh, Jy bh, Jz bh)], num seeds per ring = [10], and offsets = [0.] Here (x1, y1, z1) is the position of the center of the black hole read from BH diagnostics.ah1.gp, r bh is the average radius of the horizon from the center, and (Jx bh, Jy bh, Jz bh) is the spin of the black hole read from BHspin.mon. For the integration settings, we use the integrationType=Leapfrog integrator with maxSteps=15000 and maxStepLength=1. We choose a small integration step size since the magnetic field is very strong and twisting, so larger step sizes will cause the integrator to step over details in the magnetic field. Additionally, as described in Sec. 5.3.2, we choose the integrationDirection to make sure the field lines don\u2019t integrate into the horizon. The resulting image is the left panel of Fig. 57. In this image, we use a Clip operator to get a meridional slice of the isosurface density plot in order to get a better view of the magnetic field lines. The resulting magnetic field lines show a helical shape and emerge from the poles of the black hole. However, we would like to make the helix formed by the field lines a bit wider, if we can. The jet may not be wider than this but if it is, we want to delineate that with our visualization. To do this, we increase the radius of the ring (0.2 r bh\u21920.6 r bh) and decrease the height of the rings (1.8 r bh\u21921.1 r bh). The resulting image is in the middle panel of Fig. 57. Although we succeeded in increasing the width of the helix, it seems that we\u2019ve increased the ring\u2019s radius by too much, resulting in field lines leaving the jet and penetrating the accretion disk. Adjusting the ring\u2019s radius by a bit, e.g. by choosing a radius 0.5 r bh and a height 1.6 r bh, results in the image in the right panel of Fig. 57. This tightly wound helical magnetic field is our optimal plot. Now we go back to the beginning of the evolution and fix our choices for (radius, height) pairs. The rings will follow the movement of the black hole and the precession of the black hole spin, while the helical field lines will slowly emerge as matter accretes onto it. (a) Initial Guess (b) After first change (c) After second change Figure 57: Finding proper grid seeds for BHD magnetic field lines Visualizing a Relativistic Jet As the BHD is evolved from its initial configuration, magnetized matter accretes onto the black hole. After a while (a few hundred M), collimated magnetic field lines will develop above the black hole poles (see Fig. 43 for an example). When this behavior begins, we suspect that a relativistic jet may be forming and we need to make additional plots to confirm, or rule out the existence of a jet. We will make the following plots: Isosurface or Volume plot of log ( \u03c10 \u2044 \u03c10(0) ), which will visualize the accretion disk. Pseudocolor plot of the apparent horizon of the black hole. Vector plot of the black hole spin. Integral curve plot of the magnetic field seeded by grid seeds around the black hole poles. Isosurface or Volume plot of log ( b 2 \u2044 2\u03c10 ). b 2 \u2044 2\u03c10 is the force-free parameter which is one requirement of relativistic jet formation. In particular, one of the conditions for incipient jet formation is b 2 \u2044 2\u03c10 \u226b 1, a feature of the Blandford-Znajek mechanism. Vector plots of the velocity field in the jet area. Having a mildly relativistic outflow with \u0393 L \u2273 1.2 is another condition for jet formation. The first four plots were made in previous sections. Using the grid seeds we found that once the magnetic field lines wind in a helical shape, then we may be looking at a relativistic jet. In order to further corroborate this, we need to make a volume plot of log ( b 2 \u2044 2\u03c10 ) and a vector plot of the fluid velocity field. The quantity b 2 \u2044 2\u03c10 is the force-free parameter and its value is one of the indicators for relativistic jet formation. In regions where this value is high, the magnetic field is strong and the density is comparatively low, thus particles of matter are more easily accelerated outward to relativistic speeds by the magnetic field. We plot the value log ( b 2 \u2044 2\u03c10 ) when we suspect a jet is present. We actually define an \u201dincipient jet\u201d based on the following three characteristics: 1) A collimated, tightly wound magnetic field, 2) a mildly relativistic outflow (\u0393 L > 1.2), and 3) the outflow is confined by a funnel containing a (nearly) force-free magnetic field b 2 \u2044 2\u03c10 \u2273 10. As we can see on the left panel of Fig. 58, an isosurface plot of the log ( b 2 \u2044 2\u03c10 ) shows that b 2 \u2044 2\u03c10 is between 10 and 100 (purple is between 1 and 2 in the colorbar of the log plot) around the winding magnetic fields. We note that in such a jet, the flow will ultimately be accelerated to \u0393 L \u2273 100, but this happens at radii beyond the outer boundary of our simulation. A vector plot of the fluid velocity also helps confirm whether or not the fluid velocities in the jet are actually (mildly) relativistic inside the magnetic funnel. Following the process described in Sec. 5.4, we create a vector plot of the fluid velocity field. In these images, we choose only plot vectors in regions where the log ( b 2 \u2044 2\u03c10 ) > \u22120.5 by using lines 11 and 12 in Code Lst. 5.4. Then we apply a cylinder selection operator to only plot vectors in a cylinder centered around the jet. The resulting image is shown in Fig. 58. A reference 0.5c vector is added to show the magnitude of the velocity vectors. We can see that the velocities in the jet are relativistic. Figure 58: BHD jet with volume plot of log","title":"Black Hole with Accretion Disk"},{"location":"Section7/#case-study-black-hole-with-accretion-disk","text":"The second case study will be of a black hole surrounded by an accretion disk, which we will refer to in this section as a BH-disk (BHD). BHDs can be found in active galactic nuclei or in the aftermath of binary neutron star mergers. The BHD data we will use in this section will be of a rapidly spinning black hole surrounded by a self-gravitating accretion disk where the spin of the BH is tilted with respect to the angular momentum of the disk. The accretion disk is seeded with a poloidal magnetic field. As matter accretes onto the BH, a relativistic jet develops. Visualizations of the BHD use the following simulation output databases: rho_b.file_*.h5: HDF5 data of the fluid rest-mass density $\\rho_0$ Bx.file *.h5, By.file *.h5, Bz.file *.h5: HDF5 data of the magnetic field vx.file *.h5, vy.file *.h5, vz.file *.h5: HDF5 data of the fluid velocity smallb2.file *.h5: HDF5 data of b2 \u2261 B2/(4\u03c0) where B is the magnitude of the magnetic field. h.t*.ah1.gp: Horizon data that lists a set of points on the apparent horizon of the black hole. BH diagnostics.ah1.gp: ASCII black hole diagnostic file containing information about the apparent horizon of the black hole. BHspin.mon: ASCII file containing the black hole spin vector at each iteration In this case study, we will focus on visualizations of the density, which was glossed over when we made visualizations of the magnetars in Sec. 6. We will go over in detail how to find good settings for visualizing the density using both isosurface and volume rendering techniques.","title":"Case Study: Black Hole with Accretion Disk"},{"location":"Section7/#isosurface-rendering-of-disk","text":"Using the databases mentioned above, we will make the following plots. Isosurface of Volume plot of log$\\left(\\frac{\\rho_0}{\\rho_0(0)}\\right)$, which will visualize the accretion disk. Pseudocolor plot of the apparent horizon of the black hole. Vector plot of the black hole spin. This section focuses on designing the BHD visualizations seen within in Figs. 50 and 51. There were a number of different visualization parameter decisions with their respective trade-offs made within this figures. To begin with, we created these visualizations using isosurface rendering as described in Sec. 4.2.2, utilizing layers of shells to model the different density values. Volume rendering is a more computational intensive operation in comparison to isosurface rendering, and isosurface rendering allows for a lot more flexibility when iterating through the visualization development process. The salient features for isosurface and volume rendering have been discussed in Sec. 4.2.2 and Sec. 4.2.1. Here we will discuss specific details regarding the visualization of BHDs using isosurface rendering. Figure 50: Isosurface zoom in of a massive BHD. At t = 0 the angular momentum of the disk is along the z axis, while the spin of the black hole (yellow arrow) is at 45\u25e6 from the z axis. Figure 51: Isosurface zoom out of the massive BHD of Fig. 50 Starting with the shells, the number amount of them and their distribution across the data play a vital role in what information is highlighted within the visualization. Within this simulation, there is significant variation in the fluid density within the inner torus of the BHD. Through experimentation, we found that there was quite a bit of fluid movement and variation for the fluid density values between -1 to -2 (log scale), therefore adding more shells within this region, can better communicate the fluid dynamics across the evolution. In the same light, the following parameters are different characteristics to be considered in order to maximize the information communicated: min and max : Disk size: Since we normalize our colorbar with the nital maximum density and take the logarithm of the resulting ratio, 0 reflects the maximum density value of the disk (typically found close to the disk). For the lower bound, we are typically interested in density values that are of the order 3 or 4 decades smaller than the maximum density. The magnitude of the minimum colorbar density is directly correlated to the size of the disk being visualized. This parameter can be adjusted within the isosurface and colorbar XML file as mentioned in Sec. 5.2.1 contourNLevels : Resolution of visualization Having more shells leads to sharper images, since we are able to capture more densities but the trade off is disk opacity. The more shells we have, the harder it is to keep the disk transparent and track all of the layers in one image. Fortunately, we found that the solution to this problem is to experiment with lighter colors and different opacity gradients as controlled within the colorbar, which we will review in later sections. contourValue : Disk smoothness As previously mentioned, there are usually specific regions of density that are more interesting and have more information to communicate than others, so focusing on creating more shells within this region of the data can be crucial to creating high quality visualizations. Unfortunately, there is no magic formula to figure out exactly what those regions of interest might be without iterating through different models and experimenting to see what shell configurations work best. imageZoom and viewNormal: : Perspective of disk The camera angle of the disk itself is crucial to what the visualization focuses on, as discussed within Sec. 4.5. Different levels of zoom and angles of the disk influence which information is largely communicated by the visualization, so experimenting on this end to figure out which perspective from the camera angle lends itself to a better visualization is something to consider when creating high quality visualizations. When modeling the visualization, it can be useful to think about what information should be communicated through the visualization, and let that guide the visualization process. For instance, Fig. 51 communicates the fluid dynamics of the outer torus and the overall disk across the evolution, whereas Fig. 50 communicates information regarding the fluid dynamics of the inner torus. Custom colorbars can be created and stored within the \u223c/.visit directory. As mentioned before hand in Sec. 5.2, the colorbar is created through an xml based file with the .ct file extension. Utilizing this feature, we create our own colorbars in order to bring more depth to the visualization and highlight different attributes, as seen within the template colorbar attached within the github. The following considerations were made when creating the colorbar: ColorControlPoint : Clarity of visualization: Within this case, since there are 21 shells across the BHD, VisIt will interpolate the correspond\ufffeing values within the colorbar and assign the color to the density value. As more shells are created within the visualization, it becomes increasingly more important to consider how the colorbar is structured in order to best communicate information within the visualization. After experimenting with different color schemes, it was found that darker colors with a limited color spectrum failed to highlight the different density shells. Although the visualization showed the overall variation in density, the minute details on how different layers of the structure change throughout the evolution was lost to the viewer. Incorporating a lighter color and opacity gradient across the pseudo-color plot allowed for more of the internal structures of the BHD to be displayed, allowing the communication of low-level information about the composition of the system. ColorControlPointList : Dynamics of density value : The spectrum of colors within the visualization should also be proportional to the magnitude of different colors packed within the colorbar. With a large number of shells being added to the visualization, there will be a lot more information that could be communicated to the viewer to show the dynamics of the torus throughout the evolution. ColorControlPoint : Distribution of density values : As mentioned beforehand, we can set distinct colors across the colorbar and VisIt will automatically interpolate between the different values in order to generate the colorbar. From here, VisIt will assign different color values to the corresponding shells within the isosurface rendering process. Leveraging this fact, it is important to be cognizant of what pockets of density values might be more important than others, so that more variation of colors are created in that region. In general, creating more color points can create more control over the smoothness between the difference colors across the colorbar. In order to better understand the thought process behind these choice s, we can take a look at some of the iterations through the visualization process. To begin, we first visualized the black hole with a limited color table (Fig. 52), from dark red to orange, that did not show the details in the shell variation as shown in Fig. 50. Figure 52: Black hole-disk visualization using a limited color table. Using this colorbar, the different shells within the disk around the black hole seem to merge together and are very difficult to distinguish. In order to better bring out the density distribution, we incorporate in Fig. 53 a wider spectrum of lighter colors with a corresponding opacity gradient that allowed for lighter densities to have more transparency in order to better highlight the internal structures of the jets and variation of densities. Figure 53: Black hole-disk visualization with improved color table.","title":"Isosurface Rendering of Disk"},{"location":"Section7/#volume-rendering-of-disk","text":"In this section, we will make volume rendering of the same BHD data used in Sec. 7.1. Fig. 56 is created using volume rendering by utilizing ray tracing modeling techniques in order to create high-quality 3-D renderings of the density values across the BHD. Being the more computationally demanding rendering operation, the volume rendering visualization technique brings out a different texture throughout the density plotting, as it allows the visualizations to have a degree of transparency, definition, and quality that cannot be duplicated using isosurface rendering. To start off, we begin the visualization process by iterating through different view settings of the BHD through computationally less intensive rendering processes like isosurface rendering for instance. After making sure we have set up the proper angles for the model, we can switch over to the ray casting volume rendering modeling for the BHD. In terms of the ray casting, there are three important parameters that play a critical role in the nature of the visualization and the information highlighted within the visualization. Building on the information on the last section, our goal within this visualization would be to highlight the fluctuation of the fluid density values across the evolution in a visually appealing manner. In this light, the following parameters are different characteristics to be considered to in order to maximize the information communicated: colorControlPoints : Visual clarity : Within the volume rendering plot, the colorbar can be controlled primarily through the volume rendering file with the colorControlPointList parameter. Functioning similar to the pseudo-color plot XML file, the colorbar will take a set of RBGA color values associated with a density data distribution percentage. As mentioned above, the general scheme that we follow for generating a colorbar would be to create a diverse spectrum of light colors, as that will illuminate the variation of density across the BHD throughout the evolution with the most clarity and visual appeal. freeformOpacity : Model opacity profile : The volume rendering plot can be greatly influenced by the specific opacity profiles set within the visualization, as different opacity parameters will communicate different levels of information to the viewer. As mentioned in Sec. 4.2.1, the freeformOpacity parameter is crucial to the opacity profile of the visualization, influencing which density values have what level of opacity, as well as the overall disk opacity. By adjusting the different values of the freeformOpacity 256 array, different aspects of the colorbar and the model will be shown within the resultant visualization. Often on a case by case decision based on what aspect of the visualization we want to focus on, such as the BHD or different magnetic field lines, these parameters can be adjusted to perfect the visualization. samplesPerRay : Resolution and smoothness of plot : The volume rendering ray casting method visualizes the disks with striking detail and clarity by casting out a set number of rays from the camera onto the model and sampling the different density value points within the visualization. With a higher magnitude of sample points per ray, the visualization will have a higher resolution but will take more time for the visualization to render. Depending on the time frame and the computational capacity available to visualize the model, the samplesPerRay can be adjusted accordingly view.xml : Model framing : The camera angle of the visualization is critical to the visualization, as it not only controls the information communicated to the viewer, but also largely influences how the sample rays might interact with the density data to create the visualization. The camera angle is controlled through an xml file as seen within Fig. 38. Experimenting with the viewing normal angle, as well as the zoom of the camera, can showcase different aspects of the model during its evolution. Figure 54: Base image of the BHD through volume rendering In order to better understand the volume rendering process, we will visualize the BHD as seen in 7.1 through volume rendering. To begin, we can set the viewing angle of the visualization and create a base image to iterate our visualization. For more information on how to create a volume rendering image, please refer to our previous section on volume rendering in Sec. 4.2.1. Figure 55: Distribution of freeformOpacity values Although we can make out the shape of the disk, we need to experiment with the settings to make the visualization better. For instance, in Fig. 54, the entire BHD seems to be completely red even though there is a vibrant colorbar used in the model. In order to improve this behavior, we first look at the volume XML file used by VisIt that controls the hyper-parameters associated with this visualization. From here, we can see how the freeformOpacity of the visualization was structured. As seen within the top left corner of the visualization beside the colorbar, there seems to be a large bias towards the red region of the visualization with very little opacity across the rest of the colorbar. Modifying towards a wider distribution of the freeformOpacity values, in order to better depict the entire colorbar across the BHD, we created the final visualization as seen in Fig 56. Figure 56: Final image of the BHD with volume rendering","title":"Volume Rendering of Disk"},{"location":"Section7/#magnetic-field-lines-around-the-black-hole","text":"In addition to the plots mentioned in Sec. 7.2 we will also make an Integral curve plot of the magnetic field seeded by grid seeds around the black hole. Since we are interested in capturing the magnetic field around the black hole, we will be using grid seeds that are placed above and below the poles of the black hole as described in Sec. 5.3.2. Since we are using grid seeds, we are not visualizing individual magnetic field lines tied to particles and tracking how they change. Rather, we are visualizing the shape of the magnetic field around the black hole. See Fig. 43 for an example of magnetic field lines seeded by grid seeds in a BHD. In our BHD initial data, the magnetic field exists only inside the accretion disk. Thus, the vacuum in between the black hole and the disk contains no magnetic field. For this reason, integrating grid seeds placed around the black hole before sufficient accretion has taken place will not draw field lines, since the magnetic field will be zero in those regions. As the evolution proceeds and matter is accreted from the disk onto the black hole, the magnetic field lines seeded around the black hole will start to develop. Differential rotation of the matter due to frame-dragging causes the magnetic field to wind up and form a helical structure above the poles. Since our aim is to best capture these helical magnetic field lines above the black hole, we choose a late time after sufficient accretion has taken place to use for magnetic field line experimentation. To generate the grid seeds, we will use seed maker.py (Code Lst. 5.3.1). For grid seeds around a black hole, it is helpful to define the (radius, height) pairs in terms of the average radius r bh of the black hole horizon. Unless the mass of a black hole changes drastically (for example in a binary black hole merger), it is okay to find r bh at a fixed time and use that value for the entire remaining evolution. To find the value of r bh, we can use the h.t .ah1.gp horizon data which contains a list of points {(xi, yi, zi)} N i=1 on the apparent horizon. Find the average of these points (which is just the arithmetic mean (x, y, z) = 1 \u2044 N \u2211 N i=i (xi, yi, zi)) to find the center of the black hole. Then to find the average radius, we take the average distance of these points to the center ( r_bh = 1 \u2044 N \u2211 N i=i \u221a ((xi \u2212 x) 2 + (yi \u2212 y) 2 + (zi \u2212 z) 2 )). Then we can draw rings with radii and height that are ratios of r_bh (e.g. (r, h) = (0.6 r_bh, 1.1r_bh)). Since we are dealing with a system where the black hole spin and the accretion disk angular momentum are tilted with respect to each other and the disk is self-gravitating with a mass comparable or even larger than the black hole mass, the black hole\u2019s spin will precess. Therefore we want the grid seeds to follow this precession, so we set up a script to automatically read the black hole spin from the BHspin.mon file to the spins field in seed maker.py. We also need to track the movement of the black hole by reading the location of the black hole from BH diagnostics.ah1.gp file. In seed maker.py, we make an initial guess: centers = [(x1, y1, z1)], pairs = [(0.2*r bh, 1.8*r bh)], spins = [(Jx bh, Jy bh, Jz bh)], num seeds per ring = [10], and offsets = [0.] Here (x1, y1, z1) is the position of the center of the black hole read from BH diagnostics.ah1.gp, r bh is the average radius of the horizon from the center, and (Jx bh, Jy bh, Jz bh) is the spin of the black hole read from BHspin.mon. For the integration settings, we use the integrationType=Leapfrog integrator with maxSteps=15000 and maxStepLength=1. We choose a small integration step size since the magnetic field is very strong and twisting, so larger step sizes will cause the integrator to step over details in the magnetic field. Additionally, as described in Sec. 5.3.2, we choose the integrationDirection to make sure the field lines don\u2019t integrate into the horizon. The resulting image is the left panel of Fig. 57. In this image, we use a Clip operator to get a meridional slice of the isosurface density plot in order to get a better view of the magnetic field lines. The resulting magnetic field lines show a helical shape and emerge from the poles of the black hole. However, we would like to make the helix formed by the field lines a bit wider, if we can. The jet may not be wider than this but if it is, we want to delineate that with our visualization. To do this, we increase the radius of the ring (0.2 r bh\u21920.6 r bh) and decrease the height of the rings (1.8 r bh\u21921.1 r bh). The resulting image is in the middle panel of Fig. 57. Although we succeeded in increasing the width of the helix, it seems that we\u2019ve increased the ring\u2019s radius by too much, resulting in field lines leaving the jet and penetrating the accretion disk. Adjusting the ring\u2019s radius by a bit, e.g. by choosing a radius 0.5 r bh and a height 1.6 r bh, results in the image in the right panel of Fig. 57. This tightly wound helical magnetic field is our optimal plot. Now we go back to the beginning of the evolution and fix our choices for (radius, height) pairs. The rings will follow the movement of the black hole and the precession of the black hole spin, while the helical field lines will slowly emerge as matter accretes onto it. (a) Initial Guess (b) After first change (c) After second change Figure 57: Finding proper grid seeds for BHD magnetic field lines","title":"Magnetic Field Lines around the Black Hole"},{"location":"Section7/#visualizing-a-relativistic-jet","text":"As the BHD is evolved from its initial configuration, magnetized matter accretes onto the black hole. After a while (a few hundred M), collimated magnetic field lines will develop above the black hole poles (see Fig. 43 for an example). When this behavior begins, we suspect that a relativistic jet may be forming and we need to make additional plots to confirm, or rule out the existence of a jet. We will make the following plots: Isosurface or Volume plot of log ( \u03c10 \u2044 \u03c10(0) ), which will visualize the accretion disk. Pseudocolor plot of the apparent horizon of the black hole. Vector plot of the black hole spin. Integral curve plot of the magnetic field seeded by grid seeds around the black hole poles. Isosurface or Volume plot of log ( b 2 \u2044 2\u03c10 ). b 2 \u2044 2\u03c10 is the force-free parameter which is one requirement of relativistic jet formation. In particular, one of the conditions for incipient jet formation is b 2 \u2044 2\u03c10 \u226b 1, a feature of the Blandford-Znajek mechanism. Vector plots of the velocity field in the jet area. Having a mildly relativistic outflow with \u0393 L \u2273 1.2 is another condition for jet formation. The first four plots were made in previous sections. Using the grid seeds we found that once the magnetic field lines wind in a helical shape, then we may be looking at a relativistic jet. In order to further corroborate this, we need to make a volume plot of log ( b 2 \u2044 2\u03c10 ) and a vector plot of the fluid velocity field. The quantity b 2 \u2044 2\u03c10 is the force-free parameter and its value is one of the indicators for relativistic jet formation. In regions where this value is high, the magnetic field is strong and the density is comparatively low, thus particles of matter are more easily accelerated outward to relativistic speeds by the magnetic field. We plot the value log ( b 2 \u2044 2\u03c10 ) when we suspect a jet is present. We actually define an \u201dincipient jet\u201d based on the following three characteristics: 1) A collimated, tightly wound magnetic field, 2) a mildly relativistic outflow (\u0393 L > 1.2), and 3) the outflow is confined by a funnel containing a (nearly) force-free magnetic field b 2 \u2044 2\u03c10 \u2273 10. As we can see on the left panel of Fig. 58, an isosurface plot of the log ( b 2 \u2044 2\u03c10 ) shows that b 2 \u2044 2\u03c10 is between 10 and 100 (purple is between 1 and 2 in the colorbar of the log plot) around the winding magnetic fields. We note that in such a jet, the flow will ultimately be accelerated to \u0393 L \u2273 100, but this happens at radii beyond the outer boundary of our simulation. A vector plot of the fluid velocity also helps confirm whether or not the fluid velocities in the jet are actually (mildly) relativistic inside the magnetic funnel. Following the process described in Sec. 5.4, we create a vector plot of the fluid velocity field. In these images, we choose only plot vectors in regions where the log ( b 2 \u2044 2\u03c10 ) > \u22120.5 by using lines 11 and 12 in Code Lst. 5.4. Then we apply a cylinder selection operator to only plot vectors in a cylinder centered around the jet. The resulting image is shown in Fig. 58. A reference 0.5c vector is added to show the magnitude of the velocity vectors. We can see that the velocities in the jet are relativistic. Figure 58: BHD jet with volume plot of log","title":"Visualizing a Relativistic Jet"},{"location":"Section8/","text":"Case Study: Binary Neutron Stars The third case study will be the visualization of a binary neutron star system. Following event GW170817, such binaries constitute prime candidates for multimessenger astronomy and therefore visualizations of magnetized simulations are important. The figures that will be produced in this section correspond to the simulations discussed in [6] and consist of mergers of identical irrotational neutron stars with dipole-like magnetic fields extending outside the stars to infinity. We will use the same techniques discussed in the case study of a single neutron star in Sec. 6. In addition, these visualizations will also draw from techniques discussed in the case study of a BHD in Sec. 7 since after the merger of two neutron stars, a black hole surrounded by an accretion disk usually forms. These visualizations will use the following simulation output databases: rho b.file *.h5 : HDF5 data of the fluid rest-mass density \u03c10 Bx.file *.h5, By.file *.h5, Bz.file *.h5 : HDF5 data of the magnetic field particles.mon : ASCII file containing the locations of a number of fluid particles vx.file *.h5, vy.file *.h5, vz.file *.h5 : HDF5 data of the magnetic field smallb2.file *.h5 HDF5 data of b 2 \u2261 b 2 /(4\u03c0) where B is magnetic field magnitude h.t*.ah1.gp : Set of points on the apparent horizon of the remnant black hole (if it forms in the first place) Using these databases, we will make visualizations across the entire evolution. In the case that we will visualize, after the merger of the neutron stars, a hypermassive neutron star forms which will eventually collapse into a black hole. We will split up the visualizations into two sections: pre-black hole formation and post-black hole formation. Before Black Hole Formation We will make the following plots before a black hole forms: Isosurface or Volume plot of log ( \u03c10 \u2044 \u03c10(0) ), which will visualize the two neutron stars as well as the remnant hypermassive neutron star after the merger takes place. Integral curve plot of the magnetic field lines seeded by particles inside the neutron stars. Plotting the density follows the same procedure as the single neutron star case in Sec. 6. However, it is worth pointing out that since the two neutron stars will eventually merge, we must consider the range of densities across the entire evolution when thinking about our plots. After the merger, the range of densities will be larger than the range of densities present prior to the merger. The highest density of the remnant neutron star will be larger than the highest density of the original two stars since the remnant has a larger mass. Additionally, the accretion disk that forms from debris around the remnant will have densities much smaller than the densities of the neutron stars. Because of this, it is a good idea to choose a color table by experimenting both with the initial data of two neutron stars as well as post-merger data that contains an accretion disk and a remnant neutron star. However, prior to the formation of the black hole (in the case that the remnant neutron star collapses into a black hole), we keep the portion of the colorbar that corresponds to densities for the accretion disk transparent so that the neutron stars can be seen clearly. After the black hole has formed we want to bring out the accretion disk, so we increase the opacity of that part of the colorbar. This transition is discussed in Sec. 8.2. The process of finding good particle seeds for magnetic field lines is similar to that of a single neutron star. However, since now there are two neutron stars, we pick a set of seed point (rings) for each neutron star. The initial dipole-like magnetic field in these neutron stars has only poloidal components in each star. From the diagnostic files, we find that at t = 0, the center of masses of the two neutron stars are at (x1, y1, z1) = (\u221212.5, 0.0, 0.0), and (x2, y2, z2) = (12.5, 0.0, 0.0). Additionally, the radius of the neutron star is approximately \u223c 5.0 in code (G = c = M\u2299 = 1) units. Using this information, we can prepare an initial guess for seed points similar to what we have done for the single neutron star case. There will of course be a similar process that involves tweaking our seed point rings as well as the integration settings to perfect our visualization. The result of this process are seed points that we generated using seed maker.py (Code Lst. 5.3.1) with centers = [(-12.5, 0., 0.), (-12.5, 0., 0.), (12.5, 0., 0.), (12.5, 0., 0.)], pairs = [(4., 3.), (0.9, 2.), (4., 3.), (0.9, 2.)], spins = [(0., 0., 1.), (0., 0., 1.), (0., 0., 1.), (0., 0., 1.)], num seeds per ring = [10, 10, 10, 10], and offsets = [0., 0., 0., 0.]. For the integration settings, we settled on the integrationType=DormandPrince integrator with maxSteps=50000 and maxStepLength=10. The rings of idealized seed points are shown on the left-hand side of Fig. 59 and the magnetic fields drawn after choosing the nearest particle seeds are shown on the right-hand side. (a) Idealized seed points (b) Field lines drawn with particle seeds Figure 59: Particle seeded magnetic field lines in a binary neutron star. As the neutron stars inspiral, we will continue using the particles we\u2019ve chosen as seed points for the magnetic field. Since the magnetic field lines are attached to the fluid matter, they will follow the neutron stars as they orbit each other. Fig. 60 shows two images from a later time in the simulation with the magnetic field lines seeded by our chosen particles. The image on the left shows the moment the neutron stars merge and the image on the right shows the hypermassive [2] neutron star remnant that forms after the merger. (a) Moment when the two neutron stars merge. (b) Remnant hypermassive neutron star Figure 60: Evolution of binary neutron star with particle field lines. The remnant hypermassive neutron star will eventually (sometimes immediately) collapse into a black hole. After the neutron star collapses into a black hole, there are some things we must change in our visualizations. After Black Hole Formation After the merger and once the remnant hypermassive neutron star collapses to a black hole, we will make the following plots: Isosurface or Volume plot of log ( \u03c10 \u2044 \u03c10(0) ), which will visualize the accretion disk. We change the colorbar of these plots compared to before black hole formation to emphasize the accretion disk. Pseudocolor plot of the apparent horizon of the black hole. Integral curve plot of the magnetic field seeded by grid seeds around the poles of the black hole. After the hypermassive neutron star collapses to a black hole, most of the fluid matter will have disappeared into the horizon. This means that the particles that we\u2019ve been using to seed magnetic field lines will also disappear into the horizon, so attempts to draw field lines using these particles don\u2019t make sense. As a result, if we visualize the system using the settings we use prior to black hole formation, the resulting image will look rather empty (panel (b) of Fig. 61). First of all, we will need to visualize the black hole. To visualize the horizon, we will use the h.t*.ah1.gp horizon data and follow the directions in Sec. 5.1. At this moment we choose not to draw a spin vector; however, it can be easily added using the same method described in Sec. 5.1. To visualize the magnetic field, we will switch to using grid seeds that are placed above and below the black hole poles as described in Sec. 5.3.2. Remember that since we are using grid seeds, we are not visualizing magnetic field lines tied to particles and tracking how they change but rather visualizing the shape of the magnetic field around the black hole at various instants. See Fig. 61 for a closer look at the magnetic field seeded by grid seeds around the black hole. We also increase the opacity of the lower density values on the colorbar to bring out the accretion disk. If the fluid density is being rendered with a Volume plot, then this opacity transition can be done by changing the freeFormOpacity parameter to increase the opacity of lower densities (see Sec. 4.2.1, Sec. 7.2). If the fluid density is being rendered with an Isosurface plot, then this opacity transition can be done by changing the minimum value min parameter to include shells that correspond to lower densities (see Sec. 4.2.2, Sec. 7.1). The result of these settings can be seen in Fig. 61(c). Notice the positions of the purple and the yellow/green on the colorbar. If the yellow portion of the colorbar wasn\u2019t transparent prior to the formation of the black hole, then the hypermassive neutron star we are interested in would be obscured by lower densities. After the black hole forms and most of the matter disappears into the horizon, we increase the opacity of the lower density values since we are now interested in viewing the accretion disk. (a) Initial data with colorbar (b) Disk before changes (c) Disk after changes (d) Magnetic field seeded by grid points Figure 61: Changes made after black hole formation When creating a movie of the entire evolution, we stitch together movies of the evolution constructed before and after black hole formation. During this transition, it is useful to add a slow fade effect (on a \u201ddissolve\u201d) when changing the opacity of the colorbars. This can be done outside of VisIt in the video editing software of our choice (e.g. Blender, Premiere Pro). As an example, go to the 1:00 mark in the video: https://www.youtube.com/watch?v=Bh7otUA78KE Additional Plots After Merger In addition to the visualizations of the entire evolution before and after the black hole formation, we will also create some additional visualizations after the merger to assess the potential formation of a relativistic jet. In addition to the plots made on Sec. 8.1, 8.2 we will also plot the following Isosurface or Volume plot of log ( b 2 \u2044 2\u03c10 ). Vector plots of the velocity field in the jet area. If the magnetic field lines seeded by grid seeds around the black hole form a helical winding pattern as they do in the bottom panel of Fig. 61, then we may be looking at an incipient relativistic jet. In order to further investigate this, we will make a volume plot of log ( b 2 \u2044 2\u03c10 ) and a vector plot of the fluid velocity field. As discussed in Sec. 7.4, the quantity b 2 \u2044 2\u03c10 is the force-free parameter and its value is one of the indicators for relativistic jet formation. As we can see on the left panel of Fig. 62\u2014which is at a time of 1761M after the black hole forms\u2014a volume plot of the log ( b 2 \u2044 2\u03c10 ) shows that b 2 \u2044 2\u03c10 is between 10 and 100 (purple is between 1 and 2 in the colorbar of the log plot) in a cylindrical region above the black hole poles. At the same time the magnetic field lines form a tightly wound funnel which is magnetically dominated. A vector plot of the fluid velocity also helps confirm whether or not the fluid velocities in the jet are actually (mildly) relativistic. Following the process described in Sec. 5.4, we create a vector plot of the fluid velocity field. In these images, we choose to only plot vectors with magnitudes greater than 0.5c by using line 3 in Code Lst. 5.4. Then we apply a cylindrical selection operator to plot vectors only in a cylinder centered around the jet. The resulting image is the right panel of Fig. 62. Since the vectors are scaled by magnitude, once a reference 0.5c vector is depicted, we can see that the velocities around the jet are relativistic. (a) Volume plot of log ( b 2 \u2044 2\u03c10 ) (b) Vector plot of the velocity field Figure 62: Additional plots to confirm the existence of an incipient jet","title":"Binary Neutron Stars"},{"location":"Section8/#case-study-binary-neutron-stars","text":"The third case study will be the visualization of a binary neutron star system. Following event GW170817, such binaries constitute prime candidates for multimessenger astronomy and therefore visualizations of magnetized simulations are important. The figures that will be produced in this section correspond to the simulations discussed in [6] and consist of mergers of identical irrotational neutron stars with dipole-like magnetic fields extending outside the stars to infinity. We will use the same techniques discussed in the case study of a single neutron star in Sec. 6. In addition, these visualizations will also draw from techniques discussed in the case study of a BHD in Sec. 7 since after the merger of two neutron stars, a black hole surrounded by an accretion disk usually forms. These visualizations will use the following simulation output databases: rho b.file *.h5 : HDF5 data of the fluid rest-mass density \u03c10 Bx.file *.h5, By.file *.h5, Bz.file *.h5 : HDF5 data of the magnetic field particles.mon : ASCII file containing the locations of a number of fluid particles vx.file *.h5, vy.file *.h5, vz.file *.h5 : HDF5 data of the magnetic field smallb2.file *.h5 HDF5 data of b 2 \u2261 b 2 /(4\u03c0) where B is magnetic field magnitude h.t*.ah1.gp : Set of points on the apparent horizon of the remnant black hole (if it forms in the first place) Using these databases, we will make visualizations across the entire evolution. In the case that we will visualize, after the merger of the neutron stars, a hypermassive neutron star forms which will eventually collapse into a black hole. We will split up the visualizations into two sections: pre-black hole formation and post-black hole formation.","title":"Case Study: Binary Neutron Stars"},{"location":"Section8/#before-black-hole-formation","text":"We will make the following plots before a black hole forms: Isosurface or Volume plot of log ( \u03c10 \u2044 \u03c10(0) ), which will visualize the two neutron stars as well as the remnant hypermassive neutron star after the merger takes place. Integral curve plot of the magnetic field lines seeded by particles inside the neutron stars. Plotting the density follows the same procedure as the single neutron star case in Sec. 6. However, it is worth pointing out that since the two neutron stars will eventually merge, we must consider the range of densities across the entire evolution when thinking about our plots. After the merger, the range of densities will be larger than the range of densities present prior to the merger. The highest density of the remnant neutron star will be larger than the highest density of the original two stars since the remnant has a larger mass. Additionally, the accretion disk that forms from debris around the remnant will have densities much smaller than the densities of the neutron stars. Because of this, it is a good idea to choose a color table by experimenting both with the initial data of two neutron stars as well as post-merger data that contains an accretion disk and a remnant neutron star. However, prior to the formation of the black hole (in the case that the remnant neutron star collapses into a black hole), we keep the portion of the colorbar that corresponds to densities for the accretion disk transparent so that the neutron stars can be seen clearly. After the black hole has formed we want to bring out the accretion disk, so we increase the opacity of that part of the colorbar. This transition is discussed in Sec. 8.2. The process of finding good particle seeds for magnetic field lines is similar to that of a single neutron star. However, since now there are two neutron stars, we pick a set of seed point (rings) for each neutron star. The initial dipole-like magnetic field in these neutron stars has only poloidal components in each star. From the diagnostic files, we find that at t = 0, the center of masses of the two neutron stars are at (x1, y1, z1) = (\u221212.5, 0.0, 0.0), and (x2, y2, z2) = (12.5, 0.0, 0.0). Additionally, the radius of the neutron star is approximately \u223c 5.0 in code (G = c = M\u2299 = 1) units. Using this information, we can prepare an initial guess for seed points similar to what we have done for the single neutron star case. There will of course be a similar process that involves tweaking our seed point rings as well as the integration settings to perfect our visualization. The result of this process are seed points that we generated using seed maker.py (Code Lst. 5.3.1) with centers = [(-12.5, 0., 0.), (-12.5, 0., 0.), (12.5, 0., 0.), (12.5, 0., 0.)], pairs = [(4., 3.), (0.9, 2.), (4., 3.), (0.9, 2.)], spins = [(0., 0., 1.), (0., 0., 1.), (0., 0., 1.), (0., 0., 1.)], num seeds per ring = [10, 10, 10, 10], and offsets = [0., 0., 0., 0.]. For the integration settings, we settled on the integrationType=DormandPrince integrator with maxSteps=50000 and maxStepLength=10. The rings of idealized seed points are shown on the left-hand side of Fig. 59 and the magnetic fields drawn after choosing the nearest particle seeds are shown on the right-hand side. (a) Idealized seed points (b) Field lines drawn with particle seeds Figure 59: Particle seeded magnetic field lines in a binary neutron star. As the neutron stars inspiral, we will continue using the particles we\u2019ve chosen as seed points for the magnetic field. Since the magnetic field lines are attached to the fluid matter, they will follow the neutron stars as they orbit each other. Fig. 60 shows two images from a later time in the simulation with the magnetic field lines seeded by our chosen particles. The image on the left shows the moment the neutron stars merge and the image on the right shows the hypermassive [2] neutron star remnant that forms after the merger. (a) Moment when the two neutron stars merge. (b) Remnant hypermassive neutron star Figure 60: Evolution of binary neutron star with particle field lines. The remnant hypermassive neutron star will eventually (sometimes immediately) collapse into a black hole. After the neutron star collapses into a black hole, there are some things we must change in our visualizations.","title":"Before Black Hole Formation"},{"location":"Section8/#after-black-hole-formation","text":"After the merger and once the remnant hypermassive neutron star collapses to a black hole, we will make the following plots: Isosurface or Volume plot of log ( \u03c10 \u2044 \u03c10(0) ), which will visualize the accretion disk. We change the colorbar of these plots compared to before black hole formation to emphasize the accretion disk. Pseudocolor plot of the apparent horizon of the black hole. Integral curve plot of the magnetic field seeded by grid seeds around the poles of the black hole. After the hypermassive neutron star collapses to a black hole, most of the fluid matter will have disappeared into the horizon. This means that the particles that we\u2019ve been using to seed magnetic field lines will also disappear into the horizon, so attempts to draw field lines using these particles don\u2019t make sense. As a result, if we visualize the system using the settings we use prior to black hole formation, the resulting image will look rather empty (panel (b) of Fig. 61). First of all, we will need to visualize the black hole. To visualize the horizon, we will use the h.t*.ah1.gp horizon data and follow the directions in Sec. 5.1. At this moment we choose not to draw a spin vector; however, it can be easily added using the same method described in Sec. 5.1. To visualize the magnetic field, we will switch to using grid seeds that are placed above and below the black hole poles as described in Sec. 5.3.2. Remember that since we are using grid seeds, we are not visualizing magnetic field lines tied to particles and tracking how they change but rather visualizing the shape of the magnetic field around the black hole at various instants. See Fig. 61 for a closer look at the magnetic field seeded by grid seeds around the black hole. We also increase the opacity of the lower density values on the colorbar to bring out the accretion disk. If the fluid density is being rendered with a Volume plot, then this opacity transition can be done by changing the freeFormOpacity parameter to increase the opacity of lower densities (see Sec. 4.2.1, Sec. 7.2). If the fluid density is being rendered with an Isosurface plot, then this opacity transition can be done by changing the minimum value min parameter to include shells that correspond to lower densities (see Sec. 4.2.2, Sec. 7.1). The result of these settings can be seen in Fig. 61(c). Notice the positions of the purple and the yellow/green on the colorbar. If the yellow portion of the colorbar wasn\u2019t transparent prior to the formation of the black hole, then the hypermassive neutron star we are interested in would be obscured by lower densities. After the black hole forms and most of the matter disappears into the horizon, we increase the opacity of the lower density values since we are now interested in viewing the accretion disk. (a) Initial data with colorbar (b) Disk before changes (c) Disk after changes (d) Magnetic field seeded by grid points Figure 61: Changes made after black hole formation When creating a movie of the entire evolution, we stitch together movies of the evolution constructed before and after black hole formation. During this transition, it is useful to add a slow fade effect (on a \u201ddissolve\u201d) when changing the opacity of the colorbars. This can be done outside of VisIt in the video editing software of our choice (e.g. Blender, Premiere Pro). As an example, go to the 1:00 mark in the video: https://www.youtube.com/watch?v=Bh7otUA78KE","title":"After Black Hole Formation"},{"location":"Section8/#additional-plots-after-merger","text":"In addition to the visualizations of the entire evolution before and after the black hole formation, we will also create some additional visualizations after the merger to assess the potential formation of a relativistic jet. In addition to the plots made on Sec. 8.1, 8.2 we will also plot the following Isosurface or Volume plot of log ( b 2 \u2044 2\u03c10 ). Vector plots of the velocity field in the jet area. If the magnetic field lines seeded by grid seeds around the black hole form a helical winding pattern as they do in the bottom panel of Fig. 61, then we may be looking at an incipient relativistic jet. In order to further investigate this, we will make a volume plot of log ( b 2 \u2044 2\u03c10 ) and a vector plot of the fluid velocity field. As discussed in Sec. 7.4, the quantity b 2 \u2044 2\u03c10 is the force-free parameter and its value is one of the indicators for relativistic jet formation. As we can see on the left panel of Fig. 62\u2014which is at a time of 1761M after the black hole forms\u2014a volume plot of the log ( b 2 \u2044 2\u03c10 ) shows that b 2 \u2044 2\u03c10 is between 10 and 100 (purple is between 1 and 2 in the colorbar of the log plot) in a cylindrical region above the black hole poles. At the same time the magnetic field lines form a tightly wound funnel which is magnetically dominated. A vector plot of the fluid velocity also helps confirm whether or not the fluid velocities in the jet are actually (mildly) relativistic. Following the process described in Sec. 5.4, we create a vector plot of the fluid velocity field. In these images, we choose to only plot vectors with magnitudes greater than 0.5c by using line 3 in Code Lst. 5.4. Then we apply a cylindrical selection operator to plot vectors only in a cylinder centered around the jet. The resulting image is the right panel of Fig. 62. Since the vectors are scaled by magnitude, once a reference 0.5c vector is depicted, we can see that the velocities around the jet are relativistic. (a) Volume plot of log ( b 2 \u2044 2\u03c10 ) (b) Vector plot of the velocity field Figure 62: Additional plots to confirm the existence of an incipient jet","title":"Additional Plots After Merger"},{"location":"Section9/","text":"Case Study: Binary Black Hole with Accretion Disk The fourth case will study the visualization of a binary black hole system surrounded by a magnetized accretion disk (BBHD). These BBHDs correspond to the simulations discussed in [7]. In these cases, the spins of the black holes are tilted with respect to the orbital angular momentum. The visualizations we will make of these BBHDs will use techniques discussed in all of the earlier case studies. We will use the following simulation output databases: rho b.file *.h5 : HDF5 data of the fluid rest-mass density \u03c10 Bx.file *.h5, By.file *.h5, Bz.file *.h5 : HDF5 data of the magnetic field particles.mon : ASCII file containing the locations of a number of fluid particles vx.file *.h5, vy.file *.h5, vz.file *.h5 : HDF5 data of the magnetic field h.t*.ah1.gp, h.t*.ah2.gp, h.t*.ah3.gp : Set of points on the apparent horizon of the two black holes in the binary (ah1 and ah2) and the remnant black hole (ah3). Set of points on the apparent horizon of the two black holes in the binary (ah1 and ah2) and the remnant black hole (ah3). : ASCII black hole diagnostic file containing information about the location of the two black holes in the binary (ah1 and ah2) and the remnant black hole (ah3). BHspin.ah1.mon, BHspin.ah2.mon, BHspin.ah3.mon : ASCII file containing the spin vector data of the two black holes in the binary (ah1 and ah2) and the remnant black hole (ah3) Since the BBHDs have a lot of similarities with BHDs (Sec. 7), the visualizations we will make are very similar: Volume plot of log ( \u03c10 \u2044 \u03c10(0) ), which will visualize the accretion disk. Pseudocolor plot of the apparent horizon of the black holes. Vector plot of the black hole spins. Integral curve plot of magnetic field seeded by grid seeds around the black holes. Integral curve plot of magnetic field seeded by particles inside the disk. The volume plot of log ( \u03c10 \u2044 \u03c10(0) ) follows the same procedure described in Sec. 7.2. Here, we are using a different colorbar with fewer colors since we aren\u2019t trying to emphasize the structure of the disk with our visualizations (see Fig. 64 for the colorbar). Magnetic Field Lines in the Disk We will start by drawing the magnetic field lines seeded by particles inside the disk. This follows a similar procedure that we used to draw magnetic field lines inside the rotating neutron stars in Sec. 6. The difference here is that the structure of a disk (a toroid) is different from that of a neutron star (an ellipsoid). So in order to place particles inside the disk, we must choose the radius and height of our ring of seed points with some thought. If we create a 2D plot of the xz-slice of the rho b density database (Fig. 63), we can see estimate the inner radius rin, the outer radius rout, and the height hdisk of the disk. The colorbar in the 2D plot is the density normalized by the initial max density. If we take the disk to be the regions where the disk density is not zero (the dark blue), we estimate that rin \u2248 25, rout \u2248 150, and hdisk \u2248 50 in code units (G = c = M\u2299 = 1). For an initial guess to use in seedmaker.py (Code Lst. 5.3.1), we choose a pair (r, h) with rin < r < rout and h < hdisk. Note that the center of mass of the disk is at the origin and that its magnetic field is poloidal with respect to the z axis. Our final seed points end up being centers = [(0., 0., 0.)] pairs = [(90, 10)] spins = [(0., 0., 1.)] num seeds per ring = [12] offsets = [0.] Figure 63: 2D xz-slice of the density data. using the Leapfrog integrator with maxSteps=2200 and maxStepLength=300. Remember that we pick particles from paritcles.mon that are closest to our chosen seed points and drawn the magnetic field lines from these particles for the entire evolution. The field lines drawn using these particles and integration settings at the first time as well as a time later on in the evolution are shown in Fig. 64. Notice how the magnetic field lines twist at the later time due to the differential rotation of the accretion disk. (a) Initial Data (b) Later Time Figure 64: Magnetic field lines inside accretion disk Two Black Holes Next, we will discuss the main difference between BHDs and BBHDs. In particular, we will be working with three sets of black hole data. Two sets correspond to the two black holes in the original binary black hole system and another one corresponds to the remnant black hole after the merger. Even though there are three sets of data, there will only be a maximum of two black holes present in our visualizations. That is, data for the two black holes in the binary will not be plotted at frames where data for the remnant black hole exist. After merger, when we have a single black hole, the plots will be the same as the plots made of BHDs in Sec. 7 and of the remnant black hole in the NSNS merger in Sec. 8. So in this section, we will focus on visualizing BBHDs prior to merger. Before the merger, we are working with two sets of black hole data. To start, we will process the h.t .ah1.gp and h.t.ah2.gp files into bh1 .3d and bh2 *.3d files as described in 5.1. Make sure to use a separate variable name in the fourth column of the .3d files (the variable name is bh1p in Code Lst. 5.1) to differentiate between the two black holes in VisIt (for example, bh1p and bh2p). Then plotting the horizon for each black hole involves creating two separate Pseudocolor plots. For example, after opening up the two .3d databases, we can create two separate plots using Code Lst. 9.2. 1 ActivateDatabase(\"/path/to/bh1.3d\") 2 AddPlot(\"Pseudocolor\", \"bh1p\") #plot index 0 3 SetActivePlots(0) 4 ... #apply pseudo options 5 ActivateDatabase(\"/path/to/bh2.3d\") 6 AddPlot(\"Pseudocolor\", \"bh2p\") #plot index 1 7 SetActivePlots(1) 8 ... #apply pseudo options Code Listing 9.2: Creating two black hole plots Figure 65: Plotting Two Black Holes and Spin Vectors Example Similarly, we will process BHspin.ah1.mon and BHspin.ah2.mon into spin vec1.vtk and spin vec2.vtk files, making sure to use different variable names (the variable name is spinvec in Code Lst. 5.1). Then we create two separate Vector plots. When applying the box operator to the Vector plots to center the spin vector on the black hole, remember to use the location from the respective black hole. Recall that this can either be acquired from the correct row of the BH diagnoistics file or by taking the average of all the points in the .3d file. The spin vector data in the BHspin.mon files contain information about the spin magnitude as well, so as long as the vector plots for each black hole are scaled with the same scaling factor, the plot will correctly reflect the magnitude. Below in Fig. 65, we show the initial data for the BBHD where the black holes have a 2:1 mass ratio and the spins are tilted 45\u25e6 above the orbital plane. Now we will discuss visualizing the magnetic field lines seeded by grid points around each black hole. Remember in the BHD case (Sec. 7.3), we created rings of seed points above and below the black hole with respect to the black hole spin that follow changes in the black hole\u2019s spin and position. It is even more important for the rings to follow the black holes in the BBHD case since the black holes orbit each other. Like with the BHDs, for each black hole, we create rings of points by choosing (radius, height) as fractions of the average black hole radius r bh (which is calculated for each black hole as described in 7.3). After experimentation, we found that using (r, h) = (0.5 bh r, 1.5 bh r) works well. From previous steps, we already know the centers of the two black holes (x1, y1, z1) and (x2, y2, z2) (from either the BH diagnostic files or the .3d files we created). We also know the spins of the black holes (Jx bh1, Jy bh1, Jz bh1) and (Jx bh2, Jy bh2, Jz bh2). from the BHspin.mon files. For the first black hole, we set the fields in seed maker.py to centers = [(x1, y1, z1)] pairs = [(0.5*bh1 r, 1.5*bh1 r)] spins = [(Jx bh1, Jy bh1, Jz bh1)] and likewise for the second black hole centers = [(x2, y2, z2)] pairs = [(0.5*bh2 r, 1.5*bh2 r)] spins = [(Jx bh2, Jy bh2, Jz bh2)] We\u2019ve left out the num seeds per ring parameter since the best choice depends on the mass of the black hole. For example, in the 1:1 mass ratio case, we choose to set this parameter to 8 for each black hole. However, for the 4:1 mass ratio case, we choose to only use 4 per ring for the smaller black hole (still having 8 seeds per ring for the larger one). Below in Fig. 66, we show magnetic fields seeded by grid points around the black holes for the 1:1, 2:1, and 4:1 mass ratio binary BHD cases. (a) 1:1 Mass Ratio (b) 2:1 Mass Ratio (c) 4:1 Mass Ratio Figure 66: Magnetic field lines around black holes in a black hole binary system.","title":"Binary Black Hole with Accretion Disk"},{"location":"Section9/#case-study-binary-black-hole-with-accretion-disk","text":"The fourth case will study the visualization of a binary black hole system surrounded by a magnetized accretion disk (BBHD). These BBHDs correspond to the simulations discussed in [7]. In these cases, the spins of the black holes are tilted with respect to the orbital angular momentum. The visualizations we will make of these BBHDs will use techniques discussed in all of the earlier case studies. We will use the following simulation output databases: rho b.file *.h5 : HDF5 data of the fluid rest-mass density \u03c10 Bx.file *.h5, By.file *.h5, Bz.file *.h5 : HDF5 data of the magnetic field particles.mon : ASCII file containing the locations of a number of fluid particles vx.file *.h5, vy.file *.h5, vz.file *.h5 : HDF5 data of the magnetic field h.t*.ah1.gp, h.t*.ah2.gp, h.t*.ah3.gp : Set of points on the apparent horizon of the two black holes in the binary (ah1 and ah2) and the remnant black hole (ah3). Set of points on the apparent horizon of the two black holes in the binary (ah1 and ah2) and the remnant black hole (ah3). : ASCII black hole diagnostic file containing information about the location of the two black holes in the binary (ah1 and ah2) and the remnant black hole (ah3). BHspin.ah1.mon, BHspin.ah2.mon, BHspin.ah3.mon : ASCII file containing the spin vector data of the two black holes in the binary (ah1 and ah2) and the remnant black hole (ah3) Since the BBHDs have a lot of similarities with BHDs (Sec. 7), the visualizations we will make are very similar: Volume plot of log ( \u03c10 \u2044 \u03c10(0) ), which will visualize the accretion disk. Pseudocolor plot of the apparent horizon of the black holes. Vector plot of the black hole spins. Integral curve plot of magnetic field seeded by grid seeds around the black holes. Integral curve plot of magnetic field seeded by particles inside the disk. The volume plot of log ( \u03c10 \u2044 \u03c10(0) ) follows the same procedure described in Sec. 7.2. Here, we are using a different colorbar with fewer colors since we aren\u2019t trying to emphasize the structure of the disk with our visualizations (see Fig. 64 for the colorbar).","title":"Case Study: Binary Black Hole with Accretion Disk"},{"location":"Section9/#magnetic-field-lines-in-the-disk","text":"We will start by drawing the magnetic field lines seeded by particles inside the disk. This follows a similar procedure that we used to draw magnetic field lines inside the rotating neutron stars in Sec. 6. The difference here is that the structure of a disk (a toroid) is different from that of a neutron star (an ellipsoid). So in order to place particles inside the disk, we must choose the radius and height of our ring of seed points with some thought. If we create a 2D plot of the xz-slice of the rho b density database (Fig. 63), we can see estimate the inner radius rin, the outer radius rout, and the height hdisk of the disk. The colorbar in the 2D plot is the density normalized by the initial max density. If we take the disk to be the regions where the disk density is not zero (the dark blue), we estimate that rin \u2248 25, rout \u2248 150, and hdisk \u2248 50 in code units (G = c = M\u2299 = 1). For an initial guess to use in seedmaker.py (Code Lst. 5.3.1), we choose a pair (r, h) with rin < r < rout and h < hdisk. Note that the center of mass of the disk is at the origin and that its magnetic field is poloidal with respect to the z axis. Our final seed points end up being centers = [(0., 0., 0.)] pairs = [(90, 10)] spins = [(0., 0., 1.)] num seeds per ring = [12] offsets = [0.] Figure 63: 2D xz-slice of the density data. using the Leapfrog integrator with maxSteps=2200 and maxStepLength=300. Remember that we pick particles from paritcles.mon that are closest to our chosen seed points and drawn the magnetic field lines from these particles for the entire evolution. The field lines drawn using these particles and integration settings at the first time as well as a time later on in the evolution are shown in Fig. 64. Notice how the magnetic field lines twist at the later time due to the differential rotation of the accretion disk. (a) Initial Data (b) Later Time Figure 64: Magnetic field lines inside accretion disk","title":"Magnetic Field Lines in the Disk"},{"location":"Section9/#two-black-holes","text":"Next, we will discuss the main difference between BHDs and BBHDs. In particular, we will be working with three sets of black hole data. Two sets correspond to the two black holes in the original binary black hole system and another one corresponds to the remnant black hole after the merger. Even though there are three sets of data, there will only be a maximum of two black holes present in our visualizations. That is, data for the two black holes in the binary will not be plotted at frames where data for the remnant black hole exist. After merger, when we have a single black hole, the plots will be the same as the plots made of BHDs in Sec. 7 and of the remnant black hole in the NSNS merger in Sec. 8. So in this section, we will focus on visualizing BBHDs prior to merger. Before the merger, we are working with two sets of black hole data. To start, we will process the h.t .ah1.gp and h.t.ah2.gp files into bh1 .3d and bh2 *.3d files as described in 5.1. Make sure to use a separate variable name in the fourth column of the .3d files (the variable name is bh1p in Code Lst. 5.1) to differentiate between the two black holes in VisIt (for example, bh1p and bh2p). Then plotting the horizon for each black hole involves creating two separate Pseudocolor plots. For example, after opening up the two .3d databases, we can create two separate plots using Code Lst. 9.2. 1 ActivateDatabase(\"/path/to/bh1.3d\") 2 AddPlot(\"Pseudocolor\", \"bh1p\") #plot index 0 3 SetActivePlots(0) 4 ... #apply pseudo options 5 ActivateDatabase(\"/path/to/bh2.3d\") 6 AddPlot(\"Pseudocolor\", \"bh2p\") #plot index 1 7 SetActivePlots(1) 8 ... #apply pseudo options Code Listing 9.2: Creating two black hole plots Figure 65: Plotting Two Black Holes and Spin Vectors Example Similarly, we will process BHspin.ah1.mon and BHspin.ah2.mon into spin vec1.vtk and spin vec2.vtk files, making sure to use different variable names (the variable name is spinvec in Code Lst. 5.1). Then we create two separate Vector plots. When applying the box operator to the Vector plots to center the spin vector on the black hole, remember to use the location from the respective black hole. Recall that this can either be acquired from the correct row of the BH diagnoistics file or by taking the average of all the points in the .3d file. The spin vector data in the BHspin.mon files contain information about the spin magnitude as well, so as long as the vector plots for each black hole are scaled with the same scaling factor, the plot will correctly reflect the magnitude. Below in Fig. 65, we show the initial data for the BBHD where the black holes have a 2:1 mass ratio and the spins are tilted 45\u25e6 above the orbital plane. Now we will discuss visualizing the magnetic field lines seeded by grid points around each black hole. Remember in the BHD case (Sec. 7.3), we created rings of seed points above and below the black hole with respect to the black hole spin that follow changes in the black hole\u2019s spin and position. It is even more important for the rings to follow the black holes in the BBHD case since the black holes orbit each other. Like with the BHDs, for each black hole, we create rings of points by choosing (radius, height) as fractions of the average black hole radius r bh (which is calculated for each black hole as described in 7.3). After experimentation, we found that using (r, h) = (0.5 bh r, 1.5 bh r) works well. From previous steps, we already know the centers of the two black holes (x1, y1, z1) and (x2, y2, z2) (from either the BH diagnostic files or the .3d files we created). We also know the spins of the black holes (Jx bh1, Jy bh1, Jz bh1) and (Jx bh2, Jy bh2, Jz bh2). from the BHspin.mon files. For the first black hole, we set the fields in seed maker.py to centers = [(x1, y1, z1)] pairs = [(0.5*bh1 r, 1.5*bh1 r)] spins = [(Jx bh1, Jy bh1, Jz bh1)] and likewise for the second black hole centers = [(x2, y2, z2)] pairs = [(0.5*bh2 r, 1.5*bh2 r)] spins = [(Jx bh2, Jy bh2, Jz bh2)] We\u2019ve left out the num seeds per ring parameter since the best choice depends on the mass of the black hole. For example, in the 1:1 mass ratio case, we choose to set this parameter to 8 for each black hole. However, for the 4:1 mass ratio case, we choose to only use 4 per ring for the smaller black hole (still having 8 seeds per ring for the larger one). Below in Fig. 66, we show magnetic fields seeded by grid points around the black holes for the 1:1, 2:1, and 4:1 mass ratio binary BHD cases. (a) 1:1 Mass Ratio (b) 2:1 Mass Ratio (c) 4:1 Mass Ratio Figure 66: Magnetic field lines around black holes in a black hole binary system.","title":"Two Black Holes"}]}